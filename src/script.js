import * as THREE        from 'three';
import Stats             from 'three/examples/jsm/libs/stats.module.js';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import * as dat from 'dat.gui';

/*This software is licensed under the GNU General Public License (GPL-3.0). For more information, visit <https://www.gnu.org/licenses/>.

The Interactive 3D Solar System Simulation shows the precession / eccentricity / inclination / obliquity / perihelion date movements of Earth, Moon, Sun and Planets modelled from a geo-heliocentric frame of reference, coming together in a Holistic-Year cycle, an Axial precession cycle (holisticyearLength/13), an Inclination precession cycle (holisticyearLength/3) and a Perihelion precession cycle (holisticyearLength/16).

Earths solar system movements and observations for length of day/year can be exactly simulated by tuning ~20 parameters. Additionally with ~10 parameters per planet/moon our complete solar system appears.

For more information, see https://holisticuniverse.com */

//*************************************************************
// ALL INPUT CONSTANTS
//*************************************************************
const holisticyearLength = 333888;
// Input Length of Holistic-Year in Years
const perihelionalignmentYear = 1246;
// Last YEAR longitude of perihelion aligned with solstice (according to J. Meeus around 1246 AD)
const perihelionalignmentJD = 2176142;
// Last YEAR longitude of perihelion aligned with solstice (according to J. Meeus around 1246 AD) in Juliandate
const inputmeanlengthsolaryearindays = 365.2421897;
// Reference length of solar year in days. THIS IS USED AS INPUT. The actual mean lenght is calculated based upon this input and the lenght of the holistic year
const meansiderealyearlengthinSeconds = 31558153.82478;
// Reference length of sidereal year in seconds = MEAN of sinusoidal variation (at phase 90°/270°, years ~6463/16897 AD)
const startmodelJD = 2451716.5;
// By default the model is pointing to the June Solstice in year 2000. Value in Juliandate and dates need to start at 00:00 (so only julianday with values of 0.5). IF YOU CHANGE THIS VALUE, ALSO OTHER VALUES NEED TO CHANGE.
const startmodelYear = 2000.5;
// By default the model is pointing to the June Solstice in year 2000. IF YOU CHANGE THIS VALUE, ALSO OTHER VALUES NEED TO CHANGE.
const whichSolsticeOrEquinox = 1;
// By default the model is pointing to the June Solstice (=1). Possible values: 0 = March Equinox, 1 = June Solstice, 2 = September Equinox, 3= December Solstice. IF YOU CHANGE THIS VALUE, ALSO OTHER VALUES NEED TO CHANGE.
const correctionDays = -0.231598615646362;
// Small correction in days because the startmodel on 21 june 00:00 UTC is not exactly aligned with Solstice + to make sure the juliandate is with exact rounded numbers in the Balanced year
const correctionSun = 0.277377;
// Small correction in degrees because the startmodel on 21 june 00:00 UTC is not exactly aligned with Solstice but needs to be around 01:47 UTC See https://www.timeanddate.com/calendar/seasons.html?year=2000&n=1440.
const temperatureGraphMostLikely = 14.5;
// 3D model = Choose from 0 to 16, with steps of 0.5 where we are in our obliquity cycle (so 32 options). If you change this value, also the earthRAAngle value will change and depending if you make it an whole or a half value you need to make earthInvPlaneInclinationAmplitude negative/positive. Value 14.5 means in 1246 we were 14.5/16 * holistic year length on our journey calculated from the balanced year so - relatively - almost nearing a new balanced year.
const earthRAAngle = 1.258454;
// 3D model = the only value which is very hard to derive. Determined by temperatureGraphMostLikely, earthtiltMean & earthInvPlaneInclinationAmplitude values.
const earthtiltMean = 23.41398;                           // 3D model + formula (optimized for IAU 2006)
const earthInvPlaneInclinationAmplitude = 0.633849;       // 3D model + formula (optimized for IAU 2006 rate)
const earthInvPlaneInclinationMean = 1.481592;            // 3D model + Formula
const eccentricityMean = 0.015321;                        // 3D model + formula = aligned needs to be 102.9553 on startdate 2000-06-21 in order 2000-01-01 was ~102.947
const eccentricityAmplitude = 0.0014226;                  // 3D model + formula = aligned needs to be 102.9553 on startdate 2000-06-21 in order 2000-01-01 was ~102.947
const eccentricitySinusCorrection = 0.8;                  // Formula only
const mideccentricitypointAmplitude = 2.4587;             // Formula only
const helionpointAmplitude = 5.05;                        // Formula only
const meansiderealyearAmplitudeinSeconds = -4.418496;     // Formula only
const meansolardayAmplitudeinSeconds = 0.00219;           // Formula only 
const meansolaryearAmplitudeinDays = 0.000023;            // Formula only
const currentAUDistance = 149597870.698828;               // 3D model + formula
const speedofSuninKM = 107225.048580526;                  // Formula only
const speedOfLight = 299792.458;                          // Speed of light in km/s (fundamental constant)
const deltaTStart = 63.63;                                // Formula only ; usage in delta-T is commented out by default (see render loop)
const startAngleModel = 89.91949879;                      // The startdate of the model is set to 21 june 2000 00:00 UTC which is just before it reaches 90 degrees which is at 01:47 UTC (89.91949879)
const earthPerihelionICRFYears = holisticyearLength/3;    // Duration of Earth's orbital plane precession (holisticyearLength/3) against ICRF

// Debg button on flag (set to true when needed)
const debugOn = false;

// Reference lengths used as INPUT for the Sun
const sunTilt = 7.155;
const milkywayDistance = 27500;
const sunSpeed = 828000;
const greatattractorDistance = 200000000;
const milkywaySpeed = 2160000;

// Reference lengths used as INPUT for the Moon
const moonSiderealMonthInput = 27.32166156;
const moonAnomalisticMonthInput = 27.55454988;
const moonNodalMonthInput = 27.21222082;
const moonDistance = 384399.07;
const moonAtApogee = 405400;                              // Moon's apogee distance in km
const moonEclipticInclinationJ2000 = 5.1453964;
const moonOrbitalEccentricity = 0.054900489;
const moonTilt = 6.687;
const moonStartposApsidal = 330;                          // Aligned with stellarium data.
const moonStartposNodal = 64;                             // Aligned to major lunar standstill and minor lunar standstill
const moonStartposMoon = 132.105;                         // Needs to be at ~21h09m57s if start model is 2451716.5

// Reference lengths used as INPUT for Mercury
const mercurySolarYearInput = 87.96855;
const mercuryEclipticInclinationJ2000 = 7.00497902;       // JPL J2000
const mercuryOrbitalEccentricity = 0.20563593;            // JPL J2000
const mercuryInvPlaneInclinationJ2000 = 6.3472858;
const mercuryTilt = 0.03;
const mercuryLongitudePerihelion = 77.4569131;
const mercuryAscendingNode = 48.33033155;                 // SPICE 48.33033155 (JPL J2000 48.33076593)
const mercuryMeanAnomaly = 156.6364301;                   // Reference only
const mercuryTrueAnomaly = 164.1669319;                   // Reference only
const mercuryAngleCorrection = 0.984366;                  // To align the perihelion exactly
const mercuryPerihelionICRFYears = holisticyearLength/(1+(5/13)); // Duration of perihelion precession to explain ~574 arcseconds per century
const mercuryStartpos = 86.25;                            // Needs to be at ~7h24m46.43 if start model is 2451716.5

// Reference lengths used as INPUT for Venus
const venusSolarYearInput = 224.6958;
const venusEclipticInclinationJ2000 = 3.39467605;         // JPL J2000
const venusOrbitalEccentricity = 0.00677672;              // JPL J2000
const venusInvPlaneInclinationJ2000 = 2.1545441;
const venusTilt = 2.6392;
const venusLongitudePerihelion = 131.5765919;
const venusAscendingNode = 76.67877109;                   // SPICE 76.67877109 (JPL J2000 76.67984255)
const venusMeanAnomaly = 324.9668371;                     // Reference only
const venusTrueAnomaly = 324.5198504;                     // Reference only
const venusAngleCorrection = -2.782986;                    // To align the perihelion exactly
const venusPerihelionICRFYears = holisticyearLength*2;    // Duration of perihelion precession to explain ~200 arcseconds per century
const venusStartpos = 249.68;                             // Needs to be at ~6h11m08.61 if start model is 2451716.5 (34.715?)

// Reference lengths used as INPUT for Mars
const marsSolarYearInput = 686.934;
const marsEclipticInclinationJ2000 = 1.84969142;          // JPL J2000
const marsOrbitalEccentricity = 0.09339410;               // JPL J2000
const marsInvPlaneInclinationJ2000 = 1.6311858;
const marsTilt = 25.19;  
const marsLongitudePerihelion = 336.0650681;
const marsAscendingNode = 49.55737662;                    // SPICE 49.55737662 (JPL J2000 49.55953891)
const marsMeanAnomaly = 109.2630844;                      // Reference only
const marsTrueAnomaly = 118.9501056;                      // Reference only
const marsAngleCorrection = -2.10564;                    // To align the perihelion exactly
const marsPerihelionICRFYears = holisticyearLength/(4+(5/13)); // Duration of perihelion precession to explain ~1600 arcseconds per century
const marsStartpos = 121.514;                             // Needs to be at ~6h13m09.72 if start model is 2451716.5

// Reference lengths used as INPUT for Jupiter
const jupiterSolarYearInput = 4330.595;
const jupiterEclipticInclinationJ2000 = 1.30439695;       // JPL J2000
const jupiterOrbitalEccentricity = 0.04838624;            // JPL J2000
const jupiterInvPlaneInclinationJ2000 = 0.3219652;
const jupiterTilt = 3.13;
const jupiterLongitudePerihelion = 14.70659401;
const jupiterAscendingNode = 100.4877868;                 // SPICE = 100.4877868 (JPL J2000 100.47390909)
const jupiterMeanAnomaly = 32.47179744;                   // Reference only
const jupiterTrueAnomaly = 35.69428061;                   // Reference only
const jupiterAngleCorrection = 1.097601;                  // To align the perihelion exactly
const jupiterPerihelionICRFYears = holisticyearLength/5;  // Duration of perihelion precession to explain ~2000 arcseconds per century
const jupiterStartpos = 13.79;                            // Needs to be at ~3h43m48.25 if start model is 2451716.5

// Reference lengths used as INPUT for Saturn
const saturnSolarYearInput = 10745.6;
const saturnEclipticInclinationJ2000 = 2.48599187;        // JPL J2000
const saturnOrbitalEccentricity = 0.05386179;             // JPL J2000
const saturnInvPlaneInclinationJ2000 = 0.9254704;
const saturnTilt = 26.73;
const saturnLongitudePerihelion = 92.12794343;
const saturnAscendingNode = 113.6452856;                  // SPICE = 113.6452856 (JPL J2000 113.66242448)
const saturnMeanAnomaly = 325.663876;                     // Reference only
const saturnTrueAnomaly = 321.7910116;                    // Reference only
const saturnAngleCorrection = -0.175436;                  // To align the perihelion exactly
const saturnPerihelionICRFYears = -holisticyearLength/8;  // Duration of perihelion precession to explain ~-3500 arcseconds per century
const saturnStartpos = 11.344;                            // Needs to be at ~3h34m49.4 if start model is 2451716.5

// Reference lengths used as INPUT for Uranus
const uranusSolarYearInput = 30583;
const uranusEclipticInclinationJ2000 = 0.77263783;        // JPL J2000
const uranusOrbitalEccentricity = 0.04725744;             // JPL J2000
const uranusInvPlaneInclinationJ2000 = 0.9946692;
const uranusTilt = 82.23;
const uranusLongitudePerihelion = 170.7308251;
const uranusAscendingNode = 74.00919023;                  // SPICE 74.00919023 (JPL J2000 74.01692503)
const uranusMeanAnomaly = 145.7292678;                    // Reference only
const uranusTrueAnomaly = 148.5142459;                    // Reference only
const uranusAngleCorrection = -0.774123;                  // To align the perihelion exactly
const uranusPerihelionICRFYears = holisticyearLength/3;   // Duration of perihelion precession to explain ~1200 arcseconds per century
const uranusStartpos = 44.676;                            // Needs to be at ~21h32m43.04 if start model is 2451716.5

// Reference lengths used as INPUT for Neptune
const neptuneSolarYearInput = 59926;
const neptuneEclipticInclinationJ2000 = 1.77004347;       // JPL J2000
const neptuneOrbitalEccentricity = 0.00859048;            // JPL J2000
const neptuneInvPlaneInclinationJ2000 = 0.7354155;
const neptuneTilt = 28.32;
const neptuneLongitudePerihelion = 45.80124471;
const neptuneAscendingNode = 131.7853754;                 // SPICE 131.7853754 (JPL J2000 131.78422574)
const neptuneMeanAnomaly = 262.5003424;                   // Reference only
const neptuneTrueAnomaly = 261.2242728;                   // Reference only
const neptuneAngleCorrection = 2.400885;                  // To align the perihelion exactly
const neptunePerihelionICRFYears = holisticyearLength*2;  // Duration of perihelion precession to explain ~-400 arcseconds per century
const neptuneStartpos = 47.917;                           // Needs to be at ~20h33m40.34 if start model is 2451716.5

//*************************************************************
// The accurate orbits of Pluto and Halleys and Eros can be added later. They are switched off via the visibility flag.
//*************************************************************

// Reference lengths used as INPUT for Pluto
const plutoSolarYearInput = 90465;               // JPL Horizons J2000 (was 89760)
const plutoEclipticInclinationJ2000 = 17.14001;  // JPL Horizons J2000 (was 17.14175)
const plutoOrbitalEccentricity = 0.2488273;      // JPL Horizons J2000 (was 0.24880766)
const plutoInvPlaneInclinationJ2000 = 15.5639473;// From Souami & Souchay (2012) - KEEP UNCHANGED
const plutoTilt = 57.47;
const plutoLongitudePerihelion = 224.06891;      // JPL Horizons J2000 (was 224.06676)
const plutoAscendingNode = 110.30393;            // JPL Horizons J2000 (was 110.30347)
const plutoMeanAnomaly = 15.55009;               // JPL Horizons J2000 (was 15.83341625)
const plutoTrueAnomaly = 26.31965048;            // Calculated from M=15.55009°, e=0.2488273 (was 26.51719941)
const plutoAngleCorrection = 2.469281;           // To align the perihelion exactly
const plutoPerihelionICRFYears = holisticyearLength; // Duration of perihelion precession to explain TODO arcseconds per century
const plutoStartpos = 71.555;                    // Needs to be at ~16h44m12.72 if start model is 2451716.5

// Reference lengths used as INPUT for Halleys
const halleysSolarYearInput = 27503;             // JPL Horizons J2000 (was 27618)
const halleysEclipticInclinationJ2000 = 162.26269; // JPL Horizons J2000 (was 162.192203847561)
const halleysOrbitalEccentricity = 0.96714291;   // JPL Horizons J2000 (was 0.9679427911271)
const halleysInvPlaneInclinationJ2000 = 150;     // ⚠ PLACEHOLDER: Needs research for retrograde orbit
const halleysTilt = 0;
const halleysLongitudePerihelion = 111.33249;    // JPL Horizons J2000 (was 172.033036745069, CRITICAL: ~60° correction)
const halleysAscendingNode = 58.42008;           // JPL Horizons J2000 (was 59.5607834844014)
const halleysMeanAnomaly = 38.77481;             // JPL Horizons J2000 (was 13, TODO placeholder)
const halleysTrueAnomaly = 166.26774708;         // Calculated from M=38.77481°, e=0.96714291 (was 13 placeholder)
const halleysAngleCorrection = -1.619816;        // To align the perihelion exactly
const halleysPerihelionICRFYears = holisticyearLength; // Duration of perihelion precession to explain TODO arcseconds per century
const halleysStartpos = 80;                      // Needs to be at ~08h43m12.79 if start model is 2451716.5

// Reference lengths used as INPUT for Eros
const erosSolarYearInput = 642.93;               // JPL Horizons J2000 (was 643.22295)
const erosEclipticInclinationJ2000 = 10.82760;   // JPL Horizons J2000 (was 10.8290328658513)
const erosOrbitalEccentricity = 0.2229512;       // JPL Horizons J2000 (was 0.222807894458402)
const erosInvPlaneInclinationJ2000 = 9.25;       // Estimated (ecliptic - Earth offset) - Keep unchanged
const erosTilt = 0;
const erosLongitudePerihelion = 178.81322;       // JPL Horizons J2000 (was 123.054362100533, CRITICAL: ~56° correction)
const erosAscendingNode = 304.30993;             // JPL Horizons J2000 (was 304.411578580454)
const erosMeanAnomaly = 320.21552;               // JPL Horizons J2000 (was 153.67797646)
const erosTrueAnomaly = 299.91713740;            // Calculated from M=320.21552°, e=0.2229512 (was 162.69081884)
const erosAngleCorrection = 0.047888;            // To align the perihelion exactly
const erosPerihelionICRFYears = holisticyearLength; // Duration of perihelion precession to explain TODO arcseconds per century
const erosStartpos = 57.402;                     // Needs to be at ~20h38m24.47 if start model is 2451716.5

// Reference lengths used as INPUT for Ceres
const ceresSolarYearInput = 1680.5;              // JPL Horizons J2000
const ceresEclipticInclinationJ2000 = 10.59407;  // JPL Horizons J2000 (was 10.58682)
const ceresOrbitalEccentricity = 0.0755347;      // JPL Horizons J2000 (was 0.07913825)
const ceresInvPlaneInclinationJ2000 = 0.4331698; // Souami & Souchay (2012) Table 2 - Real data!
const ceresTilt = 4;                             // Dawn spacecraft measurement (~4°)
const ceresLongitudePerihelion = 73.59769;       // JPL Horizons J2000
const ceresAscendingNode = 80.30533;             // JPL Horizons J2000
const ceresMeanAnomaly = 95.98772;               // JPL Horizons J2000
const ceresTrueAnomaly = 104.48097667;           // Calculated from M=95.98772°, e=0.0755347
const ceresAngleCorrection = 0;                  // To align the perihelion exactly
const ceresPerihelionICRFYears = holisticyearLength; // Duration of perihelion precession
const ceresOrbitDistance = 2.76596;              // JPL Horizons J2000

// Ascending nodes on invariable plane (from Souami & Souchay 2012, Table 9)
// These are DIFFERENT from <planet>AscendingNode which is on the ecliptic!
// Units: degrees at J2000.0 epoch
const earthAscendingNodeInvPlaneSouamiSouchay = 284.51;  // Precesses with period holisticyearLength/3 against ICRF which is holisticyearLength/5 against ecliptic
const mercuryAscendingNodeInvPlaneSouamiSouchay = 32.22;
const venusAscendingNodeInvPlaneSouamiSouchay = 52.31;
const marsAscendingNodeInvPlaneSouamiSouchay = 352.95;
const jupiterAscendingNodeInvPlaneSouamiSouchay = 306.92;
const saturnAscendingNodeInvPlaneSouamiSouchay = 122.27;
const uranusAscendingNodeInvPlaneSouamiSouchay = 308.44;
const neptuneAscendingNodeInvPlaneSouamiSouchay = 189.28;
const plutoAscendingNodeInvPlaneSouamiSouchay = 107.06;
const halleysAscendingNodeInvPlaneSouamiSouchay = 59.56; // Approximation from ecliptic value
const erosAscendingNodeInvPlaneSouamiSouchay = 10.36;    // Approximation from ecliptic value
const ceresAscendingNodeInvPlaneSouamiSouchay = 80.89;   // From Souami & Souchay (2012) Table 2

// J2000-verified ascending nodes - optimized to reproduce exact J2000 ecliptic inclinations
// These use the existing <planet>Inclination values (Souami & Souchay 2012) and only adjust ascending nodes
// Earth's ascending node is set the same as Souami & Souchay value
// Result: All planets match J2000 EclipticInclinationJ2000 values with error < 0.0001°
const earthAscendingNodeInvPlaneVerified = 284.51;       // Souami & Souchay (2012)
const mercuryAscendingNodeInvPlaneVerified = 32.83;      // was 32.22, Δ = +0.61° (from S&S)
const venusAscendingNodeInvPlaneVerified = 54.70;        // was 52.31, Δ = +2.39° (from S&S)
const marsAscendingNodeInvPlaneVerified = 354.87;        // was 352.95, Δ = +1.92° (from S&S)
const jupiterAscendingNodeInvPlaneVerified = 312.89;     // was 306.92, Δ = +5.97° (from S&S)
const saturnAscendingNodeInvPlaneVerified = 118.81;      // was 122.27, Δ = -3.46° (from S&S)
const uranusAscendingNodeInvPlaneVerified = 307.80;      // was 308.44, Δ = -0.64° (from S&S)
const neptuneAscendingNodeInvPlaneVerified = 192.04;     // was 189.28, Δ = +2.76° (from S&S)
const plutoAscendingNodeInvPlaneVerified = 101.06;       // was 107.06, Δ = -6.00° (from S&S)
const halleysAscendingNodeInvPlaneVerified = 59.56;      // Approximation from ecliptic value
const erosAscendingNodeInvPlaneVerified = 10.36;         // Approximation from ecliptic value
const ceresAscendingNodeInvPlaneVerified = 80.89;        // From Souami & Souchay (2012) Table 2

// ══════════════════════════════════════════════════════════════════════════════
// PLANETARY INCLINATION OSCILLATION AMPLITUDES
// These represent how much each planet's orbital plane tilts toward/away from
// the invariable plane during its precession cycle.
//
// Scientific basis: Laplace-Lagrange secular theory (Farside physics textbook, Table 10.4)
// Source: https://farside.ph.utexas.edu/teaching/celestial/Celestial/node91.html
// These are theoretical bounds from Table 10.4:
// - Mercury: 4.57° to 9.86°
// - Venus: 0.00° to 3.38° (we use 0.72° to 4.11° for J2000 calibration)
// - Earth: 0.00° to 2.95° (we use 0.93° to 2.06° for J2000 calibration)
// - Mars: 0.00° to 5.84°
// - Jupiter: 0.241° to 0.489°
// - Saturn: 0.797° to 1.02° (we use 0.43° to 1.53° expanded for retrograde)
// - Uranus: 0.902° to 1.11°
// - Neptune: 0.554° to 0.800°
//
// Alternative derivation from JPL secular rates (°/century):
// A = |rate| × |period| / (2π)
// This gives smaller values as it assumes we're near maximum rate.
//
// We use the Laplace-Lagrange derived amplitudes as they represent the full
// oscillation envelope are based on analytical eigenmode calculations.
// The period for each planet equals its <planet>PerihelionICRFYears constant (earthPerihelionICRFYears for Earth).
// ══════════════════════════════════════════════════════════════════════════════

// Mercury: Range 4.57° to 9.86° (from Laplace-Lagrange)
// J2000=6.3472858° (EXACT), phase 203.3195°, period holisticyearLength/(1+(5/13)), trend error: 0.8"/cy
const mercuryInvPlaneInclinationMean = 6.347540;
const mercuryInvPlaneInclinationAmplitude = 0.000258;  // Range: 6.35° to 6.35°

// Venus: Range 0.72° to 4.11° (from Laplace-Lagrange)
// J2000=2.1545441° (EXACT), phase 203.3195°, period holisticyearLength*2, trend error: 18.3"/cy
// Note: Large error due to long period - Venus motion too slow to counteract Earth's contribution
const venusInvPlaneInclinationMean = 3.055471;
const venusInvPlaneInclinationAmplitude = 1.055286;  // Range: 2.00° to 4.11°

// Mars: Range 0.00° to 5.84° (from Laplace-Lagrange)
// J2000=1.6311858° (EXACT), phase 203.3195°, period holisticyearLength/(4+(5/13)), trend error: 16.6"/cy
const marsInvPlaneInclinationMean = 3.600460;
const marsInvPlaneInclinationAmplitude = 2.239753;  // Range: 1.36° to 5.84°

// Jupiter: Range 0.241° to 0.489° (from Laplace-Lagrange)
// J2000=0.3219652° (EXACT), phase 203.3195°, period holisticyearLength/5, trend error: 0.3"/cy
const jupiterInvPlaneInclinationMean = 0.363200;
const jupiterInvPlaneInclinationAmplitude = 0.123101;  // Range: 0.24° to 0.49°

// Saturn: Range 0.43° to 1.53° (expanded from Laplace-Lagrange)
// J2000=0.9254704° (EXACT), phase 23.3195° (retrograde), period -holisticyearLength/8, trend error: 0.0"/cy
const saturnInvPlaneInclinationMean = 0.941380;
const saturnInvPlaneInclinationAmplitude = 0.166278;  // Range: 0.78° to 1.11°

// Uranus: Range 0.902° to 1.11° (from Laplace-Lagrange)
// J2000=0.9946692° (EXACT), phase 203.3195°, period holisticyearLength/3, trend error: 1.1"/cy
const uranusInvPlaneInclinationMean = 1.017900;
const uranusInvPlaneInclinationAmplitude = 0.092904;  // Range: 0.92° to 1.11°

// Neptune: Range 0.554° to 0.800° (from Laplace-Lagrange)
// J2000=0.7354155° (EXACT), phase 203.3195°, period holisticyearLength*2, trend error: 0.4"/cy
const neptuneInvPlaneInclinationMean = 0.645100;
const neptuneInvPlaneInclinationAmplitude = 0.092094;  // Range: 0.55° to 0.74°

// Pluto: Range 15.0° to 16.5° (estimated)
// J2000=15.5639473° (EXACT), phase 203.3195°, period holisticyearLength, trend error: 4.2"/cy
const plutoInvPlaneInclinationMean = 15.716200;
const plutoInvPlaneInclinationAmplitude = 0.717024;  // Range: 15.00° to 16.43°

// Halleys: Estimated from near-Earth asteroid dynamics
// Ecliptic inclination ~162.26269°, Earth offset ~1.58°, gives ~150° to invariable plane
const halleysInvPlaneInclinationMean = 150;
const halleysInvPlaneInclinationAmplitude = 0.1;     // Estimated oscillation

// Eros: Estimated from near-Earth asteroid dynamics
// Ecliptic inclination ~10.83°, Earth offset ~1.58°, gives ~9.25° to invariable plane
const erosInvPlaneInclinationMean = 9.25;
const erosInvPlaneInclinationAmplitude = 0.5;     // Estimated oscillation

// Ceres: From Souami & Souchay (2012) Table 2
// Inclination to invariable plane at J2000: 0.4331698° (defined above in Ceres parameters section)
const ceresInvPlaneInclinationMean = 0.43;
const ceresInvPlaneInclinationAmplitude = 0.05;   // Estimated (no Laplace-Lagrange data for asteroids)

// ══════════════════════════════════════════════════════════════════════════════
// PLANETARY INCLINATION PHASE ANGLES
//
// All planets use a universal phase angle derived from the s₈ eigenmode of
// Laplace-Lagrange secular theory (γ₈ = 202.8°).
//
// PROGRADE precession planets use: 203.3195°
// RETROGRADE precession planets use: 23.3195° (= 203.3195° - 180°)
//
// The 180° offset for retrograde planets compensates for the reversed direction
// of precession - both values represent the same physical direction in space.
// ══════════════════════════════════════════════════════════════════════════════

const mercuryInclinationPhaseAngle = 203.3195;  // prograde, decreasing trend, error: 0.5"/cy
const venusInclinationPhaseAngle = 203.3195;    // prograde, decreasing trend, error: 21.2"/cy
const earthInclinationPhaseAngle = 203.3195;    // prograde, decreasing trend (reference)
const marsInclinationPhaseAngle = 203.3195;     // prograde, decreasing trend, error: 13.1"/cy
const jupiterInclinationPhaseAngle = 203.3195;  // prograde, decreasing trend, error: 0.0"/cy
const saturnInclinationPhaseAngle = 23.3195;    // RETROGRADE, increasing trend, error: 0.0"/cy
const uranusInclinationPhaseAngle = 203.3195;   // prograde, decreasing trend, error: 1.0"/cy
const neptuneInclinationPhaseAngle = 203.3195;  // prograde, increasing trend, error: 0.2"/cy
const plutoInclinationPhaseAngle = 203.3195;    // prograde, decreasing trend, error: 5.1"/cy
const halleysInclinationPhaseAngle = 23.3195;   // RETROGRADE (estimated)
const erosInclinationPhaseAngle = 203.3195;     // prograde (estimated)
const ceresInclinationPhaseAngle = 203.3195;    // prograde (estimated)

// ══════════════════════════════════════════════════════════════════════════════
// JPL ECLIPTIC INCLINATION TREND RATES (degrees/century)
// ══════════════════════════════════════════════════════════════════════════════
// Source: JPL Approximate Positions of the Planets
// https://ssd.jpl.nasa.gov/planets/approx_pos.html
// These are the target rates that our model should reproduce for verification.
// ══════════════════════════════════════════════════════════════════════════════
const mercuryEclipticInclinationTrendJPL = -0.00595;  // degrees/century (DECREASING)
const venusEclipticInclinationTrendJPL = -0.00079;    // degrees/century (DECREASING)
const marsEclipticInclinationTrendJPL = -0.00813;     // degrees/century (DECREASING)
const jupiterEclipticInclinationTrendJPL = -0.00184;  // degrees/century (DECREASING)
const saturnEclipticInclinationTrendJPL = +0.00194;   // degrees/century (INCREASING)
const uranusEclipticInclinationTrendJPL = -0.00243;   // degrees/century (DECREASING)
const neptuneEclipticInclinationTrendJPL = +0.00035;  // degrees/century (INCREASING)
const plutoEclipticInclinationTrendJPL = -0.00100;    // degrees/century (estimated)

// Derived phase offset for inclination path alignment with zodiac
// The earthInvPlaneInclinationMean correction accounts for the projection offset when measuring
// angles across two planes (ecliptic vs invariable plane) - the compound angle geometry
// causes a systematic offset approximately equal to the current inclination.
// Formula: 360 - startAngleModel - (earthAscendingNodeInvPlaneVerified - earthInclinationPhaseAngle) - <number 1.5 - 2 >
const inclinationPathZodiacOffsetDeg = 360 - startAngleModel - (earthAscendingNodeInvPlaneVerified - earthInclinationPhaseAngle) - 2;

// Really fixed values
const diameters = {
  sunDiameter      : 1392684.00,
  moonDiameter     : 3474.8,
  earthDiameter    : 12756.27,
  mercuryDiameter  : 4879.40,
  venusDiameter    : 12103.60,
  marsDiameter     : 6779,
  jupiterDiameter  : 139822,
  saturnDiameter   : 116464,
  uranusDiameter   : 50724,
  neptuneDiameter  : 49244,
  plutoDiameter    : 2376.6,
  halleysDiameter  : 11,
  erosDiameter     : 16.84,
};

//*************************************************************
// ALL CONSTANTS ARE CALCULATED FROM HERE ONWARDS
//*************************************************************

//*************************************************************
// ASTRONOMICAL REFERENCE VALUES
// Used for model calibration and validation
//*************************************************************
const ASTRO_REFERENCE = {
  // ═══════════════════════════════════════════════════════════════════════════
  // J2000.0 EPOCH VALUES (Jan 1, 2000 12:00 TT, JD 2451545.0)
  // ═══════════════════════════════════════════════════════════════════════════

  // IAU 2006 Obliquity of the Ecliptic
  // Source: IAU 2006 precession model (Capitaine et al. 2003)
  // ε₀ = 84381.406" at J2000.0, rate = -46.836769"/century
  obliquityJ2000_arcsec: 84381.406,
  obliquityJ2000_deg: 84381.406 / 3600,              // = 23.439279°
  obliquityRate_arcsecPerCentury: -46.836769,
  obliquityRate_degPerCentury: -46.836769 / 3600,    // = -0.013010°/century

  // Earth's orbital inclination to the Invariable Plane at J2000.0
  // Source: Astronomical Almanac, formula: 1°34'59" - 18"×T (T in centuries from 1900)
  // At J2000 (T=1): 1°34'59" - 18" = 1°34'41" ≈ 1.57806°
  // More commonly cited value: 1.57869° (1°34'43.3")
  earthInclinationJ2000_deg: 1.57869,

  // ═══════════════════════════════════════════════════════════════════════════
  // MODEL EPOCH VALUES (June 21, 2000 00:00 UTC, JD 2451716.5)
  // Adjusted from J2000.0 for the 171.5 day offset (0.004696 centuries)
  // ═══════════════════════════════════════════════════════════════════════════

  // Time offset from J2000.0 to model start
  // J2000.0 = JD 2451545.0, Model start = JD 2451716.5
  // Offset = 171.5 days = 0.469623 years = 0.00469623 centuries
  modelEpochOffsetDays: 171.5,
  modelEpochOffsetCenturies: 171.5 / 36525,          // = 0.00469623

  // Obliquity at model epoch (June 21, 2000)
  // = obliquityJ2000 + rate × offset
  // = 84381.406" + (-46.836769" × 0.00469623) = 84381.186"
  // = 23.439279° - 0.000061° = 23.439218°
  get obliquityModelEpoch_arcsec() {
    return this.obliquityJ2000_arcsec + this.obliquityRate_arcsecPerCentury * this.modelEpochOffsetCenturies;
  },
  get obliquityModelEpoch_deg() {
    return this.obliquityModelEpoch_arcsec / 3600;   // ≈ 23.439218°
  },

  // Earth's inclination at model epoch (June 21, 2000)
  // Inclination rate: -18"/century (from Astronomical Almanac formula)
  // Change over 171.5 days: -18" × 0.00469623 = -0.085" ≈ negligible
  // For practical purposes, same as J2000 value
  earthInclinationRate_arcsecPerCentury: -18,
  get earthInclinationModelEpoch_deg() {
    const changeArcsec = this.earthInclinationRate_arcsecPerCentury * this.modelEpochOffsetCenturies;
    return this.earthInclinationJ2000_deg + changeArcsec / 3600;  // ≈ 1.57869°
  },

  // ═══════════════════════════════════════════════════════════════════════════
  // SOLSTICE REFERENCE TIMES
  // ═══════════════════════════════════════════════════════════════════════════

  // June Solstice reference times (for solstice timing validation)
  // Source: USNO / timeanddate.com astronomical tables
  juneSolstice2000_JD: 2451716.575,                  // June 21, 2000 01:48 UTC

  // ═══════════════════════════════════════════════════════════════════════════
  // PERIHELION REFERENCE VALUES (J2000.0)
  // ═══════════════════════════════════════════════════════════════════════════

  // Earth's longitude of perihelion at J2000.0
  // Source: JPL Horizons / Astronomical Almanac
  perihelionLongitudeJ2000_deg: 102.947,             // RA of perihelion in degrees

  // Earth's orbital eccentricity at J2000.0
  // Source: JPL Horizons / Astronomical Almanac
  eccentricityJ2000: 0.01671022,                     // Distance to Earth in AU (eccentricity)

  // ═══════════════════════════════════════════════════════════════════════════
  // YEAR LENGTH REFERENCE VALUES (J2000.0)
  // Source: Meeus & Savoie (1992) "The history of the tropical year"
  // Journal of the British Astronomical Association, 102(1), 40-42
  // ═══════════════════════════════════════════════════════════════════════════

  // Tropical year measured from each cardinal point (days)
  // These differ due to Earth's elliptical orbit
  tropicalYearVEJ2000: 365.242374,    // Vernal Equinox to Vernal Equinox
  tropicalYearSSJ2000: 365.241626,    // Summer Solstice to Summer Solstice
  tropicalYearAEJ2000: 365.242018,    // Autumnal Equinox to Autumnal Equinox
  tropicalYearWSJ2000: 365.242740,    // Winter Solstice to Winter Solstice

  // Mean tropical year (average of all cardinal points)
  tropicalYearMeanJ2000: 365.2421897, // Mean tropical year at J2000.0

  // Other year types
  anomalisticYearJ2000: 365.259636,   // Perihelion to perihelion
  siderealYearJ2000: 365.256363,      // Fixed star reference (one complete orbit)

  // Secular change in tropical year length
  tropicalYearRateSecPerCentury: -0.53,

  // ═══════════════════════════════════════════════════════════════════════════
  // DAY LENGTH REFERENCE VALUES (J2000.0)
  // Source: IERS Conventions / IAU definitions
  // ═══════════════════════════════════════════════════════════════════════════

  // Solar day (SI seconds) - by definition at epoch
  solarDayJ2000: 86400.0,             // Mean solar day (exact by definition)

  // Sidereal day (rotation relative to vernal equinox)
  siderealDayJ2000: 86164.09053083288,     // ~23h 56m 4.0905s

  // Stellar day (rotation relative to fixed stars)
  // Slightly longer than sidereal day due to precession
  stellarDayJ2000: 86164.0989036905,       // ~23h 56m 4.0989s
};

const perihelionCycleLength = holisticyearLength / 16;
const meansolaryearlengthinDays = Math.round(inputmeanlengthsolaryearindays * (holisticyearLength / 16)) / (holisticyearLength / 16);
const meanearthRotationsinDays = meansolaryearlengthinDays+1;
const startmodelyearwithCorrection = startmodelYear+(correctionDays/meansolaryearlengthinDays);
const balancedYear = perihelionalignmentYear-(temperatureGraphMostLikely*(holisticyearLength/16));
const balancedJD = startmodelJD-(meansolaryearlengthinDays*(startmodelyearwithCorrection-balancedYear));
const yearsFromBalancedToJ2000 = (startmodelJD - balancedJD) / meansolaryearlengthinDays;
const meansiderealyearlengthinDays = meansolaryearlengthinDays *(holisticyearLength/13)/((holisticyearLength/13)-1);
const meanlengthofday = meansiderealyearlengthinSeconds/meansiderealyearlengthinDays;
const meanSiderealday = (meansolaryearlengthinDays/(meansolaryearlengthinDays+1))*meanlengthofday;
const meanStellarday = (meanSiderealday/(holisticyearLength/13))/(meansolaryearlengthinDays+1)+meanSiderealday;
const meanAnomalisticYearinDays = ((meansolaryearlengthinDays)/(perihelionCycleLength-1))+meansolaryearlengthinDays;

//sDAY IS USED IN 3D MODEL CALCULATIONS 
const sDay = 1/meansolaryearlengthinDays;
const sYear = sDay*365;
const sMonth = sDay*30;
const sWeek = sDay*7;
const sHour = sDay/24;
const sMinute = sHour/60;
const sSecond = sMinute/60;

const lightYear = speedOfLight*meanlengthofday*meansolaryearlengthinDays;
const sunOrbitPeriod = (lightYear*milkywayDistance*Math.PI*2)/(sunSpeed/60/60*meanlengthofday*meansolaryearlengthinDays);
const milkywayOrbitPeriod = (lightYear*greatattractorDistance*Math.PI*2)/(milkywaySpeed/60/60*meanlengthofday*meansolaryearlengthinDays);

// Moon calculations
const moonSiderealMonth = (holisticyearLength*meansolaryearlengthinDays)/Math.ceil(((holisticyearLength*meansolaryearlengthinDays)/moonSiderealMonthInput)-0);
// You can tweak the last number +/-1 (See Moon characteristics)
const moonAnomalisticMonth = (holisticyearLength*meansolaryearlengthinDays)/Math.ceil(((holisticyearLength*meansolaryearlengthinDays)/moonAnomalisticMonthInput)-0);
// You can tweak the last number +/-1 (See Moon characteristics)
const moonNodalMonth = (holisticyearLength*meansolaryearlengthinDays)/Math.ceil(((holisticyearLength*meansolaryearlengthinDays)/moonNodalMonthInput)-0);
// You can tweak the last number +/-1 (See Moon characteristics)

const moonSynodicMonth = (holisticyearLength*meansolaryearlengthinDays)/(Math.ceil(((holisticyearLength*meansolaryearlengthinDays)/moonSiderealMonthInput)-1)+13-holisticyearLength);
const moonTropicalMonth = (holisticyearLength*meansolaryearlengthinDays)/(Math.ceil(((holisticyearLength*meansolaryearlengthinDays)/moonSiderealMonthInput)-1)+13);
const moonFullMoonCycleEarth = (moonSynodicMonth/(moonSynodicMonth-moonAnomalisticMonth))*moonAnomalisticMonth;
const moonFullMoonCycleICRF = (holisticyearLength*meansolaryearlengthinDays)/(((holisticyearLength*meansolaryearlengthinDays)/moonFullMoonCycleEarth)+13);
const moonNodalPrecessionindaysEarth = (moonSiderealMonth/(moonSiderealMonth-moonNodalMonth))*moonNodalMonth;
const moonNodalPrecessionindaysICRF = (holisticyearLength*meansolaryearlengthinDays)/(((holisticyearLength*meansolaryearlengthinDays)/moonNodalPrecessionindaysEarth)-13);
const moonApsidalPrecessionindaysEarth = (1/((moonAnomalisticMonth/moonSiderealMonth)-1))*moonAnomalisticMonth;
const moonApsidalPrecessionindaysICRF = (holisticyearLength*meansolaryearlengthinDays)/(((holisticyearLength*meansolaryearlengthinDays)/moonApsidalPrecessionindaysEarth)+13);
const moonApsidalMeetsNodalindays = ((moonNodalMonth/(moonAnomalisticMonth-moonNodalMonth))*moonAnomalisticMonth);
const moonRoyerCycleindays = (moonNodalPrecessionindaysEarth/(moonNodalPrecessionindaysEarth-moonApsidalPrecessionindaysEarth)*(moonApsidalPrecessionindaysEarth/meansolaryearlengthinDays))*meansolaryearlengthinDays;
const moonDraconicYearICRF = 1/((1/meansolaryearlengthinDays)+(1/moonNodalPrecessionindaysEarth));
const moonDraconicYearEarth = (holisticyearLength*meansolaryearlengthinDays)/(((holisticyearLength*meansolaryearlengthinDays)/moonDraconicYearICRF)-13);
const moonSpeed = (moonDistance*Math.PI*2)/(meansolaryearlengthinDays*(1/(meansolaryearlengthinDays/moonSiderealMonth)))/24;

// Mean AU distance derived from mean sidereal year and mean orbital speed
// meanAU = (P_seconds / 3600 * v_km/h) / (2π) = orbital circumference / 2π
const meanAUDistance = (meansiderealyearlengthinSeconds / 60 / 60 * speedofSuninKM) / (2 * Math.PI);
// Result: 149,597,870.345632 km

// Gravitational parameter of the Sun (derived from Kepler's 3rd Law)
// GM = (2π)² × a³ / P² where a = mean AU in km, P = mean sidereal year in seconds
// The 0.029% difference represents the inherent limitation of deriving GM_SUN from Kepler's law in a multi-body Solar System. Kepler's law assumes a perfect two-body system. The real Solar System is an N-body problem.
const GM_SUN = (4 * Math.PI * Math.PI * Math.pow(meanAUDistance, 3)) / Math.pow(meansiderealyearlengthinSeconds, 2);
// Result: ~1.32712 × 10¹¹ km³/s²

// Gravitational constant (km³/(kg·s²))
const G_CONSTANT = 6.6743e-20;  // 6.6743 × 10⁻¹¹ m³/(kg·s²) converted to km³/(kg·s²)

// Sun's mass derived from gravitational parameter (kg)
// M_SUN = GM_SUN / G ≈ 1.989 × 10³⁰ kg
const M_SUN = GM_SUN / G_CONSTANT;

// Earth-Moon mass ratio ≈ 81.30
// Earth is 81.3 times more massive than Moon
// TODO: Derive from orbital geometry relationship
const MASS_RATIO_EARTH_MOON = 81.3007;

// Earth+Moon system gravitational parameter from Moon's orbit (km³/s²)
// GM_system = (2π)² × a³ / P² - this gives G(M_Earth + M_Moon)
const GM_EARTH_MOON_SYSTEM = (4 * Math.PI * Math.PI * Math.pow(moonDistance, 3)) / Math.pow(moonSiderealMonth * meanlengthofday, 2);

// Solar perturbation correction factor using Moon's apogee ratio to AU
// The 1/(1 - moonApogee/AU) factor ≈ 1.00271 corrects for solar perturbation effects:
// - Kepler's law applied to Moon's orbit uses observed distance/period which include solar effects
// - At apogee, Moon is closest to Earth's Hill sphere edge, maximizing solar influence
// - The quadrupole solar perturbation (~5.6×10⁻³) scales with orbital size ratio. https://farside.ph.utexas.edu/teaching/celestial/Celestial/node100.html
// - This represents the "effective radius" reconciling Kepler-derived with measured GM values

// Earth's gravitational parameter (corrected for Moon's mass and solar perturbation)
// GM_Earth = GM_system × (ratio / (ratio + 1)) / (1 - moonApogee/AU)
const GM_EARTH = GM_EARTH_MOON_SYSTEM * (MASS_RATIO_EARTH_MOON / (MASS_RATIO_EARTH_MOON + 1)) / (1 - moonAtApogee / meanAUDistance);
// Result: ~398,600 km³/s² (matches JPL value)

// Earth's mass derived from gravitational parameter (kg)
// M_EARTH = GM_EARTH / G ≈ 5.97 × 10²⁴ kg
const M_EARTH = GM_EARTH / G_CONSTANT;

// Moon's gravitational parameter (km³/s²)
// GM_Moon = GM_system / (ratio + 1) with same solar perturbation correction
// The entire GM_EARTH_MOON_SYSTEM is affected by solar perturbation
const GM_MOON = GM_EARTH_MOON_SYSTEM / (MASS_RATIO_EARTH_MOON + 1) / (1 - moonAtApogee / meanAUDistance);
// Result: ~4,902.8 km³/s² (matches GRAIL value)

// Moon's mass derived from gravitational parameter (kg)
// M_MOON = GM_MOON / G ≈ 7.35 × 10²² kg
const M_MOON = GM_MOON / G_CONSTANT;

// Mass ratio Sun/Earth ≈ 332,946
const MASS_RATIO_SUN_EARTH = M_SUN / M_EARTH;

// ═══════════════════════════════════════════════════════════════════════════
// Planetary Mass Ratios (Sun/Planet) - From IAU/JPL measurements
// These ratios were determined from moon observations and spacecraft tracking
// GM_planet = GM_SUN / ratio, then M_planet = GM_planet / G
// ═══════════════════════════════════════════════════════════════════════════

// Mercury: No moons, mass determined from Mariner 10 and MESSENGER spacecraft
const MASS_RATIO_SUN_MERCURY = 6023625.5;            // DE440
const GM_MERCURY = GM_SUN / MASS_RATIO_SUN_MERCURY;  // ~22,032 km³/s²
const M_MERCURY = GM_MERCURY / G_CONSTANT;           // ~3.30 × 10²³ kg

// Venus: No moons, mass determined from Venera, Magellan spacecraft
const MASS_RATIO_SUN_VENUS = 408523.72;              // DE440
const GM_VENUS = GM_SUN / MASS_RATIO_SUN_VENUS;      // ~324,859 km³/s²
const M_VENUS = GM_VENUS / G_CONSTANT;               // ~4.87 × 10²⁴ kg

// Mars: Mass from Phobos/Deimos orbits and spacecraft tracking
const MASS_RATIO_SUN_MARS = 3098703.59;              // DE440
const GM_MARS = GM_SUN / MASS_RATIO_SUN_MARS;        // ~42,828 km³/s²
const M_MARS = GM_MARS / G_CONSTANT;                 // ~6.42 × 10²³ kg

// Jupiter: Mass from Galilean moon orbits (Io, Europa, Ganymede, Callisto)
const MASS_RATIO_SUN_JUPITER = 1047.348625;          // DE440
const GM_JUPITER = GM_SUN / MASS_RATIO_SUN_JUPITER;  // ~126,712,764 km³/s²
const M_JUPITER = GM_JUPITER / G_CONSTANT;           // ~1.90 × 10²⁷ kg

// Saturn: Mass from Titan and other moon orbits
const MASS_RATIO_SUN_SATURN = 3497.9018;             // DE440
const GM_SATURN = GM_SUN / MASS_RATIO_SUN_SATURN;    // ~37,940,585 km³/s²
const M_SATURN = GM_SATURN / G_CONSTANT;             // ~5.68 × 10²⁶ kg

// Uranus: Mass from moon orbits (Titania, Oberon, etc.)
const MASS_RATIO_SUN_URANUS = 22902.944;             // DE440
const GM_URANUS = GM_SUN / MASS_RATIO_SUN_URANUS;    // ~5,794,556 km³/s²
const M_URANUS = GM_URANUS / G_CONSTANT;             // ~8.68 × 10²⁵ kg

// Neptune: Mass from Triton orbit and Voyager 2 flyby
const MASS_RATIO_SUN_NEPTUNE = 19412.237;            // DE440
const GM_NEPTUNE = GM_SUN / MASS_RATIO_SUN_NEPTUNE;  // ~6,836,527 km³/s²
const M_NEPTUNE = GM_NEPTUNE / G_CONSTANT;           // ~1.02 × 10²⁶ kg

// Pluto: Mass from Charon orbit (binary system)
const MASS_RATIO_SUN_PLUTO = 136047200;              // DE440
const GM_PLUTO = GM_SUN / MASS_RATIO_SUN_PLUTO;      // ~975.5 km³/s²
const M_PLUTO = GM_PLUTO / G_CONSTANT;               // ~1.47 × 10²² kg

// Ceres: Mass from Dawn spacecraft (2015-2018)
const GM_CERES = 62.6274;                            // km³/s² (Dawn radiometric tracking)
const M_CERES = GM_CERES / G_CONSTANT;               // ~9.38 × 10²⁰ kg

// Halley's Comet: Mass estimated from size (~11×8×8 km) and density (~0.6 g/cm³)
// No spacecraft has orbited it, so mass is approximate
const M_HALLEYS = 2.2e14;                            // ~2.2 × 10¹⁴ kg (estimated)
const GM_HALLEYS = M_HALLEYS * G_CONSTANT;           // ~1.47 × 10⁻⁵ km³/s²

// 433 Eros: Mass precisely measured by NEAR Shoemaker spacecraft (2000-2001)
const M_EROS = 6.687e15;                             // 6.687 × 10¹⁵ kg (measured)
const GM_EROS = M_EROS * G_CONSTANT;                 // ~4.46 × 10⁻⁴ km³/s²

// Orbital Formulas Helper Object
// Contains functions to calculate derived orbital elements
const OrbitalFormulas = {
  // Solve Kepler's equation for Eccentric Anomaly using Newton-Raphson
  // M = E - e·sin(E)  →  solve for E given M and e
  // Input: M in degrees, e (eccentricity)
  // Output: E in degrees
  eccentricAnomaly: (M_deg, e) => {
    const M = M_deg * Math.PI / 180;
    let E = M; // Initial guess
    for (let i = 0; i < 30; i++) {
      const dE = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
      E -= dE;
      if (Math.abs(dE) < 1e-10) break;
    }
    return E * 180 / Math.PI;
  },

  // Mean motion in degrees per day
  // n = 360° / P
  meanMotion: (P_days) => 360 / P_days,

  // Semi-minor axis (AU)
  // b = a × √(1 - e²)
  semiMinorAxis: (a, e) => a * Math.sqrt(1 - e * e),

  // Perihelion distance (AU)
  // q = a × (1 - e)
  perihelionDist: (a, e) => a * (1 - e),

  // Aphelion distance (AU)
  // Q = a × (1 + e)
  aphelionDist: (a, e) => a * (1 + e),

  // Semi-latus rectum (AU)
  // p = a × (1 - e²)
  semiLatusRectum: (a, e) => a * (1 - e * e),

  // Focal distance (AU)
  // c = a × e
  focalDistance: (a, e) => a * e,

  // Heliocentric distance from true anomaly (AU)
  // r = a × (1 - e²) / (1 + e × cos(ν))
  heliocentricDist: (a, e, nu_deg) => {
    const nu = nu_deg * Math.PI / 180;
    return a * (1 - e * e) / (1 + e * Math.cos(nu));
  },

  // Flight path angle (degrees)
  // tan(γ) = e × sin(ν) / (1 + e × cos(ν))
  flightPathAngle: (e, nu_deg) => {
    const nu = nu_deg * Math.PI / 180;
    return Math.atan2(e * Math.sin(nu), 1 + e * Math.cos(nu)) * 180 / Math.PI;
  },

  // Mean longitude (degrees)
  // L = M + ϖ (mod 360°)
  meanLongitude: (M_deg, lonPerihelion_deg) => ((M_deg + lonPerihelion_deg) % 360 + 360) % 360,

  // True longitude (degrees)
  // λ = ν + ϖ (mod 360°)
  trueLongitude: (nu_deg, lonPerihelion_deg) => ((nu_deg + lonPerihelion_deg) % 360 + 360) % 360,

  // Argument of latitude (degrees)
  // u = ω + ν
  argumentOfLatitude: (omega_deg, nu_deg) => ((omega_deg + nu_deg) % 360 + 360) % 360,

  // Time since perihelion (days)
  // t = P × M / 360°
  timeSincePerihelion: (P_days, M_deg) => P_days * M_deg / 360,

  // Time to next perihelion (days)
  // t_next = P × (360° - M) / 360°
  timeToNextPerihelion: (P_days, M_deg) => P_days * (360 - M_deg) / 360,

  // Orbital velocity using vis-viva equation (km/s)
  // v = √(GM × (2/r - 1/a))
  // Input: r in km, a in km
  orbitalVelocity: (r_km, a_km) => {
    return Math.sqrt(GM_SUN * (2 / r_km - 1 / a_km));
  },

  // Perihelion velocity (km/s)
  // v_p = √(GM × (1 + e) / (a × (1 - e)))
  perihelionVelocity: (a_km, e) => {
    return Math.sqrt(GM_SUN * (1 + e) / (a_km * (1 - e)));
  },

  // Aphelion velocity (km/s)
  // v_a = √(GM × (1 - e) / (a × (1 + e)))
  aphelionVelocity: (a_km, e) => {
    return Math.sqrt(GM_SUN * (1 - e) / (a_km * (1 + e)));
  },

  // Specific orbital energy (km²/s²)
  // ε = -GM / (2a)
  specificEnergy: (a_km) => {
    return -GM_SUN / (2 * a_km);
  },

  // Specific angular momentum (km²/s)
  // h = √(GM × a × (1 - e²))
  specificAngularMomentum: (a_km, e) => {
    return Math.sqrt(GM_SUN * a_km * (1 - e * e));
  },

  // Radial velocity (km/s)
  // v_r = √(GM/p) × e × sin(ν)
  // where p = a(1-e²) is the semi-latus rectum
  radialVelocity: (a_km, e, nu_deg) => {
    const nu = nu_deg * Math.PI / 180;
    const p = a_km * (1 - e * e);
    return Math.sqrt(GM_SUN / p) * e * Math.sin(nu);
  },

  // Transverse velocity (km/s)
  // v_t = √(GM/p) × (1 + e × cos(ν))
  // where p = a(1-e²) is the semi-latus rectum
  transverseVelocity: (a_km, e, nu_deg) => {
    const nu = nu_deg * Math.PI / 180;
    const p = a_km * (1 - e * e);
    return Math.sqrt(GM_SUN / p) * (1 + e * Math.cos(nu));
  },

  // Escape velocity from Sun at distance r (km/s)
  // v_esc = √(2GM/r)
  escapeVelocity: (r_km) => Math.sqrt(2 * GM_SUN / r_km),

  // Circular orbit velocity at distance r (km/s)
  // v_circ = √(GM/r)
  circularVelocity: (r_km) => Math.sqrt(GM_SUN / r_km),

  // Velocity ratio (current velocity / circular velocity)
  // Shows orbital dynamics: >1 near perihelion, <1 near aphelion, =√2 at escape
  velocityRatio: (v_km_s, r_km) => v_km_s / Math.sqrt(GM_SUN / r_km),

  // Heliocentric latitude (degrees)
  // sin(β) = sin(i) × sin(u) where u = ω + ν
  heliocentricLatitude: (inclination_deg, omega_deg, nu_deg) => {
    const i = inclination_deg * Math.PI / 180;
    const u = (omega_deg + nu_deg) * Math.PI / 180;
    return Math.asin(Math.sin(i) * Math.sin(u)) * 180 / Math.PI;
  },

  // True anomaly rate (degrees/day)
  // dν/dt = n × (1 + e×cos(ν))² / (1 - e²)^(3/2)
  // Fastest at perihelion, slowest at aphelion
  trueAnomalyRate: (n_deg_day, e, nu_deg) => {
    const nu = nu_deg * Math.PI / 180;
    const factor = Math.pow(1 + e * Math.cos(nu), 2) / Math.pow(1 - e * e, 1.5);
    return n_deg_day * factor;
  },

  // Eccentric anomaly rate (degrees/day)
  // dE/dt = n / (1 - e×cos(E))
  eccentricAnomalyRate: (n_deg_day, e, E_deg) => {
    const E = E_deg * Math.PI / 180;
    return n_deg_day / (1 - e * Math.cos(E));
  },

  // Area sweep rate (km²/s) - Kepler's 2nd Law
  // dA/dt = h/2 (constant throughout orbit)
  areaSweepRate: (a_km, e) => OrbitalFormulas.specificAngularMomentum(a_km, e) / 2,

  // Synodic period between any two planets (days)
  // P_syn = |P₁ × P₂ / (P₁ - P₂)|
  synodicPeriod: (P1_days, P2_days) => {
    if (P1_days === P2_days) return Infinity;
    return Math.abs(P1_days * P2_days / (P1_days - P2_days));
  },

  // Phase angle between two planets (degrees, 0-180)
  // Angular separation as seen from Sun
  phaseAngle: (lambda1_deg, lambda2_deg) => {
    let diff = Math.abs(lambda1_deg - lambda2_deg);
    if (diff > 180) diff = 360 - diff;
    return diff;
  },

  // Radius of curvature (km)
  // ρ = p × (1 + e² + 2e×cos(ν))^(3/2) / (1 + e×cos(ν))²
  radiusOfCurvature: (a_km, e, nu_deg) => {
    const p = a_km * (1 - e * e);
    const nu = nu_deg * Math.PI / 180;
    const cosNu = Math.cos(nu);
    const numerator = Math.pow(1 + e*e + 2*e*cosNu, 1.5);
    const denominator = Math.pow(1 + e*cosNu, 2);
    return p * numerator / denominator;
  },

  // Velocity ratio at perihelion vs aphelion
  // v_p/v_a = (1 + e) / (1 - e)
  velocityRatioPeriApo: (e) => (1 + e) / (1 - e),

  // Distance ratio aphelion vs perihelion
  // Q/q = (1 + e) / (1 - e)
  distanceRatioApoPerip: (e) => (1 + e) / (1 - e),

  // Kepler's 3rd Law: Orbital period from semi-major axis
  // P = 2π√(a³/GM) - returns days
  keplerPeriod: (a_km) => {
    const P_seconds = 2 * Math.PI * Math.sqrt(Math.pow(a_km, 3) / GM_SUN);
    return P_seconds / o.lengthofDay;
  },

  // Hill Sphere Radius (km)
  // r_Hill = a × (m / 3M)^(1/3)
  // Region where body's gravity dominates over the primary's gravity
  // Satellites must orbit within this radius to remain bound
  hillSphereRadius: (a_km, m_body, M_primary) => {
    return a_km * Math.pow(m_body / (3 * M_primary), 1/3);
  },

  // Sphere of Influence - Laplace definition (km)
  // r_SOI = a × (m / M)^(2/5)
  // Region where body's gravitational influence exceeds perturbation from primary
  // Used in patched conic approximation for spacecraft trajectories
  sphereOfInfluence: (a_km, m_body, M_primary) => {
    return a_km * Math.pow(m_body / M_primary, 2/5);
  },

  // Lagrange L1/L2 Distance from smaller body (km) - approximate
  // Same formula as Hill sphere: r_L1 ≈ r_L2 ≈ a × (m / 3M)^(1/3)
  // L1 is between the bodies, L2 is on the far side (unstable equilibrium points)
  lagrangeL1L2Distance: (a_km, m_body, M_primary) => {
    return a_km * Math.pow(m_body / (3 * M_primary), 1/3);
  },

  // Earth-Moon Barycenter distance from Earth center (km)
  // d_bary = moonDistance / (1 + mass_ratio)
  // Result: ~4,670 km (inside Earth, which has radius ~6,371 km)
  barycenterDistance: (moonDist_km, massRatio) => {
    return moonDist_km / (1 + massRatio);
  },

  // Schwarzschild Radius (km) - theoretical
  // r_s = 2GM / c²
  // The radius at which escape velocity equals speed of light
  // If all mass were compressed within this radius, it would form a black hole
  schwarzschildRadius: (GM) => {
    return 2 * GM / (speedOfLight * speedOfLight);
  },

  // Tidal Force Ratio (dimensionless)
  // Compares tidal force from body1 vs body2 at given distances
  // F_ratio = (M1 / M2) × (r2 / r1)³
  // For Sun/Moon on Earth: ~0.46 (Sun's tidal force is ~46% of Moon's)
  tidalForceRatio: (M1, M2, r1_km, r2_km) => {
    return (M1 / M2) * Math.pow(r2_km / r1_km, 3);
  },

  // Gravitational Potential at distance r (km²/s²)
  // Φ = -GM/r
  // Gravitational potential energy per unit mass at distance r
  gravitationalPotential: (GM, r_km) => {
    return -GM / r_km;
  },

  // Surface Gravity (m/s²)
  // g = GM / R²
  // Gravitational acceleration at the surface
  surfaceGravity: (GM_km3_s2, R_km) => {
    // GM in km³/s², R in km, result in m/s²
    return GM_km3_s2 / (R_km * R_km) * 1000;  // Convert km/s² to m/s²
  },

  // Surface Escape Velocity (km/s)
  // v_esc = √(2GM/R)
  // Minimum velocity needed to escape from the surface
  surfaceEscapeVelocity: (GM, R_km) => {
    return Math.sqrt(2 * GM / R_km);
  },

  // Mean Density (kg/m³)
  // ρ = M / V = 3M / (4πR³)
  // Average density of the body
  meanDensity: (M_kg, R_km) => {
    const R_m = R_km * 1000;
    const V = (4/3) * Math.PI * Math.pow(R_m, 3);
    return M_kg / V;
  },

  // Orbital Energy Ratio (dimensionless)
  // ratio = r/a - shows position relative to semi-major axis
  // < 1: closer than semi-major axis (moving toward aphelion)
  // = 1: at semi-major axis distance
  // > 1: farther than semi-major axis (moving toward perihelion)
  orbitalEnergyRatio: (r_km, a_km) => r_km / a_km,

  // Tidal Acceleration (m/s²)
  // a_tidal = 2 × GM × Δr / r³
  // Differential gravitational acceleration across an extended body
  tidalAcceleration: (GM, r_km, delta_r_km) => {
    return 2 * GM * delta_r_km / Math.pow(r_km, 3) * 1000;  // Convert to m/s²
  },

  // Semi-major Axis from Period (km)
  // a = (GM × P² / 4π²)^(1/3)
  // Inverse of Kepler's 3rd Law
  semiMajorAxisFromPeriod: (P_seconds, GM) => {
    return Math.pow(GM * P_seconds * P_seconds / (4 * Math.PI * Math.PI), 1/3);
  },

  // Mean Motion from GM (rad/s)
  // n = √(GM / a³)
  // Angular velocity in radians per second
  meanMotionFromGM: (GM, a_km) => Math.sqrt(GM / Math.pow(a_km, 3)),

  // ═══════════════════════════════════════════════════════════════
  // Precession & Newtonian Dynamics
  // ═══════════════════════════════════════════════════════════════

  // Precession rate from precession period (arcsec/century)
  // Rate = 360° × 3600"/° × 100 years / Period_years = 129,600,000 / Period_years
  precessionRateFromPeriod: (period_years) => {
    if (!isFinite(period_years) || period_years === 0) return 0;
    return 129600000 / period_years;
  },

  // Precession period from rate (years for full 360° cycle)
  // Period = 129,600,000 / Rate_arcsec_per_century
  precessionPeriodFromRate: (arcsec_per_century) => {
    if (!isFinite(arcsec_per_century) || arcsec_per_century === 0) return Infinity;
    return 129600000 / arcsec_per_century;
  },

  // Convert precession against Ecliptic to precession against ICRF
  // ICRF_period = (ecliptic × reference) / (ecliptic - reference)
  // Reference is typically holisticyearLength/13 (nodal precession contribution)
  precessionEclipticToICRF: (ecliptic_years, reference_years) => {
    const diff = ecliptic_years - reference_years;
    if (diff === 0) return Infinity;
    return (ecliptic_years * reference_years) / diff;
  },

  // Convert precession against ICRF to precession against Ecliptic
  // Inverse transformation: ecliptic = (ICRF × reference) / (ICRF + reference)
  precessionICRFToEcliptic: (ICRF_years, reference_years) => {
    const sum = ICRF_years + reference_years;
    if (sum === 0) return Infinity;
    return (ICRF_years * reference_years) / sum;
  },

  // Ratio of holistic year to precession period
  // Shows resonance structure in Newtonian precession (e.g., Mars = 4, Earth = 3)
  holisticPrecessionRatio: (precession_period, holistic_year) => {
    if (precession_period === 0) return Infinity;
    return holistic_year / precession_period;
  },

  // Precession period from holistic year ratio
  // period = holisticyearLength / n (where n is integer ratio)
  precessionFromHolisticRatio: (holistic_year, ratio) => {
    if (ratio === 0) return Infinity;
    return holistic_year / ratio;
  },

  // Precession angular velocity (rad/year) from arcsec/century
  // Converts observational units to angular velocity
  precessionAngularVelocity: (arcsec_per_century) => {
    // 1 arcsec = π/(180×3600) rad, 1 century = 100 years
    return (arcsec_per_century / 100) * (Math.PI / 648000);
  },

  // Newtonian perturbation strength estimate (dimensionless)
  // Shows relative influence of perturbing planet on another
  // strength = (m_perturber/M_sun) × (a_inner/a_outer)²
  perturbationStrength: (a_planet_km, a_perturber_km, m_perturber, M_sun) => {
    const ratio = a_planet_km < a_perturber_km
      ? Math.pow(a_planet_km / a_perturber_km, 2)
      : Math.pow(a_perturber_km / a_planet_km, 2);
    return (m_perturber / M_sun) * ratio;
  },

  // Precession ratio between two planets
  // Useful for identifying resonance patterns
  precessionRatio: (rate1_arcsec, rate2_arcsec) => {
    if (rate2_arcsec === 0) return Infinity;
    return rate1_arcsec / rate2_arcsec;
  },

  // Decompose total precession into ecliptic and perturbation components
  // Returns object with total, ecliptic contribution, and planetary perturbations
  precessionDecomposition: (total_arcsec, ecliptic_contribution_arcsec) => {
    return {
      total: total_arcsec,
      ecliptic: ecliptic_contribution_arcsec,
      perturbations: total_arcsec - ecliptic_contribution_arcsec
    };
  },

  // Format holistic ratio as readable fraction (e.g., "1/4" for ratio=4)
  // Returns string like "Holistic Year / 4" or "Holistic Year × 1.22"
  holisticRatioDescription: (ratio) => {
    if (!isFinite(ratio) || ratio === 0) return 'N/A';
    const absRatio = Math.abs(ratio);
    const sign = ratio < 0 ? ' (retrograde)' : '';
    // Check if it's close to an integer
    if (Math.abs(absRatio - Math.round(absRatio)) < 0.01) {
      const n = Math.round(absRatio);
      if (n === 1) return `= Holistic Year${sign}`;
      return `= Holistic Year / ${n}${sign}`;
    }
    return `≈ Holistic Year / ${absRatio.toFixed(2)}${sign}`;
  },

  // ═══════════════════════════════════════════════════════════════
  // Precession Breakdown (Lagrange-Laplace Secular Theory)
  // ═══════════════════════════════════════════════════════════════

  // Laplace coefficient b_{3/2}^{(1)}(α) - for outer perturber on inner planet
  // Computed using numerical integration of the defining integral:
  //   b_s^j(α) = (1/π) × ∫₀^(2π) cos(jψ) / (1 - 2α cos(ψ) + α²)^s dψ
  // This is more accurate than series expansion for larger α values (e.g., Venus α=0.54)
  // Reference: Murray & Dermott (1999), Solar System Dynamics, Chapter 7
  laplaceCoefficient_3_2_1: (alpha) => {
    // Numerical integration with 1000 steps (accurate to <0.1%)
    const steps = 1000;
    const dPsi = (2 * Math.PI) / steps;
    let sum = 0;

    for (let i = 0; i < steps; i++) {
      const psi = i * dPsi;
      const cosPsi = Math.cos(psi);
      const denom = Math.pow(1 - 2 * alpha * cosPsi + alpha * alpha, 1.5);
      sum += cosPsi / denom;
    }

    return sum * dPsi / Math.PI;
  },

  // Laplace coefficient b_{3/2}^{(2)}(α) - for inner perturber on outer planet
  // Computed using numerical integration with j=2:
  //   b_s^j(α) = (1/π) × ∫₀^(2π) cos(jψ) / (1 - 2α cos(ψ) + α²)^s dψ
  // Used when calculating perturbation from an INNER planet
  laplaceCoefficient_3_2_2: (alpha) => {
    const steps = 1000;
    const dPsi = (2 * Math.PI) / steps;
    let sum = 0;

    for (let i = 0; i < steps; i++) {
      const psi = i * dPsi;
      const cosPsi = Math.cos(psi);
      const cos2Psi = Math.cos(2 * psi);
      const denom = Math.pow(1 - 2 * alpha * cosPsi + alpha * alpha, 1.5);
      sum += cos2Psi / denom;
    }

    return sum * dPsi / Math.PI;
  },

  // Eccentricity correction factor for precession (first-order)
  // For first-order secular theory, this is negligible (~2% for Mercury)
  // Full formula from disturbing function: f(e) ≈ 1 + (1/2)e² + O(e⁴)
  // Reference: PERIHELION_PRECESSION_CORRECTED.md
  eccentricityCorrectionFactor: (e_planet, e_perturber) => {
    // Simplified first-order correction - negligible for most planets
    // Setting to 1.0 matches the corrected document which doesn't use this
    return 1.0;
  },

  // Mutual inclination between two orbital planes (degrees)
  // cos(I_mutual) = cos(i₁)cos(i₂) + sin(i₁)sin(i₂)cos(ΔΩ)
  mutualInclination: (i1_deg, i2_deg, deltaOmega_deg) => {
    const i1 = i1_deg * Math.PI / 180;
    const i2 = i2_deg * Math.PI / 180;
    const dO = deltaOmega_deg * Math.PI / 180;
    const cosI = Math.cos(i1) * Math.cos(i2) + Math.sin(i1) * Math.sin(i2) * Math.cos(dO);
    return Math.acos(Math.max(-1, Math.min(1, cosI))) * 180 / Math.PI;
  },

  // Inclination correction factor for precession
  // g(I) = cos(I_mutual) - reduces in-plane perturbation
  inclinationCorrectionFactor: (i_mutual_deg) => {
    return Math.cos(i_mutual_deg * Math.PI / 180);
  },

  // Mean motion in rad/year from orbital period in days
  meanMotionRadPerYear: (period_days) => {
    const period_years = period_days / 365.25;
    return (2 * Math.PI) / period_years;
  },

  // Secular precession contribution from ONE perturber (arcsec/century)
  // Implements Lagrange-Laplace secular perturbation theory
  // A_ii = Σ(j≠i) (n_i/4) × ε_ij × α_ij × ᾱ_ij × b₃/₂⁽¹⁾(α_ij)
  // Where:
  //   ε_ij = m_j / (M_sun + m_i) ≈ m_j / M_sun for planets
  //   α_ij = a_inner / a_outer (always < 1)
  //   ᾱ_ij = a_i / a_j for outer perturber, or 1 for inner perturber
  //   b₃/₂⁽¹⁾ = Laplace coefficient for outer perturber
  //   b₃/₂⁽²⁾ = Laplace coefficient for inner perturber
  // Reference: Murray & Dermott (1999), farside.ph.utexas.edu/teaching/celestial/Celestial/node91.html
  secularPrecessionContribution: (
    n_rad_per_year,       // Mean motion of perturbed planet (rad/year)
    m_perturber,          // Mass of perturbing planet (kg)
    M_sun,                // Mass of Sun (kg)
    a_planet_km,          // Semi-major axis of perturbed planet (km)
    a_perturber_km,       // Semi-major axis of perturbing planet (km)
    e_planet,             // Eccentricity of perturbed planet
    e_perturber,          // Eccentricity of perturbing planet
    i_planet_deg,         // Ecliptic inclination of perturbed planet (degrees)
    i_perturber_deg,      // Ecliptic inclination of perturbing planet (degrees)
    deltaOmega_deg        // Difference in ascending node longitudes (degrees)
  ) => {
    const isOuter = a_perturber_km > a_planet_km;

    // α = a_inner / a_outer (always < 1)
    const alpha = isOuter
      ? a_planet_km / a_perturber_km
      : a_perturber_km / a_planet_km;

    // ᾱ = a_planet / a_perturber for outer, or 1 for inner perturber
    const alpha_bar = isOuter
      ? a_planet_km / a_perturber_km  // Same as α for outer perturber
      : 1;                             // 1 for inner perturber

    // Get appropriate Laplace coefficient
    // Note: b₃/₂⁽¹⁾(α) ≈ 3α × (1 + terms) already contains one factor of α
    // Note: b₃/₂⁽²⁾(α) ≈ 3.75α² × (1 + terms) already contains α² factor
    const laplace = isOuter
      ? OrbitalFormulas.laplaceCoefficient_3_2_1(alpha)
      : OrbitalFormulas.laplaceCoefficient_3_2_2(alpha);

    // Mass ratio ε = m_perturber / M_sun
    const massRatio = m_perturber / M_sun;

    // Base secular precession rate (rad/year)
    // Laplace-Lagrange first-order secular theory:
    //
    // For EXTERIOR perturbers: dω/dt = (n/4) × ε × α² × b₃/₂⁽¹⁾(α)
    // For INTERIOR perturbers: dω/dt = (n/4) × ε × α × b₃/₂⁽²⁾(α)
    //
    // Where:
    //   n = mean motion of the perturbed planet (rad/year)
    //   ε = m_perturber / M_sun (mass ratio)
    //   α = a_inner / a_outer (semi-major axis ratio, always < 1)
    //   b₃/₂⁽ʲ⁾(α) = Laplace coefficient (computed via numerical integration)
    //
    // Note: Eccentricity and inclination corrections are negligible for first-order theory
    //       (they contribute ~2-5% for Mercury, which is within the expected ~4% error)
    //
    // Reference: Murray & Dermott (1999), PERIHELION_PRECESSION_CORRECTED.md
    let rate_rad_per_year = 0.25 * n_rad_per_year * massRatio * alpha * alpha_bar * laplace;

    // Sign: outer perturbers cause prograde (+), inner cause retrograde (-)
    if (!isOuter) {
      rate_rad_per_year = -rate_rad_per_year;
    }

    // Convert rad/year to arcsec/century
    // 1 rad = 206264.806 arcsec, 1 century = 100 years
    const arcsec_per_century = rate_rad_per_year * 206264.806 * 100;

    return arcsec_per_century;
  }
};

// Planet calculations TYPE I
const mercurySolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/mercurySolarYearInput));
const mercuryOrbitDistance = (((holisticyearLength/mercurySolarYearCount)**2)**(1/3));
const mercuryPerihelionDistance = mercuryOrbitDistance*mercuryOrbitalEccentricity*100;
const mercuryElipticOrbit = mercuryPerihelionDistance/2;
const mercurySpeed = (mercuryOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/mercurySolarYearCount))/24;
const mercuryRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(mercurySolarYearCount*3/2);
const mercuryEccentricityPerihelion = (mercuryPerihelionDistance/2)*mercuryOrbitalEccentricity;
const mercuryLowestPoint = 180-mercuryAscendingNode;

const venusSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/venusSolarYearInput));
const venusOrbitDistance = (((holisticyearLength/venusSolarYearCount)**2)**(1/3));
const venusPerihelionDistance = (venusOrbitDistance*venusOrbitalEccentricity*100);
const venusElipticOrbit = venusPerihelionDistance/2;
const venusSpeed = (venusOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/venusSolarYearCount))/24;
const venusRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/243.022699230302));
const venusEccentricityPerihelion = (venusPerihelionDistance/2)*venusOrbitalEccentricity;
const venusLowestPoint = 180-venusAscendingNode;

// Planet calculations TYPE II
const marsSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/marsSolarYearInput));
const marsOrbitDistance = (((holisticyearLength/marsSolarYearCount)**2)**(1/3));
const marsRealOrbitalEccentricity = marsOrbitalEccentricity/(1+marsOrbitalEccentricity);
const marsElipticOrbit = (((marsRealOrbitalEccentricity*marsOrbitDistance)/2))*100+((marsOrbitalEccentricity*marsOrbitDistance)-(marsRealOrbitalEccentricity*marsOrbitDistance))*100;
const marsPerihelionDistance = (marsOrbitDistance*marsOrbitalEccentricity*100)+marsElipticOrbit;
const marsSpeed = (marsOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/marsSolarYearCount))/24;
const marsRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/1.02595659586635));

const erosSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/erosSolarYearInput));
const erosOrbitDistance = (((holisticyearLength/erosSolarYearCount)**2)**(1/3));
const erosRealOrbitalEccentricity = erosOrbitalEccentricity/(1+erosOrbitalEccentricity);
const erosElipticOrbit = (((erosRealOrbitalEccentricity*erosOrbitDistance)/2))*100+((erosOrbitalEccentricity*erosOrbitDistance)-(erosRealOrbitalEccentricity*erosOrbitDistance))*100;
const erosPerihelionDistance = (erosOrbitDistance*erosOrbitalEccentricity*100)+erosElipticOrbit;
const erosSpeed = (erosOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/erosSolarYearCount))/24;
const erosRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/0.21958333344885));

// Planet calculations TYPE III
const jupiterSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/jupiterSolarYearInput));
const jupiterOrbitDistance = (((holisticyearLength/jupiterSolarYearCount)**2)**(1/3));
const jupiterRealOrbitalEccentricity = jupiterOrbitalEccentricity/(1+jupiterOrbitalEccentricity);
const jupiterElipticOrbit = ((jupiterOrbitalEccentricity*jupiterOrbitDistance)-(jupiterRealOrbitalEccentricity*jupiterOrbitDistance))*100; 
const jupiterPerihelionDistance = jupiterRealOrbitalEccentricity*jupiterOrbitDistance*2*100;
const jupiterSpeed = (jupiterOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/jupiterSolarYearCount))/24;
const jupiterRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/0.413541666975253));

const saturnSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/saturnSolarYearInput));
const saturnOrbitDistance = (((holisticyearLength/saturnSolarYearCount)**2)**(1/3));
const saturnRealOrbitalEccentricity = saturnOrbitalEccentricity/(1+saturnOrbitalEccentricity);
const saturnElipticOrbit = ((saturnOrbitalEccentricity*saturnOrbitDistance)-(saturnRealOrbitalEccentricity*saturnOrbitDistance))*100; 
const saturnPerihelionDistance = saturnRealOrbitalEccentricity*saturnOrbitDistance*2*100;
const saturnSpeed = (saturnOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/saturnSolarYearCount))/24;
const saturnRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/0.440023148755863));

const uranusSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/uranusSolarYearInput));
const uranusOrbitDistance = (((holisticyearLength/uranusSolarYearCount)**2)**(1/3));
const uranusRealOrbitalEccentricity = uranusOrbitalEccentricity/(1+uranusOrbitalEccentricity);
const uranusElipticOrbit = ((uranusOrbitalEccentricity*uranusOrbitDistance)-(uranusRealOrbitalEccentricity*uranusOrbitDistance))*100; 
const uranusPerihelionDistance = uranusRealOrbitalEccentricity*uranusOrbitDistance*2*100;
const uranusSpeed = (uranusOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/uranusSolarYearCount))/24;
const uranusRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/0.718329998141018));

const neptuneSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/neptuneSolarYearInput));
const neptuneOrbitDistance = (((holisticyearLength/neptuneSolarYearCount)**2)**(1/3));
const neptuneRealOrbitalEccentricity = neptuneOrbitalEccentricity/(1+neptuneOrbitalEccentricity);
const neptuneElipticOrbit = ((neptuneOrbitalEccentricity*neptuneOrbitDistance)-(neptuneRealOrbitalEccentricity*neptuneOrbitDistance))*100; 
const neptunePerihelionDistance = neptuneRealOrbitalEccentricity*neptuneOrbitDistance*2*100;
const neptuneSpeed = (neptuneOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/neptuneSolarYearCount))/24;
const neptuneRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/0.671300001591743));

const plutoSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/plutoSolarYearInput));
const plutoOrbitDistance = (((holisticyearLength/plutoSolarYearCount)**2)**(1/3));
const plutoPerihelionDistance = plutoOrbitalEccentricity*plutoOrbitDistance*100;
const plutoElipticOrbit = plutoPerihelionDistance/2;
const plutoSpeed = (plutoOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/plutoSolarYearCount))/24;
const plutoRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/6.38720012152536));

const halleysSolarYearCount = (Math.round((holisticyearLength*meansolaryearlengthinDays)/halleysSolarYearInput));
const halleysOrbitDistance = (((holisticyearLength/halleysSolarYearCount)**2)**(1/3));
const halleysRealOrbitalEccentricity = halleysOrbitalEccentricity/(1+halleysOrbitalEccentricity);
const halleysElipticOrbit = ((halleysOrbitalEccentricity*halleysOrbitDistance)-(halleysRealOrbitalEccentricity*halleysOrbitDistance))*100; 
const halleysPerihelionDistance = halleysRealOrbitalEccentricity*halleysOrbitDistance*2*100;
const halleysSpeed = (halleysOrbitDistance*currentAUDistance*Math.PI*2)/(meansolaryearlengthinDays*(holisticyearLength/halleysSolarYearCount))/24;
const halleysRotationPeriod = 24*(meansolaryearlengthinDays*holisticyearLength)/(Math.round((meansolaryearlengthinDays*holisticyearLength)/2.2));

/* formats numbers with X decimals and a custom thousands separator */
const fmtNum = (n, dec = 6, sep = ',') =>
  Number(n).toLocaleString('en-US', {
    minimumFractionDigits:dec,
    maximumFractionDigits:dec
  }).replace(/,/g, sep);

// Format number in proper scientific notation with Unicode superscripts (e.g., 1.988415709678 × 10³⁰)
const fmtScientific = (n, dec = 12) => {
  const superscripts = {'0':'⁰','1':'¹','2':'²','3':'³','4':'⁴','5':'⁵','6':'⁶','7':'⁷','8':'⁸','9':'⁹','-':'⁻'};
  const expStr = n.toExponential(dec);
  const [mantissa, exp] = expStr.split('e');
  const expNum = parseInt(exp, 10);
  const superExp = String(expNum).split('').map(c => superscripts[c] || c).join('');
  return `${mantissa} × 10${superExp}`;
};

// ═══════════════════════════════════════════════════════════════
// Precession Breakdown Helper Functions
// ═══════════════════════════════════════════════════════════════

// Cache for precession breakdown calculations (avoid recalculating every frame)
const precessionBreakdownCache = {
  mercury: { data: null, time: 0 },
  venus: { data: null, time: 0 },
  earth: { data: null, time: 0 },
  mars: { data: null, time: 0 },
  jupiter: { data: null, time: 0 },
  saturn: { data: null, time: 0 },
  uranus: { data: null, time: 0 },
  neptune: { data: null, time: 0 },
  pluto: { data: null, time: 0 },
  halleys: { data: null, time: 0 },
  eros: { data: null, time: 0 }
};

// Get orbital data for all 8 major planets (used for precession breakdown calculations)
// Uses FIXED J2000 ecliptic orbital elements for consistency with reference calculations
// NOTE: period_days uses the CALCULATED period from the model (holisticyearLength/count * meansolaryearlengthinDays)
//       i_deg uses the FIXED ecliptic inclination (e.g., mercuryEclipticInclinationJ2000 = 7.005°)
//       omega_deg uses the FIXED J2000 ascending node (e.g., mercuryAscendingNode = 48.33°)
function getPlanetPerturbationData(oRef) {
  return [
    {
      name: 'Mercury',
      a_km: mercuryOrbitDistance * oRef.lengthofAU,
      e: mercuryOrbitalEccentricity,
      i_deg: mercuryEclipticInclinationJ2000,        // Fixed ecliptic inclination (7.005°)
      omega_deg: mercuryAscendingNode,               // Fixed J2000 ascending node
      mass: M_MERCURY,
      period_days: (holisticyearLength / mercurySolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(mercuryPerihelionICRFYears)
    },
    {
      name: 'Venus',
      a_km: venusOrbitDistance * oRef.lengthofAU,
      e: venusOrbitalEccentricity,
      i_deg: venusEclipticInclinationJ2000,          // Fixed ecliptic inclination (3.39°)
      omega_deg: venusAscendingNode,                 // Fixed J2000 ascending node
      mass: M_VENUS,
      period_days: (holisticyearLength / venusSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(venusPerihelionICRFYears)
    },
    {
      name: 'Earth',
      a_km: oRef.lengthofAU,                        // Earth = 1 AU
      e: eccentricityMean,                          // Fixed mean eccentricity
      i_deg: 0,                                     // Earth defines the ecliptic (0° by definition)
      omega_deg: 0,                                 // Reference point
      mass: M_EARTH,
      period_days: meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(earthPerihelionICRFYears)
    },
    {
      name: 'Mars',
      a_km: marsOrbitDistance * oRef.lengthofAU,
      e: marsOrbitalEccentricity,
      i_deg: marsEclipticInclinationJ2000,          // Fixed ecliptic inclination (1.85°)
      omega_deg: marsAscendingNode,                 // Fixed J2000 ascending node
      mass: M_MARS,
      period_days: (holisticyearLength / marsSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(marsPerihelionICRFYears)
    },
    {
      name: 'Jupiter',
      a_km: jupiterOrbitDistance * oRef.lengthofAU,
      e: jupiterOrbitalEccentricity,
      i_deg: jupiterEclipticInclinationJ2000,       // Fixed ecliptic inclination (1.30°)
      omega_deg: jupiterAscendingNode,              // Fixed J2000 ascending node
      mass: M_JUPITER,
      period_days: (holisticyearLength / jupiterSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(jupiterPerihelionICRFYears)
    },
    {
      name: 'Saturn',
      a_km: saturnOrbitDistance * oRef.lengthofAU,
      e: saturnOrbitalEccentricity,
      i_deg: saturnEclipticInclinationJ2000,        // Fixed ecliptic inclination (2.49°)
      omega_deg: saturnAscendingNode,               // Fixed J2000 ascending node
      mass: M_SATURN,
      period_days: (holisticyearLength / saturnSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(saturnPerihelionICRFYears)
    },
    {
      name: 'Uranus',
      a_km: uranusOrbitDistance * oRef.lengthofAU,
      e: uranusOrbitalEccentricity,
      i_deg: uranusEclipticInclinationJ2000,        // Fixed ecliptic inclination (0.77°)
      omega_deg: uranusAscendingNode,               // Fixed J2000 ascending node
      mass: M_URANUS,
      period_days: (holisticyearLength / uranusSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(uranusPerihelionICRFYears)
    },
    {
      name: 'Neptune',
      a_km: neptuneOrbitDistance * oRef.lengthofAU,
      e: neptuneOrbitalEccentricity,
      i_deg: neptuneEclipticInclinationJ2000,       // Fixed ecliptic inclination (1.77°)
      omega_deg: neptuneAscendingNode,              // Fixed J2000 ascending node
      mass: M_NEPTUNE,
      period_days: (holisticyearLength / neptuneSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(neptunePerihelionICRFYears)
    },
    {
      name: 'Pluto',
      a_km: plutoOrbitDistance * oRef.lengthofAU,
      e: plutoOrbitalEccentricity,
      i_deg: plutoEclipticInclinationJ2000,         // Fixed ecliptic inclination (17.14°)
      omega_deg: plutoAscendingNode,                // Fixed J2000 ascending node
      mass: M_PLUTO,
      period_days: (holisticyearLength / plutoSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(plutoPerihelionICRFYears)
    },
    {
      name: 'Halleys',
      a_km: halleysOrbitDistance * oRef.lengthofAU,
      e: halleysOrbitalEccentricity,
      i_deg: halleysEclipticInclinationJ2000,       // Fixed ecliptic inclination (162.19° - retrograde)
      omega_deg: halleysAscendingNode,              // Fixed J2000 ascending node
      mass: M_HALLEYS,
      period_days: (holisticyearLength / halleysSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(halleysPerihelionICRFYears)
    },
    {
      name: 'Eros',
      a_km: erosOrbitDistance * oRef.lengthofAU,
      e: erosOrbitalEccentricity,
      i_deg: erosEclipticInclinationJ2000,          // Fixed ecliptic inclination (10.83°)
      omega_deg: erosAscendingNode,                 // Fixed J2000 ascending node
      mass: M_EROS,
      period_days: (holisticyearLength / erosSolarYearCount) * meansolaryearlengthinDays,
      observedPrecession: OrbitalFormulas.precessionRateFromPeriod(erosPerihelionICRFYears)
    }
  ];
}

// Calculate precession breakdown for a specific planet
function calculatePrecessionBreakdown(planetName, oRef) {
  const allPlanets = getPlanetPerturbationData(oRef);
  const planetData = allPlanets.find(p => p.name === planetName);
  if (!planetData) return null;

  const n_rad_per_year = OrbitalFormulas.meanMotionRadPerYear(planetData.period_days);
  const contributions = [];
  let total = 0;

  for (const perturber of allPlanets) {
    if (perturber.name === planetName) continue;

    const deltaOmega = planetData.omega_deg - perturber.omega_deg;

    const contrib = OrbitalFormulas.secularPrecessionContribution(
      n_rad_per_year,
      perturber.mass,
      M_SUN,
      planetData.a_km,
      perturber.a_km,
      planetData.e,
      perturber.e,
      planetData.i_deg,
      perturber.i_deg,
      deltaOmega
    );

    const isOuter = perturber.a_km > planetData.a_km;
    const alpha = isOuter
      ? planetData.a_km / perturber.a_km
      : perturber.a_km / planetData.a_km;

    contributions.push({
      perturber: perturber.name,
      contribution: contrib,
      isOuter: isOuter,
      alpha: alpha
    });

    total += contrib;
  }

  // Sort by absolute contribution (largest first)
  contributions.sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution));

  return {
    planet: planetName,
    contributions: contributions,
    calculatedTotal: total,
    observedTotal: planetData.observedPrecession,
    accuracy: planetData.observedPrecession !== 0 ? (total / planetData.observedPrecession) * 100 : 0
  };
}

// Get cached precession breakdown (recalculates every 1000ms)
function getPrecessionBreakdownCached(planetKey, oRef) {
  const cache = precessionBreakdownCache[planetKey];
  const now = Date.now();
  if (!cache.data || now - cache.time > 1000) {
    const planetName = planetKey.charAt(0).toUpperCase() + planetKey.slice(1);
    cache.data = calculatePrecessionBreakdown(planetName, oRef);
    cache.time = now;
  }
  return cache.data;
}

// Individual getter functions for each planet's breakdown
function getMercuryPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('mercury', oRef); }
function getVenusPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('venus', oRef); }
function getEarthPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('earth', oRef); }
function getMarsPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('mars', oRef); }
function getJupiterPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('jupiter', oRef); }
function getSaturnPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('saturn', oRef); }
function getUranusPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('uranus', oRef); }
function getNeptunePrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('neptune', oRef); }
function getPlutoPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('pluto', oRef); }
function getHalleysPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('halleys', oRef); }
function getErosPrecessionBreakdown(oRef) { return getPrecessionBreakdownCached('eros', oRef); }

// Helper to get contribution for a specific perturber from breakdown
function getContribution(breakdown, perturberName) {
  if (!breakdown || !breakdown.contributions) return 0;
  const c = breakdown.contributions.find(x => x.perturber === perturberName);
  return c ? c.contribution : 0;
}

/* ──────────────────────────────────────────────────────────────
   Universal cell renderer
   • numbers   → thousands-sep + decimals
   • dates     → dd/mm/yyyy, HH:MM:SS   (en-GB, 24 h)
   • bold / italic / small meta
   • getters (functions) evaluated each frame
   ────────────────────────────────────────────────────────────── */
const renderVal = val => {

  /* 0 ─ whole value may itself be a function */
  if (typeof val === 'function')
    return renderVal(val());

  /* ──────────────────────────────────────────────────
     A.  DIRECT  Date  or ISO-string  (no wrappers)
     ────────────────────────────────────────────────── */
  if (val instanceof Date)
    return val.toLocaleString('en-GB', { hour12:false });

  if (typeof val === 'string' && /^\d{4}-\d\d-\d\d/.test(val)) {
    const d = new Date(val.replace(' ', 'T'));
    if (!isNaN(d)) return d.toLocaleString('en-GB', { hour12:false });
  }

  /* ──────────────────────────────────────────────────
     B.  BOXED VALUE  { v, dec?, sep? }   ← new date branch
     ────────────────────────────────────────────────── */
  if (val && typeof val === 'object' && 'v' in val) {

    /* 1. unwrap getter if needed */
    let raw = (typeof val.v === 'function') ? val.v() : val.v;

    /* 2. same date logic as above */
    if (raw instanceof Date)
      return raw.toLocaleString('en-GB', { hour12:false });

    if (typeof raw === 'string' && /^\d{4}-\d\d-\d\d/.test(raw)) {
      const d = new Date(raw.replace(' ', 'T'));
      if (!isNaN(d)) return d.toLocaleString('en-GB', { hour12:false });
    }

    /* 3. if it's already a string (non-date), return it directly */
    if (typeof raw === 'string') return raw;

    /* 4. fall back to numeric formatting */
    const num = Number(raw);
    if (!Number.isFinite(num)) return '';          // guard NaN or ±∞

    /* 5. show infinity symbol if explicitly requested for very large numbers */
    if (val.infinity && Math.abs(num) > val.infinity) return '∞';

    const dec = val.dec ?? 0;
    const sep = val.sep ?? ',';
    return fmtNum(num, dec, sep);
  }

  /* ──────────────────────────────────────────────────
     C.  meta wrappers { bold | italic | small : … }
     ────────────────────────────────────────────────── */
  if (val && typeof val === 'object') {
    const inner = renderVal(val.bold ?? val.italic ?? val.small ?? val);
    if (val.bold)   return `<strong>${inner}</strong>`;
    if (val.italic) return `<em>${inner}</em>`;
    if (val.small)  return `<small>${inner}</small>`;
    return inner;
  }

  /* ──────────────────────────────────────────────────
     D.  plain scalar → default numeric formatting
     ────────────────────────────────────────────────── */
  if (Number.isFinite(val)) return fmtNum(val);
  return val ?? '';
};

const planetMeta = {
  earth : {
    intro : 'Earth is the third planet from the Sun and is the largest of the terrestrial planets. It is the only planet in our solar system not to be named after a Greek or Roman deity. The Earth was formed approximately ~4.5 billion years ago and is the only known planet to support life. It has a significant atmosphere, active geology, and a large moon, distinguished by its vast oceans of liquid water and diverse ecosystems that make it unique in the Solar System.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Earth_OLD.jpg',
    imgRatio : 35 / 9
  },
  sun  : {
    intro : 'The Sun (or Sol), is the star at the centre of our solar system and is responsible for the Earth’s climate and weather. The Sun is an almost perfect sphere with a difference of just 10 km in diameter between the poles and the equator. The average radius of the Sun is 695,508 km (109.2 x that of the Earth) of which 20–25% is the core. Our Sun is a ~4.5 billion-year-old yellow dwarf star that contains 99.86% of the Solar Systems mass and powers almost all life and weather on Earth through nuclear fusion of hydrogen into helium in its core.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Sun.jpg',
    imgRatio : 35 / 9
  },
  moon  : {
    intro : 'The Moon is Earths only natural satellite. It orbits around Earth at an average distance of 384,399 km. The Moon is just less than a third of the width of Earth which is really large compared to other Moon-Planet sizes in our solar system. The Moon rotates, but keeps facing Earth with the exact same near side. The origin of the Moon is usually explained by a Mars-sized body, known as Theia, striking the Earth, creating a debris ring that eventually collected into a single natural satellite, the Moon, but there are a number of variations on this giant-impact hypothesis, as well as alternative explanations, and research continues into how the Moon came to be formed.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Moon.jpg',
    imgRatio : 35 / 9
  },
  mercury  : {
    intro : 'Mercury is the smallest and closest planet to the Sun and due to its proximity it is not easily seen except during twilight. It is a heavily cratered, airless world that experiences extreme temperature swings due to its proximity to the Sun and lack of atmosphere. For every two orbits of the Sun, Mercury completes three rotations about its axis and up until 1965 it was thought that the same side of Mercury constantly faced the Sun. Thirteen times a century Mercury can be observed from the Earth passing across the face of the Sun in an event called a transit, the next will occur on the 13th November 2032.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Mercury.jpg',
    imgRatio : 35 / 9
  },
  venus  : {
    intro : 'Venus is the second planet from the Sun and is the second brightest object in the night sky after the Moon. Named after the Roman goddess of love and beauty, Venus is the second largest terrestrial planet and is sometimes referred to as the Earth’s sister planet due the their similar size and mass. The surface of this hot rocky planet is obscured by an opaque layer of clouds made up of sulphuric acid, crushing atmospheric pressure 90 times that of Earth, and a surface hot enough to melt lead due to a runaway greenhouse effect.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/VenusAtmosphere.jpg',
    imgRatio : 35 / 9
  },
  mars  : {
    intro : 'Mars is the fourth planet from the Sun and is the second smallest planet in the solar system. Named after the Roman god of war, Mars is also often described as the “Red Planet” due to its reddish appearance. Mars is a terrestrial planet with a thin atmosphere composed primarily of carbon dioxide. It is a cold, dusty red planet with massive extinct volcanoes, deep canyons, frozen polar caps, and evidence of ancient water flows, making it the most Earth-like planet in the Solar System.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Mars.jpg',
    imgRatio : 35 / 9
  },
  jupiter  : {
    intro : 'The planet Jupiter is the fifth planet out from the Sun, and is two and a half times more massive than all the other planets in the solar system combined. It is made primarily of gases and is therefore known as a “gas giant”. It has distinctive bands of swirling clouds, a powerful magnetic field, at least 95 moons, and an ongoing storm called the Great Red Spot that has raged for centuries',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Jupiter.jpg',
    imgRatio : 35 / 9
  },
  saturn  : {
    intro : 'Saturn is the sixth planet from the Sun and the most distant that can be seen with the naked eye. Saturn is the second largest planet and is best known for its fabulous ring system that was first observed in 1610 by the astronomer Galileo Galilei. Like Jupiter, Saturn is a gas giant and is composed of similar gasses including hydrogen, helium and methane. It has a distinctive yellow-orange hue, known for its extensive system of icy rings and more than 80 moons, including Titan, the only moon in the Solar System with a thick atmosphere. Saturns has a very strange persistent hexagonal cloud pattern around the north pole of the planet',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Saturn.jpg',
    imgRatio : 35 / 9
  },
  uranus  : {
    intro : 'Uranus is the seventh planet from the Sun. While being visible to the naked eye, it was not recognised as a planet due to its dimness and slow orbit. Uranus became the first planet discovered with the use of a telescope. Uranus is tipped over on its side with an axial tilt of over 82 degrees. It is often described as “rolling around the Sun on its side”. It is a cold, blue-green ice giant planet, with a set of narrow rings and a family of at least 28 moons named after literary characters.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Uranus.jpg',
    imgRatio : 35 / 9
  },
  neptune  : {
    intro : 'Neptune is the eighth planet from the Sun making it the most distant in the solar system. This gas giant planet may have formed much closer to the Sun in early solar system history before migrating to its present position. Neptune is a cold, windy ice giant with a vivid blue color, powerful storms, supersonic winds reaching 2,000 km/h (1,200 mph), a faint ringsystem and a collection of 16 known moons including the geologically active Triton.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Neptune.jpg',
    imgRatio : 35 / 9
  },
  pluto  : {
    intro : 'Pluto is a dwarf planet located in a distant region of our solar system beyond Neptune known as the Kuiper Belt. Pluto was long considered our ninth planet, but the International Astronomical Union reclassified Pluto as a dwarf planet in 2006. It is the largest known trans-Neptunian object by volume by a small margin, but is less massive than Eris. Like other Kuiper belt objects, Pluto is made primarily of ice and rock and is much smaller than the inner planets. Pluto has roughly one-sixth the mass of the Moon and one-third its volume.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/FictionalMakemake.jpg',
    imgRatio : 35 / 9
  },
  halleys  : {
    intro : 'Halleys Comet is the only known short-period comet that is consistently visible to the naked eye from Earth, appearing every 72–80 years. Halleys periodic returns to the inner Solar System have been observed and recorded by astronomers around the world since at least 240 BC, but it was not until 1705 that the English astronomer Edmond Halley understood that these appearances were re-appearances of the same comet. As a result of this discovery, the comet is named after Halley.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/FictionalCeres.jpg',
    imgRatio : 35 / 9
  },
  eros  : {
    intro : '433 Eros is a stony asteroid of the Amor group, and the first discovered, and second-largest near-Earth object. It has an elongated shape and a volume-equivalent diameter of approximately 16.8 kilometers (10.4 miles). Visited by the NEAR Shoemaker space probe in 1998, it became the first asteroid ever studied from its own orbit. The asteroid was discovered by German astronomer C. G. Witt at the Berlin Observatory on 13 August 1898 in an eccentric orbit between Mars and Earth. It was later named after Eros, a god from Greek mythology, the son of Aphrodite.',
    img   : 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/FictionalEris.jpg',
    imgRatio : 35 / 9
  },
  // …
};

//*************************************************************
// Create Planets logic
//*************************************************************
const startingPoint = {
  name: "Starting Point",
  startPos: 0,
  speed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.1,
  color: 0x578B7C,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const earthWobbleCenter = {
  name: "EARTH-WOBBLE-CENTER",
  startPos: -(((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/3)*360)-(((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/16)*360)-180)),
  speed: 0,
  tilt: 0,
  rotationSpeed: -Math.PI*2/(holisticyearLength/13),
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.011,
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/deathstar.png',
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceOn: false,
  isNotPhysicalObject: true,
};

const midEccentricityOrbit = {
  name: "EARTH-MID-ECCENTRICITY-ORBIT",
  startPos: -(((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/3)*360)-(((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/16)*360)-180)),
  speed: Math.PI*2/(holisticyearLength/13),
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: eccentricityMean*100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.011,   
  color: 0x0096FF,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/earth_mean_eccentricity.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,
  traceOn: true,
  isNotPhysicalObject: true,
};

const earth = {
  name: "Earth",
  startPos: 0,    
  speed: -Math.PI*2/(holisticyearLength/13),
  rotationSpeed: Math.PI*2*(meansolaryearlengthinDays+1),
  tilt: -earthtiltMean,
  orbitRadius: -eccentricityAmplitude*100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.earthDiameter/ currentAUDistance)*100,
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Earth.jpg',
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,
  traceOn: false,
};

const earthInclinationPrecession = {
  name: "Earth Inclination Precession",
  startPos: ((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/3)*360),
  speed: Math.PI*2/(holisticyearLength/3),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.1,
  color: 0xFEAA0D,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const earthEclipticPrecession = {
  name: "Earth Ecliptic Precession",
  startPos: ((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/5)*360),
  speed: Math.PI*2/(holisticyearLength/5),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: -earthInvPlaneInclinationAmplitude,

  size: 0.1,
  color: 0xFEAA0D,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const earthObliquityPrecession = {
  name: "Earth Obliquity Precession",
  startPos: -((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/8)*360),
  speed: -Math.PI*2/(holisticyearLength/8),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: earthInvPlaneInclinationAmplitude,

  size: 0.1,
  color: 0xFEAA0D,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const earthPerihelionPrecession1 = {
  name: "Earth Perihelion Precession1",
  startPos: ((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/16)*360),
  speed: Math.PI*2/(holisticyearLength/16),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: -earthRAAngle,
  orbitTiltb: 0,

  size: 0.1,
  color: 0xFEAA0D,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const earthPerihelionPrecession2 = {
  name: "Earth Perihelion Precession2",
  startPos: -((balancedYear-startmodelyearwithCorrection)/(holisticyearLength/16)*360),
  speed: -Math.PI*2/(holisticyearLength/16),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: -eccentricityMean*100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.1,
  color: 0xFEAA0D,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const barycenterEarthAndSun = {
  name: "Barycenter Earth and Sun",
  startPos: 0,
  speed: 0,
  tilt: 0,
  orbitRadius: eccentricityAmplitude*100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const earthPerihelionFromEarth = {
  name: "PERIHELION-OF-EARTH",
  startPos: 0,    
  speed: 0,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.011,   
  color: 0xBF40BF,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/lightstar.png',
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceOn: true,
  traceLength : sYear * 1000000,
  traceStep : sYear,
  isNotPhysicalObject: true,
};

const sun = {
  name: "Sun",
  startPos: correctionSun,
  speed: Math.PI*2,
  rotationSpeed: (Math.PI*2)/(1/(meansolaryearlengthinDays/moonTropicalMonth)),
  tilt: -7.155,
  orbitRadius: 100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.sunDiameter/ currentAUDistance)*100,   
  color: 0x333333,
  visible: true,
  emissive: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,
  traceOn: false,
};

const moonApsidalPrecession = {
  name: "Moon Apsidal Precession",
  startPos: moonStartposApsidal,
  speed: (Math.PI*2)/(moonApsidalPrecessionindaysEarth/meansolaryearlengthinDays),
  tilt: 0,
  orbitRadius: -(moonDistance/currentAUDistance)*(moonOrbitalEccentricity*100),
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: moonEclipticInclinationJ2000-moonTilt,
  orbitTiltb: 0,

  size: 0.01,
  color: 0x8b8b8b,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
}; 

const moonApsidalNodalPrecession1 = {
  name: "Moon Apsidal Nodal Precession1",
  startPos: moonStartposApsidal-moonStartposNodal,
  speed: -(Math.PI*2)/(moonApsidalMeetsNodalindays/meansolaryearlengthinDays),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.001,
  color: 0x8b8b8b,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
}; 

const moonApsidalNodalPrecession2 = {
  name: "Moon Apsidal Nodal Precession2",
  startPos: -(moonStartposApsidal-moonStartposNodal),
  speed: (Math.PI*2)/(moonApsidalMeetsNodalindays/meansolaryearlengthinDays),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.001,
  color: 0x8b8b8b,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
}; 

const moonRoyerCyclePrecession = {
  name: "Moon Royer Cycle",
  startPos: 360-moonStartposApsidal-moonStartposNodal,
  speed: -(Math.PI*2)/(moonRoyerCycleindays/meansolaryearlengthinDays),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.001,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const moonNodalPrecession = {
  name: "Moon Nodal Precession",
  startPos: moonStartposNodal,
  speed: -(Math.PI*2)/(moonNodalPrecessionindaysEarth/meansolaryearlengthinDays),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90+180)*Math.PI)/180)*-moonEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90+180)*Math.PI)/180)*-moonEclipticInclinationJ2000,
  
  size: 0.001,
  color: 0x8b8b8b,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
}; 

const moon = {
  name: "Moon",
  startPos: moonStartposMoon,
  speed: (Math.PI*2)/(1/(meansolaryearlengthinDays/moonTropicalMonth)),
  rotationSpeed: 0,
  tilt: -moonTilt,
  orbitRadius: (moonDistance/currentAUDistance)*100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: (diameters.moonDiameter/ currentAUDistance)*100,
  color: 0x8b8b8b,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Moon.jpg',
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 19,
  traceStep : sDay,
  traceOn: false,
};

const mercuryPerihelionDurationEcliptic1 = {
  name: "Mercury Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/mercuryPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const mercuryPerihelionFromEarth = {
  name: "PERIHELION MERCURY",
  startPos: correctionSun,    
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((mercuryLongitudePerihelion+mercuryAngleCorrection+90))*Math.PI/180)*mercuryPerihelionDistance,
  orbitCenterb: Math.cos((90-(mercuryLongitudePerihelion+mercuryAngleCorrection-90))*Math.PI/180)*mercuryPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.5,
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/mercury_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear, 
  traceOn: false,
  isNotPhysicalObject: true,
};

const mercuryPerihelionDurationEcliptic2 = {
  name: "Mercury Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/mercuryPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const mercuryRealPerihelionAtSun = {
  name: "Mercury Real Perihelion At Sun",
  startPos: mercuryLowestPoint,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: mercuryElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: mercuryEccentricityPerihelion,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-mercuryAscendingNode)*Math.PI)/180)*-mercuryEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-mercuryAscendingNode)*Math.PI)/180)*-mercuryEclipticInclinationJ2000,

  size: 1.0,
  color: 0x868485,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const mercuryFixedPerihelionAtSun = {
  name: "Mercury Fixed Perihelion At Sun",
  startPos: mercuryLowestPoint,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-mercuryAscendingNode)*Math.PI)/180)*-mercuryEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-mercuryAscendingNode)*Math.PI)/180)*-mercuryEclipticInclinationJ2000,

  size: 1.0,
  color: 0x868485,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const mercury = {
  name: "Mercury",
  startPos: mercuryStartpos,
  speed: Math.PI*2/(holisticyearLength/mercurySolarYearCount),
  rotationSpeed: Math.PI*2*((mercuryRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: -mercuryTilt,
  orbitRadius: (((holisticyearLength/mercurySolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: (diameters.mercuryDiameter/ currentAUDistance)*100,
  color: 0x868485,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Mercury.jpg',
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 16,
  traceStep : sWeek,
  traceOn: false,
};

const venusPerihelionDurationEcliptic1 = {
  name: "Venus Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/venusPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const venusPerihelionFromEarth = {
  name: "PERIHELION VENUS",
  startPos: correctionSun, 
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((venusLongitudePerihelion+venusAngleCorrection+90))*Math.PI/180)*venusPerihelionDistance,
  orbitCenterb: Math.cos((90-(venusLongitudePerihelion+venusAngleCorrection-90))*Math.PI/180)*venusPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.1,   
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/venus_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear, 
  traceOn: false,
  isNotPhysicalObject: true,
};

const venusPerihelionDurationEcliptic2 = {
  name: "Venus Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/venusPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const venusRealPerihelionAtSun = {
  name: "Venus Real Perihelion At Sun",
  startPos: venusLowestPoint,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: venusElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: venusEccentricityPerihelion,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-venusAscendingNode)*Math.PI)/180)*-venusEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-venusAscendingNode)*Math.PI)/180)*-venusEclipticInclinationJ2000,

  size: 0.1,
  color: 0xA57C1B,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const venusFixedPerihelionAtSun = {
  name: "Venus Fixed Perihelion At Sun",
  startPos: venusLowestPoint,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-venusAscendingNode)*Math.PI)/180)*-venusEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-venusAscendingNode)*Math.PI)/180)*-venusEclipticInclinationJ2000,

  size: 0.1,
  color: 0xA57C1B,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const venus = {
  name: "Venus",
  startPos: venusStartpos,
  speed: Math.PI*2/(holisticyearLength/venusSolarYearCount),
  rotationSpeed: -Math.PI*2*((venusRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: -venusTilt,
  orbitRadius: (((holisticyearLength/venusSolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.venusDiameter/ currentAUDistance)*100,
  color: 0xA57C1B,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/VenusAtmosphere.jpg',
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 16,
  traceStep : sWeek,
  traceOn: false,
};

const marsPerihelionDurationEcliptic1 = {
  name: "Mars Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/marsPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const marsPerihelionFromEarth = {
  name: "PERIHELION MARS",
  startPos: correctionSun,    
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((marsLongitudePerihelion+marsAngleCorrection+90))*Math.PI/180)*marsPerihelionDistance,
  orbitCenterb: Math.cos((90-(marsLongitudePerihelion+marsAngleCorrection-90))*Math.PI/180)*marsPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.5,   
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/mars_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,
  traceOn: false,
  isNotPhysicalObject: true,
};

const marsPerihelionDurationEcliptic2 = {
  name: "Mars Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/marsPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const marsRealPerihelionAtSun = {
  name: "Mars Real Perihelion At Sun",
  startPos: marsStartpos*2,
  speed: -Math.PI*2+(2*Math.PI*2/(holisticyearLength/marsSolarYearCount)),
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: marsElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-marsAscendingNode)*Math.PI)/180)*-marsEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-marsAscendingNode)*Math.PI)/180)*-marsEclipticInclinationJ2000,

  size: 0.1,
  color: 0xFEAA0D,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
}; 

const marsFixedPerihelionAtSun = {
  name: "Mars Fixed Perihelion At Sun",
  startPos: marsStartpos*2,
  speed: -Math.PI*2+(2*Math.PI*2/(holisticyearLength/marsSolarYearCount)),
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-marsAscendingNode)*Math.PI)/180)*-marsEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-marsAscendingNode)*Math.PI)/180)*-marsEclipticInclinationJ2000,

  size: 0.1,
  color: 0xFEAA0D,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
}; 

const mars = {
  name: "Mars",
  startPos: marsStartpos,
  speed: -Math.PI*2/(holisticyearLength/marsSolarYearCount),
  rotationSpeed: Math.PI*2*((marsRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: -marsTilt,
  orbitRadius: (((holisticyearLength/marsSolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.marsDiameter/ currentAUDistance)*100,
  color: 0xFF0000,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Mars.jpg',
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 16,
  traceStep : sWeek, 
  traceOn: false,
};

const jupiterPerihelionDurationEcliptic1 = {
  name: "Jupiter Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/jupiterPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const jupiterPerihelionFromEarth = {
  name: "PERIHELION JUPITER",
  startPos: correctionSun,
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((jupiterLongitudePerihelion+jupiterAngleCorrection+90))*Math.PI/180)*jupiterPerihelionDistance,
  orbitCenterb: Math.cos((90-(jupiterLongitudePerihelion+jupiterAngleCorrection-90))*Math.PI/180)*jupiterPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.5,   
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/jupiter_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,
  traceOn: false,
  isNotPhysicalObject: true,
};

const jupiterPerihelionDurationEcliptic2 = {
  name: "Jupiter Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/jupiterPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const jupiterRealPerihelionAtSun = {
  name: "Jupiter Real Perihelion At Sun",
  startPos: jupiterStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: jupiterElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-jupiterAscendingNode)*Math.PI)/180)*-jupiterEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-jupiterAscendingNode)*Math.PI)/180)*-jupiterEclipticInclinationJ2000,
  
  size: 1.0,
  color: 0xCDC2B2,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const jupiterFixedPerihelionAtSun = {
  name: "Jupiter Fixed Perihelion At Sun",
  startPos: jupiterStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-jupiterAscendingNode)*Math.PI)/180)*-jupiterEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-jupiterAscendingNode)*Math.PI)/180)*-jupiterEclipticInclinationJ2000,
  
  size: 1.0,
  color: 0xCDC2B2,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const jupiter = {
  name: "Jupiter",
  startPos: jupiterStartpos,
  speed: Math.PI*2/(holisticyearLength/jupiterSolarYearCount),
  rotationSpeed: Math.PI*2*((jupiterRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: -jupiterTilt,
  orbitRadius: (((holisticyearLength/jupiterSolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.jupiterDiameter/ currentAUDistance)*100,
  color: 0xCDC2B2,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Jupiter.jpg',
  ringUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/other-rings.png',
  ringSize   : 11/6*(diameters.jupiterDiameter/ currentAUDistance)*100,
  ringInnerMult : 1.70,
  ringOuterMult : 1.90,
  ringOpacity   : 0.03,
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 16,
  traceStep : sWeek,
  traceOn: false,
};

const saturnPerihelionDurationEcliptic1 = {
  name: "Saturn Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/saturnPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const saturnPerihelionFromEarth = {
  name: "PERIHELION SATURN",
  startPos: correctionSun,
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((saturnLongitudePerihelion+saturnAngleCorrection+90))*Math.PI/180)*saturnPerihelionDistance,
  orbitCenterb: Math.cos((90-(saturnLongitudePerihelion+saturnAngleCorrection-90))*Math.PI/180)*saturnPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.5,
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/saturn_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,  
  traceOn: false,
  isNotPhysicalObject: true,
};

const saturnPerihelionDurationEcliptic2 = {
  name: "Saturn Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/saturnPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const saturnRealPerihelionAtSun = {
  name: "Saturn Real Perihelion At Sun",
  startPos: saturnStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: -saturnElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-saturnAscendingNode)*Math.PI)/180)*-saturnEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-saturnAscendingNode)*Math.PI)/180)*-saturnEclipticInclinationJ2000,

  size: 0.1,   
  color: 0xA79662,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const saturnFixedPerihelionAtSun = {
  name: "Saturn Fixed Perihelion At Sun",
  startPos: saturnStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-saturnAscendingNode)*Math.PI)/180)*-saturnEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-saturnAscendingNode)*Math.PI)/180)*-saturnEclipticInclinationJ2000,

  size: 0.1,   
  color: 0xA79662,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const saturn = {
  name: "Saturn",
  startPos: saturnStartpos,    
  speed: Math.PI*2/(holisticyearLength/saturnSolarYearCount),
  rotationSpeed: Math.PI*2*((saturnRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: -saturnTilt,
  orbitRadius: (((holisticyearLength/saturnSolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.saturnDiameter/ currentAUDistance)*100,
  color: 0xA79662,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Saturn.jpg',
  ringUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/saturn-rings.png',
  ringSize   : 2*(diameters.saturnDiameter/ currentAUDistance)*100,
  ringInnerMult: 1.23,
  ringOuterMult: 2.27,
  ringOpacity : 0.4,
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 250,
  traceStep : sWeek,
  traceOn: false,
};

const uranusPerihelionDurationEcliptic1 = {
  name: "Uranus Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/uranusPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const uranusPerihelionFromEarth = {
  name: "PERIHELION URANUS",
  startPos: correctionSun,    
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((uranusLongitudePerihelion+uranusAngleCorrection+90))*Math.PI/180)*uranusPerihelionDistance,
  orbitCenterb: Math.cos((90-(uranusLongitudePerihelion+uranusAngleCorrection-90))*Math.PI/180)*uranusPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.5,   
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/uranus_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,
  traceOn: false,
  isNotPhysicalObject: true,
};

const uranusPerihelionDurationEcliptic2 = {
  name: "Uranus Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/uranusPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const uranusRealPerihelionAtSun = {
  name: "Uranus Real Perihelion At Sun",
  startPos: uranusStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: uranusElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-uranusAscendingNode)*Math.PI)/180)*-uranusEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-uranusAscendingNode)*Math.PI)/180)*-uranusEclipticInclinationJ2000,

  size: 0.1,   
  color: 0xD2F9FA,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const uranusFixedPerihelionAtSun = {
  name: "Uranus Fixed Perihelion At Sun",
  startPos: uranusStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-uranusAscendingNode)*Math.PI)/180)*-uranusEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-uranusAscendingNode)*Math.PI)/180)*-uranusEclipticInclinationJ2000,

  size: 0.1,   
  color: 0xD2F9FA,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const uranus = {
  name: "Uranus",
  startPos: uranusStartpos,
  speed: Math.PI*2/(holisticyearLength/uranusSolarYearCount),
  rotationSpeed: -Math.PI*2*((uranusRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: -uranusTilt,
  orbitRadius: (((holisticyearLength/uranusSolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.uranusDiameter/ currentAUDistance)*100,
  color: 0xD2F9FA,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Uranus.jpg',
  ringUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/other-rings.png',
  ringSize   : 6/5*(diameters.uranusDiameter/ currentAUDistance)*100,
  ringInnerMult : 1.50,
  ringOuterMult : 2.00,
  ringOpacity   : 0.05,
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 250,
  traceStep : sWeek,  
  traceOn: false,
};

const neptunePerihelionDurationEcliptic1 = {
  name: "Neptune Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/neptunePerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const neptunePerihelionFromEarth = {
  name: "PERIHELION NEPTUNE",
  startPos: correctionSun,    
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((neptuneLongitudePerihelion+neptuneAngleCorrection+90))*Math.PI/180)*neptunePerihelionDistance,
  orbitCenterb: Math.cos((90-(neptuneLongitudePerihelion+neptuneAngleCorrection-90))*Math.PI/180)*neptunePerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.5,   
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/neptune_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,
  traceOn: false,
  isNotPhysicalObject: true,
};

const neptunePerihelionDurationEcliptic2 = {
  name: "Neptune Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/neptunePerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const neptuneRealPerihelionAtSun = {
  name: "Neptune Real Perihelion At Sun",
  startPos: neptuneStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: neptuneElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-neptuneAscendingNode)*Math.PI)/180)*-neptuneEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-neptuneAscendingNode)*Math.PI)/180)*-neptuneEclipticInclinationJ2000,

  size: 0.1,   
  color: 0x5E93F1,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const neptuneFixedPerihelionAtSun = {
  name: "Neptune Fixed Perihelion At Sun",
  startPos: neptuneStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-neptuneAscendingNode)*Math.PI)/180)*-neptuneEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-neptuneAscendingNode)*Math.PI)/180)*-neptuneEclipticInclinationJ2000,

  size: 0.1,   
  color: 0x5E93F1,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const neptune = {
  name: "Neptune",
  startPos: neptuneStartpos,
  speed: Math.PI*2/(holisticyearLength/neptuneSolarYearCount),
  rotationSpeed: Math.PI*2*((neptuneRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: -neptuneTilt,
  orbitRadius: (((holisticyearLength/neptuneSolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.neptuneDiameter/ currentAUDistance)*100,
  color: 0x5E93F1,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Neptune.jpg',
  ringUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/other-rings.png',
  ringSize   : 4/5*(diameters.neptuneDiameter/ currentAUDistance)*100,
  ringInnerMult : 1.80,
  ringOuterMult : 2.05,
  ringOpacity   : 0.03,
  visible: true,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 250,
  traceStep : sWeek,
  traceOn: false,
};

// The accurate orbits of Pluto and Halleys and Eros can be added later
// You might be able to make eccentric orbits with these settings but not sure if it works (helpfull for hallays?)
// orbitSemiMajor: 519.969067802053,
// orbitSemiMinor: 519.969067802053*Math.sqrt(1-0.048499*0.048499),

const plutoPerihelionDurationEcliptic1 = {
  name: "Pluto Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/plutoPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const plutoPerihelionFromEarth = {
  name: "PERIHELION PLUTO",
  startPos: correctionSun,    
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((plutoLongitudePerihelion+plutoAngleCorrection+90))*Math.PI/180)*plutoPerihelionDistance,
  orbitCenterb: Math.cos((90-(plutoLongitudePerihelion+plutoAngleCorrection-90))*Math.PI/180)*plutoPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 5,   
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/pluto_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,
  traceOn: false,
  isNotPhysicalObject: true,
};

const plutoPerihelionDurationEcliptic2 = {
  name: "Pluto Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/plutoPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const plutoRealPerihelionAtSun = {
  name: "Pluto Real Perihelion At Sun",
  startPos: plutoStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: plutoElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-plutoAscendingNode)*Math.PI)/180)*-plutoEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-plutoAscendingNode)*Math.PI)/180)*-plutoEclipticInclinationJ2000,

  size: 0.1,   
  color: 0x5E93F1,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const plutoFixedPerihelionAtSun = {
  name: "Pluto Fixed Perihelion At Sun",
  startPos: plutoStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-plutoAscendingNode)*Math.PI)/180)*-plutoEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-plutoAscendingNode)*Math.PI)/180)*-plutoEclipticInclinationJ2000,

  size: 0.1,   
  color: 0x5E93F1,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const pluto = {
  name: "Pluto",
  startPos: plutoStartpos,
  speed: Math.PI*2/(holisticyearLength/plutoSolarYearCount),
  rotationSpeed: Math.PI*2*((plutoRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: -plutoTilt,
  orbitRadius: (((holisticyearLength/plutoSolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.plutoDiameter/ currentAUDistance)*100,
  color: 0x5E93F1,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/FictionalMakemake.jpg',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 250,
  traceStep : sWeek,  
  traceOn: false,
};

const halleysPerihelionDurationEcliptic1 = {
  name: "Halleys Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/halleysPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const halleysPerihelionFromEarth = {
  name: "PERIHELION HALLEYS",
  startPos: correctionSun,    
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((halleysLongitudePerihelion+halleysAngleCorrection+90))*Math.PI/180)*halleysPerihelionDistance,
  orbitCenterb: Math.cos((90-(halleysLongitudePerihelion+halleysAngleCorrection-90))*Math.PI/180)*halleysPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 5,   
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/halleys_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear,  
  traceOn: false,
  isNotPhysicalObject: true,
};

const halleysPerihelionDurationEcliptic2 = {
  name: "Halleys Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/halleysPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const halleysRealPerihelionAtSun = {
  name: "Halleys Real Perihelion At Sun",
  startPos: halleysStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: halleysElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-halleysAscendingNode)*Math.PI)/180)*(-halleysEclipticInclinationJ2000),
  orbitTiltb: Math.sin(((-90-halleysAscendingNode)*Math.PI)/180)*(-halleysEclipticInclinationJ2000),

  size: 0.1,
  color: 0xA57C1B,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const halleysFixedPerihelionAtSun = {
  name: "Halleys Fixed Perihelion At Sun",
  startPos: halleysStartpos*2,
  speed: -Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-halleysAscendingNode)*Math.PI)/180)*(-halleysEclipticInclinationJ2000),
  orbitTiltb: Math.sin(((-90-halleysAscendingNode)*Math.PI)/180)*(-halleysEclipticInclinationJ2000),

  size: 0.1,
  color: 0xA57C1B,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const halleys = {
  name: "Halleys",
  startPos: halleysStartpos,
  speed: Math.PI*2/(holisticyearLength/halleysSolarYearCount),
  rotationSpeed: Math.PI*2*((halleysRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: halleysTilt,
  orbitRadius: (((holisticyearLength/halleysSolarYearCount) ** 2) **(1/3)) *100,
  orbitSemiMajor: 0,
  orbitSemiMinor: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.halleysDiameter/ currentAUDistance)*100,
  color: 0x00FF00,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/FictionalCeres.jpg',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 250,
  traceStep : sWeek,
  traceOn: false,
};

const erosPerihelionDurationEcliptic1 = {
  name: "Eros Perihelion Duration Ecliptic1",
  startPos: 0,
  speed: Math.PI*2/erosPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.5,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const erosPerihelionFromEarth = {
  name: "PERIHELION EROS",
  startPos: correctionSun,
  speed: Math.PI*2,
  rotationSpeed: 0,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: Math.cos(((erosLongitudePerihelion+erosAngleCorrection+90))*Math.PI/180)*erosPerihelionDistance,
  orbitCenterb: Math.cos((90-(erosLongitudePerihelion+erosAngleCorrection-90))*Math.PI/180)*erosPerihelionDistance,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: 0.5,   
  color: 0x333333,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/eros_perihelion.png',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 1000000,
  traceStep : sYear, 
  traceOn: false,
  isNotPhysicalObject: true,
};

const erosPerihelionDurationEcliptic2 = {
  name: "Eros Perihelion Duration Ecliptic2",
  startPos: 0,
  speed: -Math.PI*2/erosPerihelionICRFYears,
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,

  size: 0.01,
  color: 0xFFFF00,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const erosRealPerihelionAtSun = {
  name: "Eros Real Perihelion At Sun",
  startPos: erosStartpos*2,
  speed: -Math.PI*2+(2*Math.PI*2/(holisticyearLength/erosSolarYearCount)),
  tilt: 0,
  orbitRadius: erosElipticOrbit,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-erosAscendingNode)*Math.PI)/180)*-erosEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-erosAscendingNode)*Math.PI)/180)*-erosEclipticInclinationJ2000,

  size: 0.1,
  color: 0xA57C1B,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const erosFixedPerihelionAtSun = {
  name: "Eros Fixed Perihelion At Sun",
  startPos: erosStartpos*2,
  speed: -Math.PI*2+(2*Math.PI*2/(holisticyearLength/erosSolarYearCount)),
  tilt: 0,
  orbitRadius: 0,
  orbitCentera: 100,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: Math.cos(((-90-erosAscendingNode)*Math.PI)/180)*-erosEclipticInclinationJ2000,
  orbitTiltb: Math.sin(((-90-erosAscendingNode)*Math.PI)/180)*-erosEclipticInclinationJ2000,

  size: 0.1,
  color: 0xA57C1B,
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  isNotPhysicalObject: true,
};

const eros = {
  name: "Eros",
  startPos: erosStartpos,
  speed: -Math.PI*2/(holisticyearLength/erosSolarYearCount),
  rotationSpeed: Math.PI*2*((erosRotationPeriod/24)/meansolaryearlengthinDays),
  tilt: erosTilt,
  orbitRadius: (((holisticyearLength/erosSolarYearCount) ** 2) **(1/3)) *100,
  orbitCentera: 0,
  orbitCenterb: 0,
  orbitCenterc: 0,
  orbitTilta: 0,
  orbitTiltb: 0,
  
  size: (diameters.erosDiameter/ currentAUDistance)*100,
  color: 0xA57C1B,
  textureUrl: 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/FictionalEris.jpg',
  visible: false,
  containerObj:"",
  orbitObj:"",
  planetObj:"",
  pivotObj:"",
  traceLength : sYear * 16,
  traceStep : sWeek,
  traceOn: false,
};

//*************************************************************
// ADD CONSTANTS
//*************************************************************
const planetObjects = [startingPoint, earthWobbleCenter, midEccentricityOrbit, earth, earthInclinationPrecession, earthEclipticPrecession, earthObliquityPrecession, earthPerihelionPrecession1, earthPerihelionPrecession2, barycenterEarthAndSun, earthPerihelionFromEarth, mercuryPerihelionFromEarth, venusPerihelionFromEarth, marsPerihelionFromEarth, jupiterPerihelionFromEarth, saturnPerihelionFromEarth, uranusPerihelionFromEarth, neptunePerihelionFromEarth, plutoPerihelionFromEarth, halleysPerihelionFromEarth, erosPerihelionFromEarth, sun, moonApsidalPrecession, moonApsidalNodalPrecession1, moonApsidalNodalPrecession2, moonRoyerCyclePrecession, moonNodalPrecession, moon, mercuryPerihelionDurationEcliptic1, venusPerihelionDurationEcliptic1, marsPerihelionDurationEcliptic1, jupiterPerihelionDurationEcliptic1, saturnPerihelionDurationEcliptic1, uranusPerihelionDurationEcliptic1, neptunePerihelionDurationEcliptic1, plutoPerihelionDurationEcliptic1, halleysPerihelionDurationEcliptic1, erosPerihelionDurationEcliptic1, mercuryPerihelionDurationEcliptic2, mercuryRealPerihelionAtSun, mercury, mercuryFixedPerihelionAtSun, venusPerihelionDurationEcliptic2, venusRealPerihelionAtSun, venus, venusFixedPerihelionAtSun, marsPerihelionDurationEcliptic2, marsRealPerihelionAtSun, mars, marsFixedPerihelionAtSun, jupiterPerihelionDurationEcliptic2, jupiterRealPerihelionAtSun, jupiter, jupiterFixedPerihelionAtSun, saturnPerihelionDurationEcliptic2, saturnRealPerihelionAtSun, saturn, saturnFixedPerihelionAtSun, uranusPerihelionDurationEcliptic2, uranusRealPerihelionAtSun, uranus, uranusFixedPerihelionAtSun, neptunePerihelionDurationEcliptic2, neptuneRealPerihelionAtSun, neptune, neptuneFixedPerihelionAtSun, plutoPerihelionDurationEcliptic2, plutoRealPerihelionAtSun, pluto, plutoFixedPerihelionAtSun, halleysPerihelionDurationEcliptic2, halleysRealPerihelionAtSun, halleys, halleysFixedPerihelionAtSun, erosPerihelionDurationEcliptic2, erosRealPerihelionAtSun, eros, erosFixedPerihelionAtSun]

const tracePlanets = [earthWobbleCenter, earthPerihelionFromEarth, midEccentricityOrbit, mercuryPerihelionFromEarth, venusPerihelionFromEarth, marsPerihelionFromEarth, jupiterPerihelionFromEarth, saturnPerihelionFromEarth, uranusPerihelionFromEarth, neptunePerihelionFromEarth, plutoPerihelionFromEarth, halleysPerihelionFromEarth, erosPerihelionFromEarth, sun, moon, mercury, venus, mars, jupiter, saturn, uranus, neptune, pluto, halleys, eros]

//*************************************************************
// ADD ALL CALENDAR CONSTANTS
//*************************************************************
const GREGORIAN_START = { year: 1582, month: 10, day: 15};
// Start of the Gregorian Calendar
const GREGORIAN_START_JD = 2299160.5;
// Start of the Gregorian Calendar in Juliandate
const REVISION_START_JD = perihelionalignmentJD;
// Start of the Revised Julian Calendar in Juliandate

/* vertex: pass UV + world-space normal & position */
const EARTH_VERT = `
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPos;

void main(){
    vUv     = uv;
    vNormal = normalize(mat3(modelMatrix) * normal);
    vPos    = (modelMatrix * vec4(position,1.0)).xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}`;

/* fragment: on-the-fly TBN via screen-space derivatives */
const EARTH_FRAG = `
precision mediump float;

uniform sampler2D u_dayTexA;
uniform sampler2D u_dayTexB;
uniform sampler2D u_niteTexA;
uniform sampler2D u_niteTexB;
uniform float     u_dayMix;
uniform float     u_niteMix;
uniform sampler2D u_normalTexture;
uniform sampler2D u_specTexture;

uniform vec3  u_sunRelPosition;   /* vector Earth → Sun (world) */
uniform float u_normalPower;      /* 0-1 mix of normal-map shading */
uniform vec3  u_position;         /* planet centre (world) */
uniform float u_dayGain; 
uniform float u_termWidth;        /* terminator width */
uniform float u_iceGlowStrength;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPos;

/* build TBN on the fly */
mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv){
    vec3  dp1 = dFdx(p),   dp2 = dFdy(p);
    vec2  duv1 = dFdx(uv), duv2 = dFdy(uv);
    vec3  T = dp2 * duv1.x - dp1 * duv2.x;
    vec3  B = dp2 * duv1.y - dp1 * duv2.y;
    float invMax = inversesqrt(max(dot(T,T), dot(B,B)));
    return mat3(T*invMax, B*invMax, N);
}

void main(){

    vec3 sunDir = normalize(u_sunRelPosition);

    /* normal-map shading */
    vec3 texN = texture2D(u_normalTexture, vUv).xyz*2.0 - 1.0;
    mat3 tbn  = cotangent_frame(vNormal, vPos, vUv);
    vec3 nMap = normalize( mix( vNormal, normalize( tbn * texN ), u_normalPower ) );

    /* day-night mix */
    float hemi = dot(vNormal, sunDir)*0.5 + 0.5;  /* geometry only */
    float edge0 = 0.5 - 0.5 * u_termWidth;
    float edge1 = 0.5 + 0.5 * u_termWidth;
    hemi = smoothstep(edge0, edge1, clamp(hemi, 0.07, 1.0));

    /* day map ------------------------------------------------------------- */
    vec3 dayA = texture2D(u_dayTexA, vUv).rgb;
    vec3 dayB = texture2D(u_dayTexB, vUv).rgb;
    vec3 day  = mix(dayA, dayB, u_dayMix) * u_dayGain;

    /* night map ----------------------------------------------------------- */
    vec3 niteA = texture2D(u_niteTexA, vUv).rgb;
    vec3 niteB = texture2D(u_niteTexB, vUv).rgb;
    vec3 night = mix(niteA, niteB, u_niteMix);
    vec3 color = mix(night, day, hemi);

    /* --- polar ice glow ----------------------------------------------- */

    /* latitude mask: 0 at equator ➔ 1 at the poles                       *
    * change 0.5 to 0.6 if you want the band thinner                     */
    float latMask = smoothstep(0.5, 0.8, abs(vNormal.y));

    /* night-side weight (1 = full night, 0 = full day)                   */
    float nightMask = 1.0 - hemi;

    /* add faint bluish subsurface scatter                                */
    color += vec3(0.05, 0.07, 0.12)
       * latMask
       * nightMask
       * u_iceGlowStrength;     // 0-1 slider

    /* softer, Fresnel-weighted ocean specular */
    float specMask = texture2D(u_specTexture, vUv).r;          // oceans = 1, land = 0
    vec3  reflDir  = reflect(-sunDir, nMap);
    vec3  viewDir  = normalize(cameraPosition - vPos);

    float rough   = 0.08;                                      // 0 = mirror, ↑ = blurrier
    float spec    = pow(max(dot(reflDir, viewDir), 0.0), 1.0 / rough);

    float fresnel = pow(1.0 - max(dot(viewDir, nMap), 0.0), 5.0);
    float ocean   = specMask * hemi;                          // day-side water only

    color += spec * fresnel * ocean * 0.6; 

    gl_FragColor = vec4(color, 1.0);
}`;

/* atmosphere shell shaders */
const ATM_VERT = `
varying vec3 vN;
varying vec3 vPos;

void main(){
    vN   = normalize(normalMatrix * normal);
    vPos = (modelMatrix * vec4(position,1.0)).xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}`;
const ATM_FRAG = `
precision mediump float;

uniform vec3 u_sunRelPosition;     /* Earth → Sun (world) */
varying vec3 vN;
varying vec3 vPos;

void main(){

    vec3 sunDir  = normalize(u_sunRelPosition);
    vec3 viewDir = normalize(cameraPosition - vPos);

    /* classic rim term */
    float rim = pow(1.0 - max(dot(viewDir, vN), 0.0), 2.0);   // strongest at the edge

    /* forward-scattering haze on the day side */
    float dayGlow = pow(max(dot(sunDir, vN), 0.0), 3.0);

    float alpha  = clamp(rim * 0.45 + dayGlow * 0.25, 0.0, 1.0) * 0.7; // mix factors
    vec3  col   = vec3(0.35, 0.55, 1.0);                      // soft blue-sky tint

    gl_FragColor = vec4(col * alpha, alpha * 0.8);
}`;

const CLOUD_FRAG = `
precision mediump float;

uniform sampler2D u_cloudTexture;
uniform vec3      u_sunRelPosition;
uniform float     u_alpha;        /* global cloud thickness */
uniform float     u_nightCloudFactor;

varying vec2 vUv;
varying vec3 vNormal;

void main(){
    /* direction to the sun and raw “hemi” term (1 = day-side, 0 = night-side) */
    vec3  sunDir   = normalize(u_sunRelPosition);
    float hemi     = dot(vNormal, sunDir) * 0.5 + 0.5;   // range 0-1

    /* optional softness around the terminator */
    float termWidth = 0.15;                              // 0 = razor, 0.5 = very wide
    hemi = smoothstep(0.5 - termWidth, 0.5 + termWidth, hemi);

    /* visibility falls from 1.0 (noon) ➜ u_nightCloudFactor (mid-night) */
    float visibility = mix(u_nightCloudFactor, 1.0, hemi);

    /* sample once: RGB = colour,  A = mask                                   */
    vec4 cloudTex = texture2D(u_cloudTexture, vUv);

    vec3  colour = cloudTex.rgb * visibility;
    float alpha  = cloudTex.a  * u_alpha * visibility;

    gl_FragColor = vec4(colour, alpha);
}`;

//*************************************************************
// ADD ALL SETTINGS NEEDED FOR GUI
//*************************************************************
let o = {
  background: 0x000000,
  Run: false,
  traceBtn: false,
  '1 second equals': sWeek,
  speedFact: sWeek,
  speed: 1,
  reverse: false,

  'Step forward': function () {
    if (this.speedFact === sYear) {
      this.pos = dateToDays(addYears(this.Date, 1)) * sDay + timeToPos(this.Time);
    } else if (this.speedFact === sYear * 10) {
      this.pos = dateToDays(addYears(this.Date, 10)) * sDay + timeToPos(this.Time);
    } else if (this.speedFact === sYear * 100) {
      this.pos = dateToDays(addYears(this.Date, 100)) * sDay + timeToPos(this.Time);
    } else if (this.speedFact === sYear * 1000) {
      this.pos = dateToDays(addYears(this.Date, 1000)) * sDay + timeToPos(this.Time);
    } else {
      this.pos += this.speedFact;
    }
    positionChanged = true;
  },

  'Step backward': function () {
    if (this.speedFact === sYear) {
      this.pos = dateToDays(addYears(this.Date, -1)) * sDay + timeToPos(this.Time);
    } else if (this.speedFact === sYear * 10) {
      this.pos = dateToDays(addYears(this.Date, -10)) * sDay + timeToPos(this.Time);
    } else if (this.speedFact === sYear * 100) {
      this.pos = dateToDays(addYears(this.Date, -100)) * sDay + timeToPos(this.Time);
    } else if (this.speedFact === sYear * 1000) {
      this.pos = dateToDays(addYears(this.Date, -1000)) * sDay + timeToPos(this.Time);
    } else {
      this.pos -= this.speedFact;
    }
    positionChanged = true;
  },

  'Reset': function () {
    this.pos = 0;
    controls.reset();
    positionChanged = true;
  },

  'Now (time in UTC)': function () {
    const now = new Date();
    // Get UTC date string (YYYY-MM-DD)
    const dateStr = now.toISOString().slice(0, 10);
    // Get UTC time string (HH:MM:SS)
    const hh = String(now.getUTCHours()).padStart(2, '0');
    const mm = String(now.getUTCMinutes()).padStart(2, '0');
    const ss = String(now.getUTCSeconds()).padStart(2, '0');
    const timeStr = `${hh}:${mm}:${ss}`;
    // Calculate position: days + time offset
    const newPos = sDay * dateToDays(dateStr) + timeToPos(timeStr);
    this.pos = newPos;
    controls.reset();
    positionChanged = true;
  },

  Date: "",
  periheliondate: "",
  cSphereSize: 1,
  zodiacSize: 1,
  constellationLayout: 'asterism', // or 'stellarium'
  starDistanceScaleFact: 1.5,
  starDistance: 5000,
  starSize: 1,
  starsizeBase: 50,
  starNamesVisible: false,
  'Axis helpers': false,
  Orbits: true,
  Time: "00:00:00",
  Zoom: 0,
  worldCamX: '0',
  worldCamY: '0',
  worldCamZ: '0',
  worldCamDist: '0',
  worldCamDistKm: '0',
  worldCamRa: '0',
  worldCamDec: '0',

  Day: "",
  julianDay: "",
  juliandaysbalancedJD: 0,
  lengthofAU : 149597870.698828,
  pos : 0,
  sun : {pivotObj: new THREE.Object3D()},
  earth : {pivotObj: new THREE.Object3D()},
  displayFormat : 'sexagesimal',
  distanceUnit : 'AU',
  RA_Display : '',
  Dec_Display : '',
  perihelionDate : "",

  'Line trace': true,
  'Camera Lat': 0,
  'Camera Long': 0,
  'Polar line': false,
  polarLineLength: 1,
  Performance: false,
  debugAscendingNode: false,
  camX: 0,
  camY: 0,
  camZ: 0,
  Size: 1,
  traceSize: 1,
  traceLength: sYear * 18,
  traceStep: sDay,
  tracePlanet: earth,
  traceArrIndex: 0,
  Lines: true,

  moonElongation: 0.01,
  mercuryElongation: 0.01,
  venusElongation: 0.01,
  marsElongation: 0.01,
  jupiterElongation: 0.01,
  saturnElongation: 0.01,
  uranusElongation: 0.01,
  neptuneElongation: 0.01,
  plutoElongation: 0.01,
  halleysElongation: 0.01,
  erosElongation: 0.01,

  // Earth-frame perihelion (equatorial RA - fluctuates with Earth's precession)
  mercuryPerihelion: 0,
  venusPerihelion: 0,
  earthPerihelion: 0,
  marsPerihelion: 0,
  jupiterPerihelion: 0,
  saturnPerihelion: 0,
  uranusPerihelion: 0,
  neptunePerihelion: 0,
  plutoPerihelion: 0,
  halleysPerihelion: 0,
  erosPerihelion: 0,

  // Ecliptic-frame perihelion (J2000 ecliptic - stable, true heliocentric value)
  mercuryPerihelionEcliptic: 0,
  venusPerihelionEcliptic: 0,
  marsPerihelionEcliptic: 0,
  jupiterPerihelionEcliptic: 0,
  saturnPerihelionEcliptic: 0,
  uranusPerihelionEcliptic: 0,
  neptunePerihelionEcliptic: 0,
  plutoPerihelionEcliptic: 0,
  halleysPerihelionEcliptic: 0,
  erosPerihelionEcliptic: 0,
  
  mercuryArgumentOfPeriapsis: 0,
  venusArgumentOfPeriapsis: 0,
  marsArgumentOfPeriapsis: 0,
  jupiterArgumentOfPeriapsis: 0,
  saturnArgumentOfPeriapsis: 0,
  uranusArgumentOfPeriapsis: 0,
  neptuneArgumentOfPeriapsis: 0,
  plutoArgumentOfPeriapsis: 0,
  halleysArgumentOfPeriapsis: 0,
  erosArgumentOfPeriapsis: 0,
  
  mercuryAscendingNode: 0,
  venusAscendingNode: 0,
  marsAscendingNode: 0,
  jupiterAscendingNode: 0,
  saturnAscendingNode: 0,
  uranusAscendingNode: 0,
  neptuneAscendingNode: 0,
  plutoAscendingNode: 0,
  halleysAscendingNode: 0,
  erosAscendingNode: 0,

  mercuryDescendingNode: 0,
  venusDescendingNode: 0,
  marsDescendingNode: 0,
  jupiterDescendingNode: 0,
  saturnDescendingNode: 0,
  uranusDescendingNode: 0,
  neptuneDescendingNode: 0,
  plutoDescendingNode: 0,
  halleysDescendingNode: 0,
  erosDescendingNode: 0,

  mercuryMeanAnomaly: 0,
  mercuryTrueAnomaly: 0,
  mercuryEccentricAnomaly: 0,
  venusMeanAnomaly: 0,
  venusTrueAnomaly: 0,
  venusEccentricAnomaly: 0,
  marsMeanAnomaly: 0,
  marsTrueAnomaly: 0,
  marsEccentricAnomaly: 0,
  jupiterMeanAnomaly: 0,
  jupiterTrueAnomaly: 0,
  jupiterEccentricAnomaly: 0,
  saturnMeanAnomaly: 0,
  saturnTrueAnomaly: 0,
  saturnEccentricAnomaly: 0,
  uranusMeanAnomaly: 0,
  uranusTrueAnomaly: 0,
  uranusEccentricAnomaly: 0,
  neptuneMeanAnomaly: 0,
  neptuneTrueAnomaly: 0,
  neptuneEccentricAnomaly: 0,
  plutoMeanAnomaly: 0,
  plutoTrueAnomaly: 0,
  plutoEccentricAnomaly: 0,
  halleysMeanAnomaly: 0,
  halleysTrueAnomaly: 0,
  halleysEccentricAnomaly: 0,
  erosMeanAnomaly: 0,
  erosTrueAnomaly: 0,
  erosEccentricAnomaly: 0,

  // Earth anomalies (calculated from Sun's position)
  earthMeanAnomaly: 0,
  earthTrueAnomaly: 0,
  earthEccentricAnomaly: 0,
  earthArgumentOfPeriapsis: 0,

  // Height above invariable plane for each planet (in AU, positive = above)
  mercuryHeightAboveInvPlane: 0,
  venusHeightAboveInvPlane: 0,
  earthHeightAboveInvPlane: 0,
  marsHeightAboveInvPlane: 0,
  jupiterHeightAboveInvPlane: 0,
  saturnHeightAboveInvPlane: 0,
  uranusHeightAboveInvPlane: 0,
  neptuneHeightAboveInvPlane: 0,
  plutoHeightAboveInvPlane: 0,

  // Boolean flags for above/below invariable plane
  mercuryAboveInvPlane: true,
  venusAboveInvPlane: true,
  earthAboveInvPlane: true,
  marsAboveInvPlane: true,
  jupiterAboveInvPlane: true,
  saturnAboveInvPlane: true,
  uranusAboveInvPlane: true,
  neptuneAboveInvPlane: true,
  plutoAboveInvPlane: true,
  halleysHeightAboveInvPlane: 0,
  halleysAboveInvPlane: true,
  erosHeightAboveInvPlane: 0,
  erosAboveInvPlane: true,

  // Dynamic ascending nodes on invariable plane - J2000-verified values (primary, precess over time)
  mercuryAscendingNodeInvPlane: 0,
  venusAscendingNodeInvPlane: 0,
  earthAscendingNodeInvPlane: 0,
  marsAscendingNodeInvPlane: 0,
  jupiterAscendingNodeInvPlane: 0,
  saturnAscendingNodeInvPlane: 0,
  uranusAscendingNodeInvPlane: 0,
  neptuneAscendingNodeInvPlane: 0,
  plutoAscendingNodeInvPlane: 0,
  halleysAscendingNodeInvPlane: 0,
  erosAscendingNodeInvPlane: 0,

  // Dynamic ascending nodes on invariable plane - Souami & Souchay (2012) values (for comparison, precess over time)
  mercuryAscendingNodeInvPlaneSouamiSouchay: 0,
  venusAscendingNodeInvPlaneSouamiSouchay: 0,
  marsAscendingNodeInvPlaneSouamiSouchay: 0,
  jupiterAscendingNodeInvPlaneSouamiSouchay: 0,
  saturnAscendingNodeInvPlaneSouamiSouchay: 0,
  uranusAscendingNodeInvPlaneSouamiSouchay: 0,
  neptuneAscendingNodeInvPlaneSouamiSouchay: 0,
  plutoAscendingNodeInvPlaneSouamiSouchay: 0,
  halleysAscendingNodeInvPlaneSouamiSouchay: 0,
  erosAscendingNodeInvPlaneSouamiSouchay: 0,

  // Dynamic ascending nodes on invariable plane in ECLIPTIC coords (for height calculation)
  // Uses apparent precession rate (holisticyearLength/16 for Earth)
  mercuryAscendingNodeInvPlaneEcliptic: 0,
  venusAscendingNodeInvPlaneEcliptic: 0,
  earthAscendingNodeInvPlaneEcliptic: 0,
  marsAscendingNodeInvPlaneEcliptic: 0,
  jupiterAscendingNodeInvPlaneEcliptic: 0,
  saturnAscendingNodeInvPlaneEcliptic: 0,
  uranusAscendingNodeInvPlaneEcliptic: 0,
  neptuneAscendingNodeInvPlaneEcliptic: 0,
  plutoAscendingNodeInvPlaneEcliptic: 0,
  halleysAscendingNodeInvPlaneEcliptic: 0,
  erosAscendingNodeInvPlaneEcliptic: 0,

  // Dynamic ecliptic inclination using J2000-verified ascending nodes
  // These match J2000 reference values exactly at year 2000
  mercuryEclipticInclinationDynamic: 0,
  venusEclipticInclinationDynamic: 0,
  marsEclipticInclinationDynamic: 0,
  jupiterEclipticInclinationDynamic: 0,
  saturnEclipticInclinationDynamic: 0,
  uranusEclipticInclinationDynamic: 0,
  neptuneEclipticInclinationDynamic: 0,
  plutoEclipticInclinationDynamic: 0,
  halleysEclipticInclinationDynamic: 0,
  erosEclipticInclinationDynamic: 0,

  // Dynamic ecliptic inclination using Souami & Souchay (2012) ascending nodes
  // For comparison with original published data
  mercuryEclipticInclinationSouamiSouchayDynamic: 0,
  venusEclipticInclinationSouamiSouchayDynamic: 0,
  marsEclipticInclinationSouamiSouchayDynamic: 0,
  jupiterEclipticInclinationSouamiSouchayDynamic: 0,
  saturnEclipticInclinationSouamiSouchayDynamic: 0,
  uranusEclipticInclinationSouamiSouchayDynamic: 0,
  neptuneEclipticInclinationSouamiSouchayDynamic: 0,
  plutoEclipticInclinationSouamiSouchayDynamic: 0,
  halleysEclipticInclinationSouamiSouchayDynamic: 0,
  erosEclipticInclinationSouamiSouchayDynamic: 0,

  // Invariable Plane Positions Panel - mass-weighted balance
  massWeightedBalance: 0,           // Mass-weighted height balance (AU)
  planetsAboveInvPlane: 0,          // Count of planets above
  planetsBelowInvPlane: 0,          // Count of planets below

  // Validation: Option A vs Option B comparison
  calculatedPlaneTilt: 0,           // Calculated tilt from angular momentum (°) - J2000 fixed
  calculatedAscendingNode: 0,       // Calculated ascending node from angular momentum (°) - J2000 fixed
  jupiterAngularMomentumPercent: 0, // Jupiter's % of total L
  saturnAngularMomentumPercent: 0,  // Saturn's % of total L
  optionABDifference: 0,            // Angular difference between methods (°)

  // Balance Trend Analysis
  balanceTrackingActive: false,     // Is tracking currently recording?
  balanceTrackingStartYear: 0,      // Year when tracking started
  balanceYearsTracked: 0,           // Duration of tracking (years)
  balanceSampleCount: 0,            // Number of samples taken
  balanceCumulativeSum: 0,          // Running sum of all balance samples
  balanceLifetimeAverage: 0,        // Cumulative sum / sample count
  balanceMinSeen: 0,                // Minimum balance observed
  balanceMaxSeen: 0,                // Maximum balance observed

  Target: "",
  lookAtObj: {},
  
  testMode        : 'Range',         // 'Range' | 'List'
  testJDsText     : "2451717, 2627033, etc.",    // list of Julian Days you want to probe
  rangeStart      : startmodelJD-(meansolaryearlengthinDays*25200), 
  rangeEnd        : startmodelJD+(meansolaryearlengthinDays*23800),
  rangePieces     : ((25200+23800)/100)+1,
  runRATestToggle : false,
  _raTestBusy     : false,
  
  solMode        : 'Range',          // 'Range' | 'List'
  solYearsText   : '2000, 2005, etc.',
  solRangeStart  : 2000,
  solRangeEnd    : 2025,
  runSolToggle   : false,
  _solBusy       : false,

  // Year Analysis Report settings
  yearAnalysisMode       : 'Range',          // 'Range' | 'List'
  yearAnalysisYearsText  : '2000, 2005, etc.',
  yearAnalysisRangeStart : 2000,
  yearAnalysisRangeEnd   : 2025,
  runYearAnalysisToggle  : false,
  _yearAnalysisBusy      : false,

  // Obliquity Calibration Test state
  runCalibrationTest    : false,
  runFindOptimalRA      : false,
  runTropicalYearAnalysis : false,
  runDecemberSolsticeAnalysis : false,
  runInvestigateParams  : false,
  runVerifyPerihelionRate: false,
  runEquinoxAnalysis    : false,
  runAnoministicAnalysis: false,
  runSiderealYearAnalysis: false,
  runAllAlignments      : false,
  runSiderealDayAnalysis : false,
  runSolarDayAnalysis   : false,
  runStellarDayAnalysis : false,
  runDayDiagnostics     : false,
  runRADiagnostics      : false,
  calibrationYearStart  : 1990,
  calibrationYearEnd    : 2010,
  _calibrationBusy      : false
};

const params = { sizeBoost: 0 }; 

let predictions = {
  juliandaysbalancedJD: 0,
  lengthofDay: 0,
  lengthofsolarDay: 86400,
  lengthofsiderealDay: 0,
  lengthofstellarDay : 0,
  lengthofsiderealDayRealLOD: 0,
  lengthofstellarDayRealLOD: 0,
  predictedDeltat: 0,
  predictedDeltatPerYear: 0,
  lengthofsolarYear: 0,
  lengthofsolarYearinDays: 0,
  lengthofsiderealYear: 0,
  lengthofsiderealYearDays: 0,
  lengthofanomalisticYearinDays: 0,
  lengthofsolarYearSecRealLOD: 0,
  lengthofsiderealYearDaysRealLOD: 0,
  lengthofanomalisticDaysRealLOD: 0,
  lengthofanomalisticYearRealLOD: 0,
  perihelionPrecession: 0,
  axialPrecession: 0,
  inclinationPrecession: 0,
  obliquityPrecession: 0,
  eclipticPrecession: 0,
  perihelionPrecessionRealLOD: 0,
  axialPrecessionRealLOD: 0,
  inclinationPrecessionRealLOD: 0,
  obliquityPrecessionRealLOD: 0,
  eclipticPrecessionRealLOD: 0,
  eccentricityEarth: 0,
  obliquityEarth: 0,
  earthInvPlaneInclinationDynamic: 0,
  longitudePerihelion: 0,
  longitudePerihelionDatePer: 0,
  longitudePerihelionDateAp: 0,
  lengthofAU: currentAUDistance,
  anomalisticMercury: 0,
};

const planetColorHex = {
  earth:   0x2e64be,
  moon:    0x787878,
  mercury: 0x6e6e6e,
  venus:   0xd5ab37,
  mars:    0xb03a2e,
  jupiter: 0xc97e4f,
  saturn:  0xd9b65c,
  uranus:  0x37c6d0,
  neptune: 0x2c539e,
  sun:     0xffae00,
  pluto:   0xc9b29a,
  halleys: 0x9ecbff,
  eros:    0x8e8074,
};

//*************************************************************
// SETUP CAMERAS and CONTROLS
//*************************************************************
const camera = new THREE.PerspectiveCamera(15, window.innerWidth / window.innerHeight, 0.1, 10000000);
camera.position.set(0, 500, 0);
//camera.position.set(0, 0.5, 4);
const baseCamDistance = camera.position.length();

//*************************************************************
// LOAD DEFAULT SETTINGS (Three.js core setup (scene, camera, renderer))
//*************************************************************
const scene = new THREE.Scene();
scene.background = new THREE.Color( o.background );

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

// —– setup once —–
const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(window.innerWidth, window.innerHeight);
// ────────────────────────────────────────────────────
// 1) Style & add your CSS2DRenderer DOM element
// ────────────────────────────────────────────────────
labelRenderer.domElement.style.position      = 'absolute';
labelRenderer.domElement.style.top           = '0';
labelRenderer.domElement.style.left          = '0';
labelRenderer.domElement.style.right         = '0';
labelRenderer.domElement.style.bottom        = '0';
labelRenderer.domElement.style.pointerEvents = 'none';
labelRenderer.domElement.style.zIndex        = '0';
document.body.appendChild(labelRenderer.domElement);

// ----------------------------------------------------------
//  Patch CSS2DRenderer so labels never disappear and
//  use proper .project() for on-screen placement
// ----------------------------------------------------------
;(function(labelRenderer, baseCamDistance) {
  const projV    = new THREE.Vector3();
  const worldV   = new THREE.Vector3();   // scratch for world pos
  const camV     = new THREE.Vector3();   // scratch for camera‐space pos
  const dom      = labelRenderer.domElement;
  const zoomFactor = 0.5, minScale = 0.2, maxScale = 1.5;

  // Ensure the CSS2D layer really covers the viewport
  Object.assign(dom.style, {
    position:      'absolute',
    top:           '0',
    left:          '0',
    right:         '0',
    bottom:        '0',
    pointerEvents: 'none',
    zIndex:        '0'
  });

  labelRenderer.render = (scene, camera) => {
    if (!needsLabelUpdate) return;
    needsLabelUpdate = false;

    // console.groupCollapsed('[Label Debug] render start');
    // console.log('starNamesVisible =', o.starNamesVisible);

    // 1) Sync size
    const w = window.innerWidth, h = window.innerHeight;
    labelRenderer.setSize(w, h);

    // 2) Clear out any old labels
    while (dom.firstChild) dom.removeChild(dom.firstChild);

    // 3) Update matrices
    scene.updateMatrixWorld();
    camera.updateMatrixWorld();
    camera.updateProjectionMatrix();

    // 4) Compute scale
    const rawScale   = baseCamDistance / camera.position.length();
    const scaled     = Math.pow(rawScale, zoomFactor);
    const finalScale = Math.min(maxScale, Math.max(minScale, scaled));
    // console.log('Computed label scale:', finalScale.toFixed(3));

    // 5) Traverse and append only those labels that are both visible
    //    and in front of the camera
    let totalLabels   = 0;
    let wantVisible   = 0;
    let actuallyShown = 0;

    scene.traverse(obj => {
    if (!(obj instanceof CSS2DObject)) return;
    totalLabels++;

    // skip labels you’ve explicitly hidden
    if (!obj.visible) return;
    wantVisible++;

    //  a) get its world‐position
    worldV.setFromMatrixPosition(obj.matrixWorld);
    //  b) transform into camera‐space
    camV.copy(worldV).applyMatrix4(camera.matrixWorldInverse);
    //  c) cull if it’s behind (camera looks down –Z in three.js)
    if (camV.z > 0) return;

    // project to NDC then to screen
    projV.copy(worldV).project(camera);
    const x = (projV.x * 0.5 + 0.5) * w;
    const y = (-projV.y * 0.5 + 0.5) * h;

    // position & show
    const el = obj.element;
    el.style.transform = 
    `translate(-50%,-50%) translate(${x}px,${y}px) scale(${finalScale})`;
    el.style.display   = '';

    dom.appendChild(el);
    actuallyShown++;
    });

    // console.log(`Labels — total: ${totalLabels}, wanted: ${wantVisible}, shown: ${actuallyShown}`);
  };
})(labelRenderer, baseCamDistance);

renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.5; // Try adjusting this
renderer.useLegacyLights = false

document.body.appendChild(renderer.domElement);

// Memory improvement: create one loader, one cache
const textureLoader = new THREE.TextureLoader();
const textureCache = new Map();

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; // for smoother motion, optional
controls.dampingFactor = 0.5;  // Lower = smoother, higher = snappier
controls.enableKeys = false;
controls.zoomSpeed = 8.0;
controls.dollySpeed = 8.0;

// Per-planet minimum distance multipliers (distance = radius * multiplier)
const cameraMinDistMultiplier = {
  'Sun': 5.0,
  'Earth': 2.5,
  'Moon': 6.0,
  'Mercury': 5.0,
  'Venus': 5.0,
  'Mars': 5.0,
  'Jupiter': 5.0,
  'Saturn': 5.0,
  'Uranus': 5.0,
  'Neptune': 5.0,
  'Pluto': 5.0,
  'default': 5.0
};

function getCameraMinDistMultiplier(name) {
  return cameraMinDistMultiplier[name] ?? cameraMinDistMultiplier['default'];
}

// Prevent zooming inside planets by intercepting wheel events
renderer.domElement.addEventListener('wheel', (event) => {
  // Skip zoom prevention when hierarchy inspector is controlling camera
  if (hierarchyInspector._cameraControlActive) return;

  if (!o.lookAtObj?.planetObj || !o.lookAtObj.size) return;

  // Get current distance from camera to target
  const currentDistance = camera.position.distanceTo(controls.target);

  // Calculate minimum distance based on planet's visual size
  // Use rotationAxis scale (where blow-up slider applies) not planetObj scale
  const scale = o.lookAtObj.rotationAxis?.scale?.x ?? 1;
  const visualRadius = o.lookAtObj.size * scale;
  const multiplier = getCameraMinDistMultiplier(o.lookAtObj.name);
  const minDistance = visualRadius * multiplier;

  // If zooming in and already at or below minimum, block it
  // deltaY < 0 = scroll up = zoom in (on most systems)
  const zoomingIn = event.deltaY < 0;
  if (zoomingIn && currentDistance <= minDistance * 1.1) {
    event.preventDefault();
    event.stopPropagation();
  }
}, { passive: false, capture: true });

//*************************************************************
// CREATE AND CONFIGURE PLANETS
//*************************************************************
//First add the default settings of the planets
planetObjects.forEach(obj => createPlanet(obj));
updatePlanetSizes(0);

//Now adding the order of all objects 
startingPoint.pivotObj.add(earth.containerObj);

earth.pivotObj.add(earthInclinationPrecession.containerObj);
earthInclinationPrecession.pivotObj.add(midEccentricityOrbit.containerObj);
earthInclinationPrecession.pivotObj.add(earthEclipticPrecession.containerObj);
earthEclipticPrecession.pivotObj.add(earthObliquityPrecession.containerObj);
earthObliquityPrecession.pivotObj.add(earthPerihelionPrecession1.containerObj);
earthPerihelionPrecession1.pivotObj.add(earthPerihelionPrecession2.containerObj);
earthPerihelionPrecession2.pivotObj.add(barycenterEarthAndSun.containerObj);

barycenterEarthAndSun.pivotObj.add(sun.containerObj);
barycenterEarthAndSun.pivotObj.add(earthPerihelionFromEarth.containerObj);

earth.pivotObj.add(moonApsidalPrecession.containerObj);
moonApsidalPrecession.pivotObj.add(moonApsidalNodalPrecession1.containerObj);
moonApsidalNodalPrecession1.pivotObj.add(moonApsidalNodalPrecession2.containerObj);
moonApsidalNodalPrecession2.pivotObj.add(moonRoyerCyclePrecession.containerObj);
moonRoyerCyclePrecession.pivotObj.add(moonNodalPrecession.containerObj);
moonNodalPrecession.pivotObj.add(moon.containerObj);

barycenterEarthAndSun.pivotObj.add(mercuryPerihelionDurationEcliptic1.containerObj);
mercuryPerihelionDurationEcliptic1.pivotObj.add(mercuryPerihelionFromEarth.containerObj);
mercuryPerihelionFromEarth.pivotObj.add(mercuryPerihelionDurationEcliptic2.containerObj);
mercuryPerihelionDurationEcliptic2.pivotObj.add(mercuryRealPerihelionAtSun.containerObj);
mercuryRealPerihelionAtSun.pivotObj.add(mercury.containerObj);

mercuryPerihelionDurationEcliptic2.pivotObj.add(mercuryFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(venusPerihelionDurationEcliptic1.containerObj);
venusPerihelionDurationEcliptic1.pivotObj.add(venusPerihelionFromEarth.containerObj);
venusPerihelionFromEarth.pivotObj.add(venusPerihelionDurationEcliptic2.containerObj);
venusPerihelionDurationEcliptic2.pivotObj.add(venusRealPerihelionAtSun.containerObj);
venusRealPerihelionAtSun.pivotObj.add(venus.containerObj);

venusPerihelionDurationEcliptic2.pivotObj.add(venusFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(marsPerihelionDurationEcliptic1.containerObj);
marsPerihelionDurationEcliptic1.pivotObj.add(marsPerihelionFromEarth.containerObj);
marsPerihelionFromEarth.pivotObj.add(marsPerihelionDurationEcliptic2.containerObj);
marsPerihelionDurationEcliptic2.pivotObj.add(marsRealPerihelionAtSun.containerObj);
marsRealPerihelionAtSun.pivotObj.add(mars.containerObj);

marsPerihelionDurationEcliptic2.pivotObj.add(marsFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(jupiterPerihelionDurationEcliptic1.containerObj);
jupiterPerihelionDurationEcliptic1.pivotObj.add(jupiterPerihelionFromEarth.containerObj);
jupiterPerihelionFromEarth.pivotObj.add(jupiterPerihelionDurationEcliptic2.containerObj);
jupiterPerihelionDurationEcliptic2.pivotObj.add(jupiterRealPerihelionAtSun.containerObj);
jupiterRealPerihelionAtSun.pivotObj.add(jupiter.containerObj);

jupiterPerihelionDurationEcliptic2.pivotObj.add(jupiterFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(saturnPerihelionDurationEcliptic1.containerObj);
saturnPerihelionDurationEcliptic1.pivotObj.add(saturnPerihelionFromEarth.containerObj);
saturnPerihelionFromEarth.pivotObj.add(saturnPerihelionDurationEcliptic2.containerObj);
saturnPerihelionDurationEcliptic2.pivotObj.add(saturnRealPerihelionAtSun.containerObj);
saturnRealPerihelionAtSun.pivotObj.add(saturn.containerObj);

saturnPerihelionDurationEcliptic2.pivotObj.add(saturnFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(uranusPerihelionDurationEcliptic1.containerObj);
uranusPerihelionDurationEcliptic1.pivotObj.add(uranusPerihelionFromEarth.containerObj);
uranusPerihelionFromEarth.pivotObj.add(uranusPerihelionDurationEcliptic2.containerObj);
uranusPerihelionDurationEcliptic2.pivotObj.add(uranusRealPerihelionAtSun.containerObj);
uranusRealPerihelionAtSun.pivotObj.add(uranus.containerObj);

uranusPerihelionDurationEcliptic2.pivotObj.add(uranusFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(neptunePerihelionDurationEcliptic1.containerObj);
neptunePerihelionDurationEcliptic1.pivotObj.add(neptunePerihelionFromEarth.containerObj);
neptunePerihelionFromEarth.pivotObj.add(neptunePerihelionDurationEcliptic2.containerObj);
neptunePerihelionDurationEcliptic2.pivotObj.add(neptuneRealPerihelionAtSun.containerObj);
neptuneRealPerihelionAtSun.pivotObj.add(neptune.containerObj);

neptunePerihelionDurationEcliptic2.pivotObj.add(neptuneFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(plutoPerihelionDurationEcliptic1.containerObj);
plutoPerihelionDurationEcliptic1.pivotObj.add(plutoPerihelionFromEarth.containerObj);
plutoPerihelionFromEarth.pivotObj.add(plutoPerihelionDurationEcliptic2.containerObj);
plutoPerihelionDurationEcliptic2.pivotObj.add(plutoRealPerihelionAtSun.containerObj);
plutoRealPerihelionAtSun.pivotObj.add(pluto.containerObj);

plutoPerihelionDurationEcliptic2.pivotObj.add(plutoFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(halleysPerihelionDurationEcliptic1.containerObj);
halleysPerihelionDurationEcliptic1.pivotObj.add(halleysPerihelionFromEarth.containerObj);
halleysPerihelionFromEarth.pivotObj.add(halleysPerihelionDurationEcliptic2.containerObj);
halleysPerihelionDurationEcliptic2.pivotObj.add(halleysRealPerihelionAtSun.containerObj);
halleysRealPerihelionAtSun.pivotObj.add(halleys.containerObj);

halleysPerihelionDurationEcliptic2.pivotObj.add(halleysFixedPerihelionAtSun.containerObj);

barycenterEarthAndSun.pivotObj.add(erosPerihelionDurationEcliptic1.containerObj);
erosPerihelionDurationEcliptic1.pivotObj.add(erosPerihelionFromEarth.containerObj);
erosPerihelionFromEarth.pivotObj.add(erosPerihelionDurationEcliptic2.containerObj);
erosPerihelionDurationEcliptic2.pivotObj.add(erosRealPerihelionAtSun.containerObj);
erosRealPerihelionAtSun.pivotObj.add(eros.containerObj);

erosPerihelionDurationEcliptic2.pivotObj.add(erosFixedPerihelionAtSun.containerObj);

// The model starts on 21 june and not at 0 degrees (March equinox) so we need to turn it 90 degrees
// Why 21 june 2000?
// a) We need a solstice date
// b) We need to be able to point to polaris + pointing to the EARTH-WOBBLE-CENTER at RA 6h
// c) Close to J2000 values so we can check and compare all values
earth.containerObj.rotation.y = (Math.PI/2)*whichSolsticeOrEquinox;
//END CREATE AND CONFIGURE PLANETS

//*************************************************************
// CREATE VALUE HOLDERS FOR Right Ascension, Declination and Distance
//*************************************************************
planetObjects.forEach(obj => {
    obj.ra = "";
    obj.dec = "";
    obj.raDisplay = '';
    obj.decDisplay = '';
    obj.distDisplay = '';
    obj.sunDistDisplay  = '';
    obj.dist = "";      
    obj.distKm = ""; 
    obj.distMi = ""; 
    obj.sunDistAU = "";
    obj.perihelionDistAU = "";
    obj.sunDistKm = "";  
    obj.sunDistMi = "";
})

//*************************************************************
// SETUP LIGHT
//*************************************************************
// AMBIENT LIGHT — soft fill light for subtle illumination
const ambientLight = new THREE.AmbientLight(0x404040, o.ambientLight || 1.2);
scene.add(ambientLight);

const fallbackLight = new THREE.PointLight(0xffffff, 10000); // distance = 0 = infinite
fallbackLight.visible = false;
scene.add(fallbackLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 1);
sunLight.castShadow = true;

// Optional: adjust shadow quality
sunLight.shadow.mapSize.set(1024, 1024);
sunLight.shadow.bias = -0.0001;
sunLight.shadow.radius = 1;
sunLight.shadow.camera.far = 1000; // Increase only if necessary

// Optional: helper for debugging shadow frustum
//const shadowCameraHelper = new THREE.CameraHelper(sunLight.shadow.camera);
//scene.add(shadowCameraHelper);

// Add the light to the scene
scene.add(sunLight);
scene.add(sunLight.target);

//*************************************************************
// ADD CELESTIAL SPHERE, ECLIPTIC GRID & ZODIAC TO Earth
//*************************************************************
// Add polar line
const polarLine = createEarthPolarLine();
earth.rotationAxis.add(polarLine);

// Celestial sphere setup
const celestialSphere = createCelestialSphere(o.starDistance);
earth.rotationAxis.add(celestialSphere);
celestialSphere.visible = false;

// Object to help align the celestial sphere
const csLookAtObj = new THREE.Object3D();
celestialSphere.add(csLookAtObj);

// Ground plane grid helper
const plane = new THREE.GridHelper(o.starDistance * 2, 30, 0x008800, 0x000088);
earth.pivotObj.add(plane);
plane.visible = false;

// Zodiac
const zodiac = new THREE.PolarGridHelper(250, 24, 1, 64, 0x000000, 0x555555);

// Generate zodiac circular text texture
const zodiacText = "      GEMINI             TAURUS             ARIES             PISCES          AQUARIUS       CAPRICORN     SAGITTARIUS      SCORPIO             LIBRA              VIRGO                LEO               CANCER ";
const zCanvas = getCircularText(
    zodiacText,
    800,
    0,
    "right",
    false,
    true,
    "Arial",
    "18pt",
    2
);

// Create texture and mesh for circular label
const zTexture = new THREE.CanvasTexture(zCanvas);
zTexture.anisotropy = 8;
zTexture.minFilter = THREE.LinearMipMapLinearFilter;
zTexture.magFilter = THREE.LinearFilter;
zTexture.needsUpdate = true;

const zLabelGeometry = new THREE.RingGeometry(235, 250, 64);
const zLabelMaterial = new THREE.MeshBasicMaterial({
    map: zTexture,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 1,
    depthWrite: false
});

const zLabel = new THREE.Mesh(zLabelGeometry, zLabelMaterial);
zLabel.rotation.x = -Math.PI / 2;
zodiac.add(zLabel);

// Add to scene
earth.pivotObj.add(zodiac);
zodiac.position.y = 0;
zodiac.position.z = -(eccentricityAmplitude*Math.PI*2)/(holisticyearLength/13)*(startmodelyearwithCorrection-(perihelionalignmentYear-(1.5*(holisticyearLength/16))+(Math.round((startmodelyearwithCorrection-perihelionalignmentYear+((1.5*(holisticyearLength/16))))/(holisticyearLength/156)))*(holisticyearLength/156)))*100; //To align to start Aquarius
zodiac.visible = false;

// Add Glow effect of zodiac (64 segments is sufficient for a smooth glow ring)
const glowGeometry = new THREE.RingGeometry(255, 265, 64);
const glowMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffaa,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.2,
    depthWrite: false
});

// Add Glow ring (can be used in render loop)
const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
glowRing.rotation.x = -Math.PI / 2;
zodiac.add(glowRing);

//*************************************************************
// INVARIABLE PLANE VISUALIZATION
//*************************************************************

// Helper function to create the invariable plane (tilted grid/disc)
function createInvariablePlaneVisualization(size = 500, divisions = 20) {
  const group = new THREE.Group();
  group.name = 'InvariablePlaneVisualization';

  // Use the same orientation logic as the Sun-centered invariable plane
  // Apply quaternion directly to the main group (like Sun-centered does)
  // The orientation will be updated dynamically in updateInvariablePlanePosition()
  const earthI = earthInvPlaneInclinationMean * Math.PI / 180;
  const earthOmega = earthAscendingNodeInvPlaneVerified * Math.PI / 180;

  // Calculate tilt axis (line of nodes - points toward ascending node)
  const tiltAxisX = Math.cos(earthOmega);
  const tiltAxisZ = Math.sin(earthOmega);
  const tiltAxis = new THREE.Vector3(tiltAxisX, 0, tiltAxisZ).normalize();

  // Create quaternion to rotate around the tilt axis
  // Apply to main group directly (not a subgroup) - same as Sun-centered plane
  const quaternion = new THREE.Quaternion();
  quaternion.setFromAxisAngle(tiltAxis, earthI);
  group.quaternion.copy(quaternion);

  // Grid helper - flat in the group, orientation applied via quaternion on group
  const gridHelper = new THREE.GridHelper(size, divisions, 0xaa44aa, 0x663366);
  gridHelper.material.opacity = 0.4;
  gridHelper.material.transparent = true;
  group.add(gridHelper);

  // Solid disc for better visibility
  const discGeometry = new THREE.CircleGeometry(size / 2, 32);
  const discMaterial = new THREE.MeshBasicMaterial({
    color: 0x8844aa,
    transparent: true,
    opacity: 0.15,
    side: THREE.DoubleSide
  });
  const disc = new THREE.Mesh(discGeometry, discMaterial);
  disc.rotation.x = -Math.PI / 2; // Lay flat in the group
  group.add(disc);

  // Edge ring - thicker and more visible (magenta)
  const ringGeometry = new THREE.RingGeometry(size/2 - 4, size/2, 64);
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0xff44ff,
    transparent: true,
    opacity: 0.7,
    side: THREE.DoubleSide
  });
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.rotation.x = -Math.PI / 2;
  group.add(ring);

  // ===== FIXED MARKERS GROUP =====
  // HIGH/LOW/MEAN markers are FIXED in ICRF coordinates based on earthInclinationPhaseAngle (203.3195°)
  // They do NOT precess with the ascending node
  // These are added to a SEPARATE group that doesn't rotate with the plane
  // Position is calculated by applying the plane's quaternion manually (like Sun-centered max incl marker)
  const markersGroup = new THREE.Group();
  markersGroup.name = 'InvPlaneMarkersGroup';

  const halfSize = size / 2;
  const markerDist = halfSize * 0.95;
  const tubeLength = size * 0.9;
  const phaseAngleRad = earthInclinationPhaseAngle * Math.PI / 180;

  // HIGH marker angle: at the phase angle (where inclination is maximum)
  const highAngle = -phaseAngleRad;  // Negate for correct ICRF orientation (like Sun-centered)
  // LOW marker angle: 180° opposite (where inclination is minimum)
  const lowAngle = highAngle + Math.PI;

  // Calculate inclination range values
  const maxInclination = earthInvPlaneInclinationMean + earthInvPlaneInclinationAmplitude;
  const minInclination = earthInvPlaneInclinationMean - earthInvPlaneInclinationAmplitude;

  // ===== HIGH-LOW AXIS TUBE (yellow) =====
  // This tube connects HIGH to LOW markers - shows the axis of maximum/minimum inclination
  const highLowTubeGeom = new THREE.CylinderGeometry(3, 3, tubeLength, 8);
  const highLowTubeMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 });
  const highLowTube = new THREE.Mesh(highLowTubeGeom, highLowTubeMat);
  // Cylinder is along Y by default, rotate to lie flat then orient toward HIGH angle
  highLowTube.rotation.z = Math.PI / 2;  // Lay flat (along X)
  markersGroup.add(highLowTube);

  // ===== MEAN AXIS TUBE (magenta) =====
  // This tube is perpendicular to HIGH-LOW - shows where inclination equals the mean
  const meanTubeGeom = new THREE.CylinderGeometry(3, 3, tubeLength, 8);
  const meanTubeMat = new THREE.MeshBasicMaterial({ color: 0xff88ff, transparent: true, opacity: 0.6 });
  const meanTube = new THREE.Mesh(meanTubeGeom, meanTubeMat);
  meanTube.rotation.z = Math.PI / 2;  // Lay flat (along X)
  markersGroup.add(meanTube);

  // High point marker (yellow) - where Earth reaches MAXIMUM inclination
  const markerGeom = new THREE.SphereGeometry(12, 12, 12);
  const highMarkerMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const highMarker = new THREE.Mesh(markerGeom, highMarkerMat);
  markersGroup.add(highMarker);

  // Low point marker (cyan) - where Earth reaches MINIMUM inclination
  const lowMarkerMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  const lowMarker = new THREE.Mesh(markerGeom, lowMarkerMat);
  markersGroup.add(lowMarker);

  // Add labels for high/low points with inclination values
  const highLabelDiv = document.createElement('div');
  highLabelDiv.innerHTML = '<span style="font-size:16px;font-weight:bold;">HIGH</span><br>' + maxInclination.toFixed(4) + '°<br><span style="font-size:10px;color:#ffff88;">' + earthInclinationPhaseAngle + '°</span>';
  highLabelDiv.style.color = '#ffff00';
  highLabelDiv.style.fontSize = '14px';
  highLabelDiv.style.fontFamily = 'Arial, sans-serif';
  highLabelDiv.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  highLabelDiv.style.pointerEvents = 'none';
  highLabelDiv.style.textAlign = 'center';
  highLabelDiv.style.lineHeight = '1.3';
  highLabelDiv.style.display = 'none'; // Hidden by default
  const highLabelObj = new CSS2DObject(highLabelDiv);
  highMarker.add(highLabelObj);  // Add to marker so it moves with it
  highLabelObj.position.set(0, 20, 0);

  const lowLabelDiv = document.createElement('div');
  lowLabelDiv.innerHTML = '<span style="font-size:16px;font-weight:bold;">LOW</span><br>' + minInclination.toFixed(4) + '°<br><span style="font-size:10px;color:#88ffff;">' + ((earthInclinationPhaseAngle + 180) % 360) + '°</span>';
  lowLabelDiv.style.color = '#00ffff';
  lowLabelDiv.style.fontSize = '14px';
  lowLabelDiv.style.fontFamily = 'Arial, sans-serif';
  lowLabelDiv.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  lowLabelDiv.style.pointerEvents = 'none';
  lowLabelDiv.style.textAlign = 'center';
  lowLabelDiv.style.lineHeight = '1.3';
  lowLabelDiv.style.display = 'none'; // Hidden by default
  const lowLabelObj = new CSS2DObject(lowLabelDiv);
  lowMarker.add(lowLabelObj);  // Add to marker so it moves with it
  lowLabelObj.position.set(0, 20, 0);

  // Mean markers at 90° offset from phase angle (where inclination = mean value)
  // These are FIXED in ICRF coordinates, not at the precessing ascending/descending nodes
  const meanMarkerGeom = new THREE.SphereGeometry(10, 12, 12);
  const meanMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff88ff }); // Magenta

  // Mean markers at 90° before and after the HIGH point
  const mean1Angle = highAngle + Math.PI / 2;  // 90° after HIGH
  const mean2Angle = highAngle - Math.PI / 2;  // 90° before HIGH

  // Mean marker 1 (90° after HIGH)
  const meanMarker1 = new THREE.Mesh(meanMarkerGeom, meanMarkerMat);
  markersGroup.add(meanMarker1);

  // Mean marker 2 (90° before HIGH)
  const meanMarker2 = new THREE.Mesh(meanMarkerGeom, meanMarkerMat);
  markersGroup.add(meanMarker2);

  // Mean labels - attach to markers so they move with them
  const meanLabel1Div = document.createElement('div');
  meanLabel1Div.innerHTML = '<span style="font-size:14px;font-weight:bold;">MEAN</span><br>' + earthInvPlaneInclinationMean.toFixed(4) + '°';
  meanLabel1Div.style.color = '#ff88ff';
  meanLabel1Div.style.fontSize = '12px';
  meanLabel1Div.style.fontFamily = 'Arial, sans-serif';
  meanLabel1Div.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  meanLabel1Div.style.pointerEvents = 'none';
  meanLabel1Div.style.textAlign = 'center';
  meanLabel1Div.style.lineHeight = '1.3';
  meanLabel1Div.style.display = 'none'; // Hidden by default
  const meanLabel1Obj = new CSS2DObject(meanLabel1Div);
  meanMarker1.add(meanLabel1Obj);  // Add to marker so it moves with it
  meanLabel1Obj.position.set(0, 15, 0);

  const meanLabel2Div = document.createElement('div');
  meanLabel2Div.innerHTML = '<span style="font-size:14px;font-weight:bold;">MEAN</span><br>' + earthInvPlaneInclinationMean.toFixed(4) + '°';
  meanLabel2Div.style.color = '#ff88ff';
  meanLabel2Div.style.fontSize = '12px';
  meanLabel2Div.style.fontFamily = 'Arial, sans-serif';
  meanLabel2Div.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  meanLabel2Div.style.pointerEvents = 'none';
  meanLabel2Div.style.textAlign = 'center';
  meanLabel2Div.style.lineHeight = '1.3';
  meanLabel2Div.style.display = 'none'; // Hidden by default
  const meanLabel2Obj = new CSS2DObject(meanLabel2Div);
  meanMarker2.add(meanLabel2Obj);  // Add to marker so it moves with it
  meanLabel2Obj.position.set(0, 15, 0);

  // Store references to markers and labels for dynamic updates
  // Store markersGroup and angle data for position updates in updateInvariablePlanePosition()
  group.userData.markersGroup = markersGroup;
  group.userData.highMarker = highMarker;
  group.userData.lowMarker = lowMarker;
  group.userData.meanMarker1 = meanMarker1;
  group.userData.meanMarker2 = meanMarker2;
  group.userData.highLowTube = highLowTube;
  group.userData.meanTube = meanTube;
  group.userData.highLabelDiv = highLabelDiv;
  group.userData.lowLabelDiv = lowLabelDiv;
  group.userData.meanLabel1Div = meanLabel1Div;
  group.userData.meanLabel2Div = meanLabel2Div;
  group.userData.highLabelObj = highLabelObj;
  group.userData.lowLabelObj = lowLabelObj;
  group.userData.meanLabel1Obj = meanLabel1Obj;
  group.userData.meanLabel2Obj = meanLabel2Obj;
  group.userData.markerDist = markerDist;
  group.userData.tubeLength = tubeLength;
  group.userData.highAngle = highAngle;
  group.userData.lowAngle = lowAngle;
  group.userData.mean1Angle = mean1Angle;
  group.userData.mean2Angle = mean2Angle;

  // Set all CSS2DObjects to not visible initially (this is what the patched renderer checks)
  highLabelObj.visible = false;
  lowLabelObj.visible = false;
  meanLabel1Obj.visible = false;
  meanLabel2Obj.visible = false;

  // ===== EARTH HEIGHT INDICATOR (Annual Crossing) =====
  // Shows Earth's current position above/below the invariable plane
  // This changes over 1 year (NOT the holisticyearLength/3 inclination cycle)
  // Earth crosses the plane in early July (ascending) and early January (descending)

  // Create a dashed line from Earth to the invariable plane
  const earthHeightLineGeom = new THREE.BufferGeometry();
  const linePositions = new Float32Array([
    0, 0, 0,  // Start at plane (will be updated)
    0, 0, 0   // End at Earth height (will be updated)
  ]);
  earthHeightLineGeom.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));

  const earthHeightLineMat = new THREE.LineDashedMaterial({
    color: 0x44ff44,  // Green (will change based on above/below)
    dashSize: 5,
    gapSize: 3,
    linewidth: 2
  });

  const earthHeightLine = new THREE.Line(earthHeightLineGeom, earthHeightLineMat);
  earthHeightLine.computeLineDistances(); // Required for dashed lines
  earthHeightLine.name = 'EarthHeightLine';
  group.add(earthHeightLine);

  // Create Earth height label
  const earthHeightLabelDiv = document.createElement('div');
  earthHeightLabelDiv.innerHTML = '<span style="font-size:14px;font-weight:bold;">EARTH</span><br>0.000000 AU<br><span style="font-size:12px;">ABOVE</span>';
  earthHeightLabelDiv.style.color = '#44ff44';
  earthHeightLabelDiv.style.fontSize = '12px';
  earthHeightLabelDiv.style.fontFamily = 'Arial, sans-serif';
  earthHeightLabelDiv.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  earthHeightLabelDiv.style.pointerEvents = 'none';
  earthHeightLabelDiv.style.textAlign = 'center';
  earthHeightLabelDiv.style.lineHeight = '1.2';
  earthHeightLabelDiv.style.background = 'rgba(0, 0, 0, 0.5)';
  earthHeightLabelDiv.style.padding = '4px 8px';
  earthHeightLabelDiv.style.borderRadius = '4px';

  const earthHeightLabelObj = new CSS2DObject(earthHeightLabelDiv);
  earthHeightLabelObj.position.set(0, 20, 0); // Will be updated dynamically
  earthHeightLabelObj.visible = false; // Hidden by default (invariable plane starts hidden)
  group.add(earthHeightLabelObj);

  // Create a small sphere marker at Earth's projected position on the plane
  const earthPlaneMarkerGeom = new THREE.SphereGeometry(6, 12, 12);
  const earthPlaneMarkerMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.8
  });
  const earthPlaneMarker = new THREE.Mesh(earthPlaneMarkerGeom, earthPlaneMarkerMat);
  earthPlaneMarker.position.set(0, 0, 0); // At Earth's projection on the plane
  earthPlaneMarker.name = 'EarthPlaneMarker';
  group.add(earthPlaneMarker);

  // Store references for dynamic updates
  group.userData.earthHeightLine = earthHeightLine;
  group.userData.earthHeightLabelDiv = earthHeightLabelDiv;
  group.userData.earthHeightLabelObj = earthHeightLabelObj;
  group.userData.earthPlaneMarker = earthPlaneMarker;

  return group;
}

// Helper function to create the inclination path (wobble curve)
// The path should align with zodiac so mean crossings are at Cancer/Capricorn (solstice axis)
function createInclinationPath(radius = 250, numPoints = 120, yScale = 50) {
  const group = new THREE.Group();
  group.name = 'InclinationPath';

  const points = [];
  const colors = [];
  const CYCLE_LENGTH = holisticyearLength / 3; // Inclination precession cycle

  // Phase offset to align the path with the zodiac
  // The path is now a child of zodiac, so it's in zodiac's local coordinate system.
  // Uses global inclinationPathZodiacOffsetDeg constant
  const PHASE_OFFSET = Math.PI + inclinationPathZodiacOffsetDeg * Math.PI / 180;

  for (let i = 0; i <= numPoints; i++) {
    const t = i / numPoints;
    const year = balancedYear + t * CYCLE_LENGTH;

    const incl = computeInclinationEarth(
      year, balancedYear, holisticyearLength,
      earthInvPlaneInclinationMean, earthInvPlaneInclinationAmplitude
    );

    // Calculate angle with phase offset
    // Negate to make marker move counterclockwise (same direction as Earth's orbit)
    const angle = -(t * Math.PI * 2) + PHASE_OFFSET;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    const deviationFromMean = incl - earthInvPlaneInclinationMean;
    // Higher inclination (further from invariable plane) = HIGHER in visualization (positive Y)
    const y = deviationFromMean * yScale;

    points.push(new THREE.Vector3(x, y, z));

    // Color: yellow at max incl, blue at min incl
    const minIncl = earthInvPlaneInclinationMean - earthInvPlaneInclinationAmplitude;
    const maxIncl = earthInvPlaneInclinationMean + earthInvPlaneInclinationAmplitude;
    const norm = (incl - minIncl) / (maxIncl - minIncl);
    colors.push(norm, norm * 0.8, 1 - norm * 0.5);
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

  const material = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2 });
  const pathLine = new THREE.Line(geometry, material);
  group.add(pathLine);

  // Current position marker group (contains sphere, arrow, and label)
  const markerGroup = new THREE.Group();
  markerGroup.name = 'CurrentInclinationMarker';

  // Yellow sphere
  const markerGeom = new THREE.SphereGeometry(3, 8, 8);
  const markerMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const markerSphere = new THREE.Mesh(markerGeom, markerMat);
  markerGroup.add(markerSphere);

  // Direction arrow (points in direction of motion along the path)
  const arrowLength = 25;
  const arrowHeadLength = 8;
  const arrowHeadWidth = 5;
  const arrowDir = new THREE.Vector3(1, 0, 0); // Will be updated dynamically
  const arrowOrigin = new THREE.Vector3(0, 0, 0);
  const arrowHelper = new THREE.ArrowHelper(arrowDir, arrowOrigin, arrowLength, 0xff8800, arrowHeadLength, arrowHeadWidth);
  arrowHelper.name = 'DirectionArrow';
  markerGroup.add(arrowHelper);

  // Inclination value label (using CSS2DObject for crisp text)
  const labelDiv = document.createElement('div');
  labelDiv.className = 'inclination-label';
  labelDiv.style.color = '#ffff00';
  labelDiv.style.fontSize = '14px';
  labelDiv.style.fontFamily = 'Arial, sans-serif';
  labelDiv.style.fontWeight = 'bold';
  labelDiv.style.textShadow = '1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black';
  labelDiv.style.pointerEvents = 'none';
  labelDiv.style.whiteSpace = 'nowrap';
  labelDiv.textContent = '';
  const labelObject = new CSS2DObject(labelDiv);
  labelObject.position.set(0, 12, 0); // Position above the marker
  labelObject.name = 'InclinationLabel';
  labelObject.visible = false; // Hidden initially (patched renderer checks this)
  markerGroup.add(labelObject);

  // Hide marker group initially (will be shown when path becomes visible)
  markerGroup.visible = false;

  group.add(markerGroup);

  // Store references for update function
  group.userData.marker = markerGroup;
  group.userData.markerSphere = markerSphere;
  group.userData.arrowHelper = arrowHelper;
  group.userData.labelObject = labelObject;
  group.userData.labelDiv = labelDiv;
  group.userData.radius = radius;
  group.userData.yScale = yScale;
  group.userData.phaseOffset = PHASE_OFFSET;

  return group;
}

// Update function for inclination path marker (called in render loop, throttled)
let _lastInclinationUpdateYear = null;
const _inclinationArrowDir = new THREE.Vector3(); // Reusable vector for arrow direction
function updateInclinationPathMarker() {
  const marker = inclinationPathGroup.userData.marker;
  const labelDiv = inclinationPathGroup.userData.labelDiv;
  const labelObject = inclinationPathGroup.userData.labelObject;

  // Hide marker and label when path is not visible
  if (!inclinationPathGroup.visible) {
    if (marker.visible) {
      marker.visible = false;
      labelObject.visible = false; // Use CSS2DObject.visible (patched renderer checks this)
    }
    return;
  }

  // Check if this is a fresh show (marker was hidden, now path is visible)
  const needsImmediateUpdate = !marker.visible;

  // Throttle: only update if year changed significantly (0.1 year = ~36 days)
  // But always update on fresh show
  if (!needsImmediateUpdate && _lastInclinationUpdateYear !== null &&
      Math.abs(o.currentYear - _lastInclinationUpdateYear) < 0.1) {
    return;
  }
  _lastInclinationUpdateYear = o.currentYear;

  const arrowHelper = inclinationPathGroup.userData.arrowHelper;
  const radius = inclinationPathGroup.userData.radius;
  const yScale = inclinationPathGroup.userData.yScale;
  const phaseOffset = inclinationPathGroup.userData.phaseOffset || 0;

  const CYCLE_LENGTH = holisticyearLength / 3;
  let progress = ((o.currentYear - balancedYear) % CYCLE_LENGTH) / CYCLE_LENGTH;
  if (progress < 0) progress += 1;

  // Apply same angle calculation as the path (negated for counterclockwise motion)
  const angle = -(progress * Math.PI * 2) + phaseOffset;
  const deviation = o.earthInvPlaneInclinationDynamic - earthInvPlaneInclinationMean;

  // Higher inclination = higher Y (positive deviation = above mean line)
  const x = Math.cos(angle) * radius;
  const y = deviation * yScale;
  const z = Math.sin(angle) * radius;

  // Set position BEFORE showing marker (prevents flash at wrong position)
  marker.position.set(x, y, z);

  // Now show marker if it was hidden (label will be shown after text is set)
  if (needsImmediateUpdate) {
    marker.visible = true;
  }

  // Calculate direction of motion (tangent to path, pointing counterclockwise)
  // Derivative of position with respect to angle (negated because angle decreases with time)
  // dx/dangle = -sin(angle) * radius, dz/dangle = cos(angle) * radius
  // But since angle = -progress*2π, motion is in direction of increasing angle visually
  // The tangent pointing in direction of motion (counterclockwise):
  const tangentX = Math.sin(angle) * radius;  // -d(cos)/dangle = sin
  const tangentZ = -Math.cos(angle) * radius; // d(sin)/dangle = cos, negated for CCW

  // Also include Y component based on rate of change of inclination
  // At progress p, inclination uses cos, so derivative is sin (positive when rising)
  const progressNext = progress + 0.001;
  const angleNext = -(progressNext * Math.PI * 2) + phaseOffset;
  const yearNext = balancedYear + progressNext * CYCLE_LENGTH;
  const inclNext = computeInclinationEarth(yearNext, balancedYear, holisticyearLength, earthInvPlaneInclinationMean, earthInvPlaneInclinationAmplitude);
  const deviationNext = inclNext - earthInvPlaneInclinationMean;
  const tangentY = (deviationNext - deviation) * yScale * 1000; // Scale for visibility

  _inclinationArrowDir.set(tangentX, tangentY, tangentZ).normalize();
  arrowHelper.setDirection(_inclinationArrowDir);

  // Update inclination label with current value
  labelDiv.textContent = o.earthInvPlaneInclinationDynamic.toFixed(3) + '°';

  // Show label after all updates are complete (if this was a fresh show)
  // This happens after position, arrow direction, and text are all set
  if (needsImmediateUpdate) {
    labelObject.visible = true; // Use CSS2DObject.visible (patched renderer checks this)
  }
}

// Update invariable plane visualization - MOVES PLANE THROUGH EARTH
//
// VISUAL BEHAVIOR (Dec 2024):
// The invariable plane moves up/down based on Earth's annual position, so you
// physically see the plane passing through Earth twice per year:
// - Early July: Plane moves DOWN through Earth (Earth ascending, going above)
// - Early January: Plane moves UP through Earth (Earth descending, going below)
//
// When Earth is ABOVE the invariable plane, the plane appears BELOW Earth.
// When Earth is BELOW the invariable plane, the plane appears ABOVE Earth.
//
// This annual crossing cycle (1 year) is independent of the holisticyearLength/3
// orbital plane tilt cycle shown by the inclination path visualization.
// Debug flag for invariable plane comparison
let _lastInvPlaneDebugTime = 0;
let _invPlaneDebugEnabled = false; // Set to true to enable debug logging

// Cached objects to prevent garbage collection (reused every frame)
const _invPlane_tiltAxis = new THREE.Vector3();
const _invPlane_quaternion = new THREE.Quaternion();
const _invPlane_localPos = new THREE.Vector3();
const _invPlane_tubeDir = new THREE.Vector3();
const _invPlane_tubeQuat = new THREE.Quaternion();
const _invPlane_yAxis = new THREE.Vector3(0, 1, 0);

function updateInvariablePlanePosition() {
  if (!invariablePlaneGroup || !invariablePlaneGroup.visible) return;

  // Update plane orientation to match dynamic ascending node (same as Sun-centered plane)
  // Apply quaternion directly to invariablePlaneGroup (same structure as Sun-centered)
  const earthI = (o.earthInvPlaneInclinationDynamic || earthInvPlaneInclinationMean) * Math.PI / 180;
  const earthOmega = (o.earthAscendingNodeInvPlane || earthAscendingNodeInvPlaneVerified) * Math.PI / 180;

  // Calculate tilt axis (line of nodes - points toward ascending node)
  const tiltAxisX = Math.cos(earthOmega);
  const tiltAxisZ = Math.sin(earthOmega);
  _invPlane_tiltAxis.set(tiltAxisX, 0, tiltAxisZ).normalize();

  // Create quaternion to rotate around the tilt axis (reuse cached quaternion)
  _invPlane_quaternion.setFromAxisAngle(_invPlane_tiltAxis, earthI);
  invariablePlaneGroup.quaternion.copy(_invPlane_quaternion);

  // DEBUG: Log values every 2 seconds
  const now = Date.now();
  if (_invPlaneDebugEnabled && (now - _lastInvPlaneDebugTime > 2000)) {
    console.log('%c═══════════════════════════════════════════════════════════', 'color: magenta');
    console.log('%cEARTH-CENTERED INVARIABLE PLANE:', 'color: magenta; font-weight: bold');
    console.log('  earthI (deg):', (earthI * 180 / Math.PI).toFixed(6));
    console.log('  earthOmega (deg):', (earthOmega * 180 / Math.PI).toFixed(6));
    console.log('  tiltAxis:', tiltAxisX.toFixed(6), 0, tiltAxisZ.toFixed(6));
    console.log('  quaternion (calculated):', _invPlane_quaternion.x.toFixed(6), _invPlane_quaternion.y.toFixed(6), _invPlane_quaternion.z.toFixed(6), _invPlane_quaternion.w.toFixed(6));
    console.log('  invariablePlaneGroup.quaternion:', invariablePlaneGroup.quaternion.x.toFixed(6), invariablePlaneGroup.quaternion.y.toFixed(6), invariablePlaneGroup.quaternion.z.toFixed(6), invariablePlaneGroup.quaternion.w.toFixed(6));
    console.log('  invariablePlaneGroup.position:', invariablePlaneGroup.position.x.toFixed(2), invariablePlaneGroup.position.y.toFixed(2), invariablePlaneGroup.position.z.toFixed(2));
    console.log('  parent:', invariablePlaneGroup.parent?.name || invariablePlaneGroup.parent?.type || 'unknown');
    // Don't update timer here - let Sun-centered update it so both log together
  }

  // ===== UPDATE FIXED MARKERS AND TUBES (HIGH/LOW/MEAN) =====
  // These are in a SEPARATE group (markersGroup) that doesn't rotate with the plane
  // Position is calculated by applying the plane's quaternion manually (like Sun-centered max incl marker)
  const markersGroup = invariablePlaneGroup.userData.markersGroup;
  if (markersGroup) {
    const markerDist = invariablePlaneGroup.userData.markerDist;
    const highAngle = invariablePlaneGroup.userData.highAngle;
    const lowAngle = invariablePlaneGroup.userData.lowAngle;
    const mean1Angle = invariablePlaneGroup.userData.mean1Angle;
    const mean2Angle = invariablePlaneGroup.userData.mean2Angle;

    // HIGH marker - calculate local position then apply quaternion (reuse cached vector)
    _invPlane_localPos.set(Math.cos(highAngle) * markerDist, 0, Math.sin(highAngle) * markerDist);
    _invPlane_localPos.applyQuaternion(_invPlane_quaternion);
    invariablePlaneGroup.userData.highMarker.position.copy(_invPlane_localPos);

    // LOW marker
    _invPlane_localPos.set(Math.cos(lowAngle) * markerDist, 0, Math.sin(lowAngle) * markerDist);
    _invPlane_localPos.applyQuaternion(_invPlane_quaternion);
    invariablePlaneGroup.userData.lowMarker.position.copy(_invPlane_localPos);

    // MEAN marker 1 (90° after HIGH)
    _invPlane_localPos.set(Math.cos(mean1Angle) * markerDist, 0, Math.sin(mean1Angle) * markerDist);
    _invPlane_localPos.applyQuaternion(_invPlane_quaternion);
    invariablePlaneGroup.userData.meanMarker1.position.copy(_invPlane_localPos);

    // MEAN marker 2 (90° before HIGH)
    _invPlane_localPos.set(Math.cos(mean2Angle) * markerDist, 0, Math.sin(mean2Angle) * markerDist);
    _invPlane_localPos.applyQuaternion(_invPlane_quaternion);
    invariablePlaneGroup.userData.meanMarker2.position.copy(_invPlane_localPos);

    // HIGH-LOW tube - oriented along the HIGH-LOW axis on the tilted plane
    const highLowTube = invariablePlaneGroup.userData.highLowTube;
    if (highLowTube) {
      // Tube direction in local space (points from LOW to HIGH)
      _invPlane_tubeDir.set(Math.cos(highAngle), 0, Math.sin(highAngle));
      _invPlane_tubeDir.applyQuaternion(_invPlane_quaternion);
      // Create quaternion that rotates Y-axis to tube direction
      _invPlane_tubeQuat.setFromUnitVectors(_invPlane_yAxis, _invPlane_tubeDir);
      highLowTube.quaternion.copy(_invPlane_tubeQuat);
      // Position at center (origin) - tube extends equally in both directions
      highLowTube.position.set(0, 0, 0);
    }

    // MEAN tube - oriented perpendicular to HIGH-LOW axis
    const meanTube = invariablePlaneGroup.userData.meanTube;
    if (meanTube) {
      // Mean tube direction in local space (perpendicular to HIGH-LOW)
      _invPlane_tubeDir.set(Math.cos(mean1Angle), 0, Math.sin(mean1Angle));
      _invPlane_tubeDir.applyQuaternion(_invPlane_quaternion);
      _invPlane_tubeQuat.setFromUnitVectors(_invPlane_yAxis, _invPlane_tubeDir);
      meanTube.quaternion.copy(_invPlane_tubeQuat);
      meanTube.position.set(0, 0, 0);
    }
  }

  // Get Earth's current height above the invariable plane (in AU)
  const heightAU = o.earthHeightAboveInvPlane || 0;
  const isAbove = o.earthAboveInvPlane;

  // Scale factor: convert AU to visual units
  // In this model, 1 AU = 100 visual units (sun.orbitRadius = 100)
  // Earth's max excursion is about ±0.027 AU = ±2.7 visual units
  const heightScale = 100; // Physically accurate: 1 AU = 100 units
  const visualHeight = heightAU * heightScale;

  // Move the plane OPPOSITE to Earth's height
  // If Earth is +0.02 AU above the plane, move plane DOWN by visualHeight
  // This makes the plane appear to pass through Earth as the year progresses
  invariablePlaneGroup.position.y = -visualHeight;

  // Sync markersGroup Y position with the plane (markers are in separate group but should move together)
  if (markersGroup) {
    markersGroup.position.y = -visualHeight;
  }

  // Update the Earth height indicator (line + label)
  const heightLine = invariablePlaneGroup.userData.earthHeightLine;
  const heightLabel = invariablePlaneGroup.userData.earthHeightLabelObj;
  const heightLabelDiv = invariablePlaneGroup.userData.earthHeightLabelDiv;

  if (!heightLine || !heightLabel) return;

  // The line goes from the plane (now at local Y=0) up to Earth (at visualHeight in world space)
  // But since the plane moved, Earth is at local position (0, visualHeight, 0) relative to plane
  const positions = heightLine.geometry.attributes.position.array;
  positions[0] = 0;  // Start X (on plane)
  positions[1] = 0;  // Start Y (on plane, which is at Y=0 in local space)
  positions[2] = 0;  // Start Z
  positions[3] = 0;  // End X (at Earth)
  positions[4] = visualHeight;  // End Y (Earth's position relative to plane)
  positions[5] = 0;  // End Z
  heightLine.geometry.attributes.position.needsUpdate = true;

  // Recompute line distances for dashed material to work correctly
  heightLine.computeLineDistances();
  heightLine.geometry.attributes.lineDistance.needsUpdate = true;

  // Update line color based on above/below
  heightLine.material.color.set(isAbove ? 0x44ff44 : 0xff4444); // Green above, red below

  // Update label position (near Earth, which is at visualHeight relative to plane)
  heightLabel.position.set(0, visualHeight + (isAbove ? 20 : -20), 0);
  const statusText = isAbove ? 'ABOVE' : 'BELOW';
  const heightText = Math.abs(heightAU).toFixed(6);
  heightLabelDiv.innerHTML = `<span style="font-size:14px;font-weight:bold;">EARTH</span><br>${heightText} AU<br><span style="font-size:12px;">${statusText}</span>`;
  heightLabelDiv.style.color = isAbove ? '#44ff44' : '#ff4444';

  // Update the Earth plane marker position (stays at plane level, Y=0 in local space)
  const earthPlaneMarker = invariablePlaneGroup.userData.earthPlaneMarker;
  if (earthPlaneMarker) {
    earthPlaneMarker.position.y = 0; // Always on the plane
  }
}

// Create invariable plane (tilted grid/disc)
// Add to SCENE (not earth.pivotObj) so orientation is in world coordinates
// This matches the Sun-centered invariable plane and avoids inheriting Earth's pivot transform
const invariablePlaneGroup = createInvariablePlaneVisualization(o.starDistance * 2, 30);
scene.add(invariablePlaneGroup);
invariablePlaneGroup.visible = false; // Off by default (labels also hidden by default)

// Add the markers group to the scene (separate from tilted plane group)
// Markers are positioned in world space using quaternion transform (like Sun-centered max incl marker)
const invPlaneMarkersGroup = invariablePlaneGroup.userData.markersGroup;
if (invPlaneMarkersGroup) {
  scene.add(invPlaneMarkersGroup);
  invPlaneMarkersGroup.visible = false; // Sync visibility with main plane
}

//*************************************************************
// SUN-CENTERED INVARIABLE PLANE (works for all planets)
//*************************************************************

// Planet data lookup for invariable plane visualization
// orbitRadiusAU is the semi-major axis used for fixed node marker positioning
// ascNode: ICRF-rate value (holisticyearLength/3) for marker POSITIONING (physical position in space)
// ascNodeEcliptic: Ecliptic-rate value (holisticyearLength/16) for marker LABELS (what user sees when planet crosses)
const PLANET_INV_PLANE_DATA = {
  earth:   { obj: earth,   key: 'earth',   inclination: () => o.earthInvPlaneInclinationDynamic,   ascNode: () => o.earthAscendingNodeInvPlane,   ascNodeEcliptic: () => o.earthAscendingNodeInvPlaneEcliptic,   height: () => o.earthHeightAboveInvPlane,   orbitRadiusAU: 1.0 },
  mercury: { obj: mercury, key: 'mercury', inclination: () => o.mercuryInvPlaneInclinationDynamic, ascNode: () => o.mercuryAscendingNodeInvPlane, ascNodeEcliptic: () => o.mercuryAscendingNodeInvPlaneEcliptic, height: () => o.mercuryHeightAboveInvPlane, orbitRadiusAU: mercuryOrbitDistance },
  venus:   { obj: venus,   key: 'venus',   inclination: () => o.venusInvPlaneInclinationDynamic,   ascNode: () => o.venusAscendingNodeInvPlane,   ascNodeEcliptic: () => o.venusAscendingNodeInvPlaneEcliptic,   height: () => o.venusHeightAboveInvPlane,   orbitRadiusAU: venusOrbitDistance },
  mars:    { obj: mars,    key: 'mars',    inclination: () => o.marsInvPlaneInclinationDynamic,    ascNode: () => o.marsAscendingNodeInvPlane,    ascNodeEcliptic: () => o.marsAscendingNodeInvPlaneEcliptic,    height: () => o.marsHeightAboveInvPlane,    orbitRadiusAU: marsOrbitDistance },
  jupiter: { obj: jupiter, key: 'jupiter', inclination: () => o.jupiterInvPlaneInclinationDynamic, ascNode: () => o.jupiterAscendingNodeInvPlane, ascNodeEcliptic: () => o.jupiterAscendingNodeInvPlaneEcliptic, height: () => o.jupiterHeightAboveInvPlane, orbitRadiusAU: jupiterOrbitDistance },
  saturn:  { obj: saturn,  key: 'saturn',  inclination: () => o.saturnInvPlaneInclinationDynamic,  ascNode: () => o.saturnAscendingNodeInvPlane,  ascNodeEcliptic: () => o.saturnAscendingNodeInvPlaneEcliptic,  height: () => o.saturnHeightAboveInvPlane,  orbitRadiusAU: saturnOrbitDistance },
  uranus:  { obj: uranus,  key: 'uranus',  inclination: () => o.uranusInvPlaneInclinationDynamic,  ascNode: () => o.uranusAscendingNodeInvPlane,  ascNodeEcliptic: () => o.uranusAscendingNodeInvPlaneEcliptic,  height: () => o.uranusHeightAboveInvPlane,  orbitRadiusAU: uranusOrbitDistance },
  neptune: { obj: neptune, key: 'neptune', inclination: () => o.neptuneInvPlaneInclinationDynamic, ascNode: () => o.neptuneAscendingNodeInvPlane, ascNodeEcliptic: () => o.neptuneAscendingNodeInvPlaneEcliptic, height: () => o.neptuneHeightAboveInvPlane, orbitRadiusAU: neptuneOrbitDistance },
};

// Reusable vectors to avoid allocation each frame
const _sunCenteredPlane_sunPos = new THREE.Vector3();
const _sunCenteredPlane_planetPos = new THREE.Vector3();
const _sunCenteredPlane_tiltAxis = new THREE.Vector3();
const _sunCenteredPlane_planeNormal = new THREE.Vector3();
const _sunCenteredPlane_planetRelToSun = new THREE.Vector3();
const _sunCenteredPlane_ascLocalPos = new THREE.Vector3();
const _sunCenteredPlane_descLocalPos = new THREE.Vector3();
const _sunCenteredPlane_maxInclLocalPos = new THREE.Vector3();
const _sunCenteredPlane_orbitCenter = new THREE.Vector3();
const _sunCenteredPlane_quaternion = new THREE.Quaternion();

/**
 * Create Sun-centered invariable plane visualization
 * This plane is fixed in space (relative to stars) and shows where planets cross it.
 */
function createSunCenteredInvPlane(size = 500, divisions = 20) {
  const group = new THREE.Group();
  group.name = 'SunCenteredInvariablePlane';

  // The invariable plane orientation relative to the ecliptic is defined by:
  // - Inclination: o.earthInvPlaneInclinationDynamic (Earth's inclination TO the invariable plane)
  // - Ascending node: o.earthAscendingNodeInvPlane + 180° (invariable plane's ascending node ON ecliptic)
  // We'll set orientation in the update function since o.earthInvPlaneInclinationDynamic is dynamic

  // Grid helper (will be tilted in update function)
  const gridHelper = new THREE.GridHelper(size, divisions, 0xaa44aa, 0x663366);
  gridHelper.material.opacity = 0.3;
  gridHelper.material.transparent = true;
  group.add(gridHelper);

  // Solid disc for better visibility
  const discGeometry = new THREE.CircleGeometry(size / 2, 48);
  const discMaterial = new THREE.MeshBasicMaterial({
    color: 0x8844aa,
    transparent: true,
    opacity: 0.12,
    side: THREE.DoubleSide
  });
  const disc = new THREE.Mesh(discGeometry, discMaterial);
  disc.rotation.x = -Math.PI / 2; // Lay flat initially
  group.add(disc);

  // Edge ring
  const ringGeometry = new THREE.RingGeometry(size/2 - 3, size/2, 64);
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0xff44ff,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide
  });
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.rotation.x = -Math.PI / 2;
  group.add(ring);

  // Store references for orientation updates
  group.userData.gridHelper = gridHelper;
  group.userData.disc = disc;
  group.userData.ring = ring;

  return group;
}

/**
 * Create node markers for a planet's orbit crossing the invariable plane
 */
function createPlanetNodeMarkersGroup() {
  const group = new THREE.Group();
  group.name = 'PlanetNodeMarkers';
  group.visible = false; // Hidden by default

  // Ascending node marker (green ☊)
  const ascMarkerGeom = new THREE.SphereGeometry(4, 12, 12);
  const ascMarkerMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
  const ascMarker = new THREE.Mesh(ascMarkerGeom, ascMarkerMat);
  ascMarker.name = 'AscendingNodeMarker';
  group.add(ascMarker);

  // Ascending node label - ADD TO MARKER so it follows automatically
  const ascLabelDiv = document.createElement('div');
  ascLabelDiv.innerHTML = '<span style="font-size:18px;">☊</span><br><span style="font-size:11px;">ASC</span>';
  ascLabelDiv.style.color = '#00ff88';
  ascLabelDiv.style.fontSize = '12px';
  ascLabelDiv.style.fontFamily = 'Arial, sans-serif';
  ascLabelDiv.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  ascLabelDiv.style.pointerEvents = 'none';
  ascLabelDiv.style.textAlign = 'center';
  const ascLabelObj = new CSS2DObject(ascLabelDiv);
  ascLabelObj.position.set(0, 15, 0); // Offset above marker in local coords
  ascLabelObj.visible = false;
  ascMarker.add(ascLabelObj); // Add to marker, not group

  // Descending node marker (orange ☋)
  const descMarkerGeom = new THREE.SphereGeometry(4, 12, 12);
  const descMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });
  const descMarker = new THREE.Mesh(descMarkerGeom, descMarkerMat);
  descMarker.name = 'DescendingNodeMarker';
  group.add(descMarker);

  // Descending node label - ADD TO MARKER so it follows automatically
  const descLabelDiv = document.createElement('div');
  descLabelDiv.innerHTML = '<span style="font-size:18px;">☋</span><br><span style="font-size:11px;">DESC</span>';
  descLabelDiv.style.color = '#ff8800';
  descLabelDiv.style.fontSize = '12px';
  descLabelDiv.style.fontFamily = 'Arial, sans-serif';
  descLabelDiv.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  descLabelDiv.style.pointerEvents = 'none';
  descLabelDiv.style.textAlign = 'center';
  const descLabelObj = new CSS2DObject(descLabelDiv);
  descLabelObj.position.set(0, 15, 0); // Offset above marker in local coords
  descLabelObj.visible = false;
  descMarker.add(descLabelObj); // Add to marker, not group

  // Max Inclination marker (yellow ▲) - FIXED position where inclination reaches maximum
  // This is the phaseOffset constant - it doesn't move as the ascending node precesses
  const maxInclMarkerGeom = new THREE.SphereGeometry(4, 12, 12);
  const maxInclMarkerMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const maxInclMarker = new THREE.Mesh(maxInclMarkerGeom, maxInclMarkerMat);
  maxInclMarker.name = 'MaxInclinationMarker';
  group.add(maxInclMarker);

  // Max Inclination label - ADD TO MARKER so it follows automatically
  const maxInclLabelDiv = document.createElement('div');
  maxInclLabelDiv.innerHTML = '<span style="font-size:14px;">▲</span><br><span style="font-size:10px;">MAX i</span>';
  maxInclLabelDiv.style.color = '#ffff00';
  maxInclLabelDiv.style.fontSize = '12px';
  maxInclLabelDiv.style.fontFamily = 'Arial, sans-serif';
  maxInclLabelDiv.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  maxInclLabelDiv.style.pointerEvents = 'none';
  maxInclLabelDiv.style.textAlign = 'center';
  const maxInclLabelObj = new CSS2DObject(maxInclLabelDiv);
  maxInclLabelObj.position.set(0, 15, 0); // Offset above marker in local coords
  maxInclLabelObj.visible = false;
  maxInclMarker.add(maxInclLabelObj); // Add to marker, not group

  // Store references
  group.userData.ascMarker = ascMarker;
  group.userData.ascLabel = ascLabelObj;
  group.userData.ascLabelDiv = ascLabelDiv;
  group.userData.descMarker = descMarker;
  group.userData.descLabel = descLabelObj;
  group.userData.descLabelDiv = descLabelDiv;
  group.userData.maxInclMarker = maxInclMarker;
  group.userData.maxInclLabel = maxInclLabelObj;
  group.userData.maxInclLabelDiv = maxInclLabelDiv;

  return group;
}

/**
 * Create height indicator label (shows planet's current height above/below plane)
 * This is added to the SCENE directly (not to the plane group) to avoid transform issues
 */
function createHeightIndicatorLabel() {
  const labelDiv = document.createElement('div');
  labelDiv.innerHTML = '<span style="font-size:14px;font-weight:bold;">PLANET</span><br>0.000000 AU<br><span style="font-size:12px;">ABOVE</span>';
  labelDiv.style.color = '#44ff44';
  labelDiv.style.fontSize = '12px';
  labelDiv.style.fontFamily = 'Arial, sans-serif';
  labelDiv.style.textShadow = '2px 2px 4px black, -1px -1px 2px black';
  labelDiv.style.pointerEvents = 'none';
  labelDiv.style.textAlign = 'center';
  labelDiv.style.lineHeight = '1.2';
  labelDiv.style.background = 'rgba(0, 0, 0, 0.6)';
  labelDiv.style.padding = '4px 8px';
  labelDiv.style.borderRadius = '4px';

  const labelObj = new CSS2DObject(labelDiv);
  labelObj.name = 'SunCenteredHeightLabel';
  labelObj.visible = false;

  return { labelObj, labelDiv };
}

// Create the Sun-centered invariable plane
const sunCenteredInvPlane = createSunCenteredInvPlane(o.starDistance * 2, 30);
scene.add(sunCenteredInvPlane); // Add to scene, NOT to any pivot
sunCenteredInvPlane.visible = false;

// Create node markers - added to SCENE (not plane) so they stay fixed relative to stars
const sunCenteredNodeMarkers = createPlanetNodeMarkersGroup();
scene.add(sunCenteredNodeMarkers); // Add to scene, NOT to plane group
sunCenteredNodeMarkers.visible = false;

// Create height indicator label (added to scene directly to avoid transform issues)
const { labelObj: sunCenteredHeightLabel, labelDiv: sunCenteredHeightLabelDiv } = createHeightIndicatorLabel();
scene.add(sunCenteredHeightLabel);

/**
 * Update the Sun-centered invariable plane position and orientation.
 * Should be called each frame when the plane is visible.
 */
function updateSunCenteredInvPlane() {
  if (!sunCenteredInvPlane.visible) {
    sunCenteredHeightLabel.visible = false;
    return;
  }

  // Safety check - ensure sun object exists
  if (!sun?.pivotObj) return;

  // Get Sun's world position
  sun.pivotObj.getWorldPosition(_sunCenteredPlane_sunPos);

  // Center the plane at the Sun's position
  // The invariable plane passes through the solar system barycenter (inside the Sun)
  // By centering at the Sun, the plane will be at the correct position relative to planetary orbits
  // The plane's ORIENTATION is fixed relative to stars (set by quaternion below)
  // Only the POSITION follows the Sun - this is correct because in geocentric view,
  // the Sun's position represents "where the center of the solar system is" from Earth's perspective
  sunCenteredInvPlane.position.copy(_sunCenteredPlane_sunPos);

  // Calculate plane orientation from Earth's relationship to the invariable plane
  //
  // Geometry:
  // - The ecliptic (Earth's orbital plane) is the X-Z plane in this model
  // - The invariable plane is tilted by o.earthInvPlaneInclinationDynamic (~1.57°) relative to ecliptic
  // - Earth's ascending node (o.earthAscendingNodeInvPlane) is where Earth crosses UP through the inv. plane
  // - The HIGH point (max height above plane) is 90° AFTER the ascending node
  // - The LOW point (max depth below plane) is 90° AFTER the descending node (= 270° after asc node)
  //
  // The invariable plane's tilt axis is the LINE OF NODES (the intersection of ecliptic and inv. plane)
  // This line points toward the ascending node longitude.
  //
  // The plane should be tilted DOWN on the side 90° after ascending node (where HIGH point is)
  // and UP on the side 90° before ascending node (where LOW point is)

  const earthI = (o.earthInvPlaneInclinationDynamic || earthInvPlaneInclinationMean) * Math.PI / 180;
  const earthOmega = (o.earthAscendingNodeInvPlane || earthAscendingNodeInvPlaneVerified) * Math.PI / 180;

  // The tilt axis is along the line of nodes, pointing toward ascending node
  // In X-Z plane (ecliptic), ascending node at angle Omega from +X axis
  // We need to rotate the ecliptic (Y=0 plane) around this axis by earthI degrees
  //
  // The axis of rotation is the line of nodes: direction (cos(Omega), 0, sin(Omega))
  // But we need to tilt the plane such that the HIGH side (90° after asc node) goes DOWN
  //
  // After the ascending node, Earth goes ABOVE the plane, meaning the plane is BELOW Earth there
  // So we tilt the plane DOWN on the +90° side of the ascending node

  // Tilt axis: perpendicular to the direction from Sun to HIGH point
  // HIGH point is at angle (Omega + 90°), so tilt axis is at angle Omega (toward ascending node)
  const tiltAxisX = Math.cos(earthOmega);
  const tiltAxisZ = Math.sin(earthOmega);
  _sunCenteredPlane_tiltAxis.set(tiltAxisX, 0, tiltAxisZ).normalize();

  // Create quaternion to rotate around the tilt axis by earthI
  // Positive rotation tilts the +90° side DOWN (which is correct - that's where Earth is highest ABOVE)
  _sunCenteredPlane_quaternion.setFromAxisAngle(_sunCenteredPlane_tiltAxis, earthI);
  sunCenteredInvPlane.quaternion.copy(_sunCenteredPlane_quaternion);

  // DEBUG: Log values every 2 seconds (uses same timer as Earth-centered)
  const now = Date.now();
  if (_invPlaneDebugEnabled && (now - _lastInvPlaneDebugTime > 2000)) {
    console.log('%c───────────────────────────────────────────────────────────', 'color: cyan');
    console.log('%cSUN-CENTERED INVARIABLE PLANE:', 'color: cyan; font-weight: bold');
    console.log('  earthI (deg):', (earthI * 180 / Math.PI).toFixed(6));
    console.log('  earthOmega (deg):', (earthOmega * 180 / Math.PI).toFixed(6));
    console.log('  tiltAxis:', tiltAxisX.toFixed(6), 0, tiltAxisZ.toFixed(6));
    console.log('  quaternion (calculated):', _sunCenteredPlane_quaternion.x.toFixed(6), _sunCenteredPlane_quaternion.y.toFixed(6), _sunCenteredPlane_quaternion.z.toFixed(6), _sunCenteredPlane_quaternion.w.toFixed(6));
    console.log('  sunCenteredInvPlane.quaternion:', sunCenteredInvPlane.quaternion.x.toFixed(6), sunCenteredInvPlane.quaternion.y.toFixed(6), sunCenteredInvPlane.quaternion.z.toFixed(6), sunCenteredInvPlane.quaternion.w.toFixed(6));
    console.log('  sunCenteredInvPlane.position:', sunCenteredInvPlane.position.x.toFixed(2), sunCenteredInvPlane.position.y.toFixed(2), sunCenteredInvPlane.position.z.toFixed(2));
    console.log('  parent:', sunCenteredInvPlane.parent?.name || sunCenteredInvPlane.parent?.type || 'unknown');
    _lastInvPlaneDebugTime = now; // Update timer here for Sun-centered
  }

  // Get the currently selected planet
  const currentPlanetName = o.lookAtObj?.name?.toLowerCase();
  const planetData = PLANET_INV_PLANE_DATA[currentPlanetName];

  if (!planetData) {
    // No valid planet selected - hide markers
    sunCenteredNodeMarkers.visible = false;
    sunCenteredHeightLabel.visible = false;
    setCSS2DVisibility(sunCenteredNodeMarkers, false);
    return;
  }

  // Get planet's orbit data
  const planetObj = planetData.obj;
  const inclinationDeg = typeof planetData.inclination === 'function' ? planetData.inclination() : planetData.inclination;
  const ascNodeDeg = planetData.ascNode();  // ICRF value for marker positioning
  const ascNodeEclipticDeg = planetData.ascNodeEcliptic();  // Ecliptic value for labels
  const heightAU = planetData.height() || 0;

  // Get planet's world position
  planetObj.pivotObj.getWorldPosition(_sunCenteredPlane_planetPos);

  // GEOCENTRIC CORRECTION:
  // In this model, Earth stays near origin while Sun orbits around it.
  // We need to adjust the plane's Y position so that at the SELECTED PLANET's location,
  // the visual height matches that planet's calculated height above the invariable plane.
  //
  // The plane is tilted and passes through the Sun. At the planet's X,Z position,
  // the plane would be at some Y value. We want the planet to appear at the correct
  // height above/below the plane.
  //
  // Calculate where the plane currently is at the planet's location, then offset
  // the entire plane so the planet appears at the correct height.
  _sunCenteredPlane_planetRelToSun.copy(_sunCenteredPlane_planetPos).sub(_sunCenteredPlane_sunPos);
  _sunCenteredPlane_planeNormal.set(0, 1, 0).applyQuaternion(_sunCenteredPlane_quaternion);

  // Current plane Y at planet's X,Z (before correction)
  const dx = _sunCenteredPlane_planetRelToSun.x;
  const dz = _sunCenteredPlane_planetRelToSun.z;
  const currentPlaneYAtPlanet = _sunCenteredPlane_sunPos.y - (_sunCenteredPlane_planeNormal.x * dx + _sunCenteredPlane_planeNormal.z * dz) / _sunCenteredPlane_planeNormal.y;

  // Planet's actual Y and desired height above plane
  const planetY = _sunCenteredPlane_planetPos.y;
  const desiredHeightUnits = (heightAU || 0) * 100; // Convert AU to visual units

  // The plane should be at: planetY - desiredHeightUnits
  // Currently it's at: currentPlaneYAtPlanet
  // So we need to shift the plane's position by the difference
  const planeYCorrection = (planetY - desiredHeightUnits) - currentPlaneYAtPlanet;
  sunCenteredInvPlane.position.y += planeYCorrection;

  // Use fixed semi-major axis for node marker positioning (in visual units: 1 AU = 100 units)
  const orbitRadius = planetData.orbitRadiusAU * 100;

  // Show node markers
  sunCenteredNodeMarkers.visible = true;
  setCSS2DVisibility(sunCenteredNodeMarkers, true);

  // Position node markers on the orbit at the ascending/descending node angles
  // The ascending node is where the planet crosses the invariable plane going "up"
  // Negate the angle because astronomical longitude increases CCW but we need CW rotation
  const ascNodeRad = -ascNodeDeg * Math.PI / 180;

  const ascMarker = sunCenteredNodeMarkers.userData.ascMarker;
  const ascLabel = sunCenteredNodeMarkers.userData.ascLabel;
  const descMarker = sunCenteredNodeMarkers.userData.descMarker;
  const descLabel = sunCenteredNodeMarkers.userData.descLabel;

  // Calculate position in plane-local coordinates (on the plane, Y=0)
  // These are positions relative to the orbit center
  const ascLocalX = Math.cos(ascNodeRad) * orbitRadius;
  const ascLocalZ = Math.sin(ascNodeRad) * orbitRadius;

  // Transform from plane-local to world coordinates:
  // 1. Create local position vector (relative to orbit center)
  // 2. Apply plane's quaternion to rotate into world orientation
  // 3. Add orbit center position to get world coordinates
  _sunCenteredPlane_ascLocalPos.set(ascLocalX, 0, ascLocalZ);
  _sunCenteredPlane_descLocalPos.set(-ascLocalX, 0, -ascLocalZ);

  // Apply plane's quaternion to transform to world orientation
  // (The plane's quaternion represents the tilt of the invariable plane)
  _sunCenteredPlane_ascLocalPos.applyQuaternion(sunCenteredInvPlane.quaternion);
  _sunCenteredPlane_descLocalPos.applyQuaternion(sunCenteredInvPlane.quaternion);

  // Determine the orbit center for node marker positioning:
  // - For Earth: In the geocentric model, Earth stays near origin while Sun orbits Earth.
  //   Earth's orbit is centered near the origin, not around the Sun.
  // - For other planets: They orbit around the Sun, so use Sun's position.
  const isEarth = currentPlanetName === 'earth';
  if (isEarth) {
    _sunCenteredPlane_orbitCenter.set(0, 0, 0);
  } else {
    _sunCenteredPlane_orbitCenter.copy(_sunCenteredPlane_sunPos);
  }

  // Add orbit center position to get world coordinates
  _sunCenteredPlane_ascLocalPos.add(_sunCenteredPlane_orbitCenter);
  _sunCenteredPlane_descLocalPos.add(_sunCenteredPlane_orbitCenter);

  // Position markers (they're scene children, so world coords)
  // Labels are children of markers, so they follow automatically
  ascMarker.position.copy(_sunCenteredPlane_ascLocalPos);
  descMarker.position.copy(_sunCenteredPlane_descLocalPos);

  // Update node labels
  const ascLabelDiv = sunCenteredNodeMarkers.userData.ascLabelDiv;
  const descLabelDiv = sunCenteredNodeMarkers.userData.descLabelDiv;

  // Update ascending node label (show ICRF value - fixed position in space)
  ascLabelDiv.innerHTML = `<span style="font-size:18px;">☊</span><br><span style="font-size:11px;">ASC NODE</span><br><span style="font-size:10px;color:#88ddff;">Ω: ${ascNodeDeg.toFixed(1)}°</span>`;

  // Update descending node label (show ICRF value)
  const descNodeDeg = (ascNodeDeg + 180) % 360;
  descLabelDiv.innerHTML = `<span style="font-size:18px;">☋</span><br><span style="font-size:11px;">DESC NODE</span><br><span style="font-size:10px;color:#88ddff;">Ω: ${descNodeDeg.toFixed(1)}°</span>`;

  // Get the phase offset for this planet (Ω_J2000 - φ₀)
  const phaseOffsetLookup = {
    mercury: mercuryInclinationPhaseAngle,
    venus: venusInclinationPhaseAngle,
    mars: marsInclinationPhaseAngle,
    jupiter: jupiterInclinationPhaseAngle,
    saturn: saturnInclinationPhaseAngle,
    uranus: uranusInclinationPhaseAngle,
    neptune: neptuneInclinationPhaseAngle,
    pluto: plutoInclinationPhaseAngle,
    earth: earthInclinationPhaseAngle  // Ω=284.51°, φ₀=81.5° → 203.3195.0°
  };
  const phaseOffset = phaseOffsetLookup[planetData.key] ?? 0;

  // Get marker references
  const maxInclMarker = sunCenteredNodeMarkers.userData.maxInclMarker;
  const maxInclLabel = sunCenteredNodeMarkers.userData.maxInclLabel;
  const maxInclLabelDiv = sunCenteredNodeMarkers.userData.maxInclLabelDiv;

  if (phaseOffset !== 0) {
    // === MAX INCLINATION MARKER (FIXED) ===
    // Position at the fixed phaseOffset longitude - this is where inclination reaches maximum
    // This marker does NOT move as the ascending node precesses
    maxInclMarker.visible = true;
    maxInclLabel.visible = true;

    const maxInclRad = -phaseOffset * Math.PI / 180; // Negate for CW rotation like other markers
    const maxInclLocalX = Math.cos(maxInclRad) * orbitRadius;
    const maxInclLocalZ = Math.sin(maxInclRad) * orbitRadius;
    _sunCenteredPlane_maxInclLocalPos.set(maxInclLocalX, 0, maxInclLocalZ);

    // Apply plane's quaternion to transform to world orientation
    _sunCenteredPlane_maxInclLocalPos.applyQuaternion(sunCenteredInvPlane.quaternion);
    _sunCenteredPlane_maxInclLocalPos.add(_sunCenteredPlane_orbitCenter);
    maxInclMarker.position.copy(_sunCenteredPlane_maxInclLocalPos);

    // Update label with fixed ICRF phase offset value
    maxInclLabelDiv.innerHTML = `<span style="font-size:14px;">▲</span><br><span style="font-size:9px;">MAX i</span><br><span style="font-size:10px;color:#ffff88;">${phaseOffset.toFixed(0)}°</span>`;
  } else {
    // Hide marker for Earth or planets without phase offset data
    maxInclMarker.visible = false;
    maxInclLabel.visible = false;
  }

  // Update height indicator label
  sunCenteredHeightLabel.visible = true;

  // Position label at the planet's world position
  sunCenteredHeightLabel.position.copy(_sunCenteredPlane_planetPos);

  // Update label content
  const isAbove = heightAU > 0;
  const planetName = planetData.key.toUpperCase();
  const statusText = isAbove ? 'ABOVE' : 'BELOW';
  const heightText = Math.abs(heightAU).toFixed(6);
  sunCenteredHeightLabelDiv.innerHTML = `<span style="font-size:14px;font-weight:bold;">${planetName}</span><br>${heightText} AU<br><span style="font-size:12px;">${statusText}</span>`;
  sunCenteredHeightLabelDiv.style.color = isAbove ? '#44ff44' : '#ff4444';
}

/**
 * Helper to set visibility of all CSS2DObjects in a group
 * CSS2DRenderer doesn't inherit visibility from parent, so we must set each label explicitly
 */
function setCSS2DVisibility(group, visible) {
  group.traverse((child) => {
    if (child.isCSS2DObject) {
      child.visible = visible;
    }
  });
}

// Create inclination path (wobble curve showing holisticyearLength/3 cycle)
// Add to earth.pivotObj (same as zodiac) so it can be toggled independently
// The rotation is applied in moveModel() to match zodiac alignment
const inclinationPathGroup = createInclinationPath(250, 360, 50);
earth.pivotObj.add(inclinationPathGroup);
inclinationPathGroup.visible = false; // Off by default

//*************************************************************
// CREATE MILKYWAY SKYDOME
//*************************************************************
const skyGeo = new THREE.SphereGeometry(100000, 25, 25);
const loader = new THREE.TextureLoader();
const skyTexture = loadTexture("https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/milkyway.jpg");

// Set correct color space for color image textures
skyTexture.colorSpace = THREE.SRGBColorSpace; // This is the correct setting for normal color images
const skyMaterial = new THREE.MeshBasicMaterial({
  map: skyTexture,
  side: THREE.BackSide
});
const sky = new THREE.Mesh(skyGeo, skyMaterial);
scene.add(sky);

//*************************************************************
// ADD STARS, CONSTELLATIONS
//*************************************************************
const sceneObjects = {
  stars: new THREE.Object3D(),
  constellations: new THREE.Object3D(),
  // we can add other fixed obects over here later on. e.g.
  //blackholes: new THREE.Object3D(), 
};

// Add containers to the scene
scene.add(sceneObjects.stars);
scene.add(sceneObjects.constellations);
// we can add other fixed objects over here later on. e.g.
//scene.add(sceneObjects.blackholes);

// --- Create Starfield ---
createStarfield();
scene.updateMatrixWorld();
sceneObjects.stars.applyMatrix4(earth.rotationAxis.matrixWorld);
sceneObjects.stars.visible = true;

// --- Create Constellations ---
scene.updateMatrixWorld();
sceneObjects.constellations.applyMatrix4(earth.rotationAxis.matrixWorld);
sceneObjects.constellations.visible = false;

// --- Create Blackholes ---
//scene.updateMatrixWorld();
//sceneObjects.blackholes.applyMatrix4(earth.rotationAxis.matrixWorld);
//sceneObjects.blackholes.visible = false;

//*************************************************************
// Add the stars, star-lables and constellations
//*************************************************************
// 1) Asset URLs
const bsc5url           = 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/input/stars.json';
const constellationsUrl = 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/input/constellations.json';
const starGlowURL       = 'https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/lensflare2.png';

let starTexture;
let starSizeMaterial = null;
let starsMesh;

let needsLabelUpdate = true;
// 2) Whenever you know the labels need repositioning:
//    • On camera move:
controls.addEventListener('change', () => { needsLabelUpdate = true; });
//    • On zoom (if separate):
camera.addEventListener('zoom',   () => { needsLabelUpdate = true; });

// 3) One dashed‐line material for all constellations
const constellationMaterial = new THREE.LineDashedMaterial({
  color:       0x00aaff,
  linewidth:   1,
  scale:       1,
  dashSize:    2,
  gapSize:     1,
  transparent: true,
  opacity:     0.5,
});

// ——————————————————————————————————————————
// 1) Create a “draw-on” shader material prototype
// ——————————————————————————————————————————
const drawOnShaderProto = new THREE.ShaderMaterial({
  uniforms: {
    uDrawProgress: { value: 0.0 },
    uTotalLength:   { value: 1.0 },
    uColor:         { value: constellationMaterial.color.clone() }
  },
  vertexShader: `
    attribute float lineDistance;
    varying   float vLineDistance;
    void main() {
      vLineDistance = lineDistance;
      gl_Position   = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uDrawProgress;
    uniform float uTotalLength;                                // ← and here
    uniform vec3  uColor;
    varying float vLineDistance;
    void main() {
      // now we can safely compare against uTotalLength
      if ((vLineDistance / uTotalLength) > uDrawProgress) discard;
      gl_FragColor = vec4(uColor, 1.0);
    }
  `,
  transparent: true,
  depthWrite:  false
});

// Array to keep track of every material instance we create,
// so we can update their `uDrawProgress` in a single loop.
const drawMaterials = [];

// 4) Kick off constellation setup immediately
initConstellations();

// 5) Load star‐glow texture, then build stars
loadTexture(starGlowURL, tex => {
  starTexture = tex;
  starTexture.colorSpace = THREE.SRGBColorSpace;  // correct color space
  initStars();  // now that we have the texture, build the Points cloud
});

//*************************************************************
// Add a Visual Ring or Glow Around the Focused Planet
//*************************************************************
const focusRing = new THREE.Mesh(
  new THREE.RingGeometry(1.1, 1.2, 64),
  new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
);
focusRing.rotation.x = Math.PI / 2;
scene.add(focusRing);

//*************************************************************
// ADD GLOW EFFECT TO SUN
//*************************************************************
const sunTexture = loadTexture('https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/glow.png'); 

// Set correct color space for color image textures
sunTexture.colorSpace = THREE.SRGBColorSpace;

// Create the Sprite material
const sunGlowMaterial = new THREE.SpriteMaterial({
  map: sunTexture || null, // if no texture, just use color
  color: 0xffffaa, // soft yellowish white
  blending: THREE.AdditiveBlending,
  transparent: true,
  opacity: 0.05, // soft glow
  depthWrite: false, // important! otherwise sun glow could hide other objects
});

// Create the Sprite
const sunGlow = new THREE.Sprite(sunGlowMaterial);

// Set position and size
sunGlow.scale.set(500, 500, 10); // Size of glow in world units, adjust as needed

// Attach to Sun pivot
sun.pivotObj.add(sunGlow);

//*************************************************************
// ADD LENS FLARE EFFECT WHEN LOOKING AT TO SUN
//*************************************************************
const flareTexture = loadTexture('https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/lensflare.png'); 
// You can use any small round bright texture or generate a quick radial white glow.

// Set correct color space for color image textures
flareTexture.colorSpace = THREE.SRGBColorSpace;

// Create multiple flare elements
const flares = [
  createFlare(0xffffff, 30),   // Bright center flare
  createFlare(0xffcc88, 15),   // Warm flare
  createFlare(0x88aaff, 20),   // Cool flare
  createFlare(0xff8888, 8),    // Small red flare
  createFlare(0x88ff88, 12),   // Small greenish flare
];

//*************************************************************
// START SCENE
//*************************************************************
const clock = new THREE.Clock(); 

// --------------------------------------------------------
// initial setup — run ONCE, right after you create renderer,
// camera, starMaterial, labelRenderer, etc.
// --------------------------------------------------------
const DESIRED_HFOV   = 60;        // horizontal slice you like
const MIN_SIZE       = 2;         // protect against 0-px viewports
const starMaterial   = new THREE.PointsMaterial({ size: 2, sizeAttenuation: false });

let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);               // debounce
  resizeTimeout = setTimeout(onWindowResize, 100);
});
onWindowResize();                            // initial call

let pause = true;

planetObjects.forEach(obj => {
  showHideObject(obj)
});
showHideAxisHelpers();

// Create reusable geometries and materials
const bGeometry = new THREE.SphereGeometry( 1, 32, 16 );
const unlitMaterial = new THREE.MeshBasicMaterial({ color: 0x777777 });

o.lookAtObj = earth;
let currPos; 

let lastFrameTime = 0;
let smoothedFps   = 60;
let lastCameraX   = 0, lastCameraY = 0, lastCameraZ = 0;
let lowPerformanceMode = false;

// At the top of your file, create reusable vectors
const centerPosVec = new THREE.Vector3();
const starPosVec  = new THREE.Vector3();
const scaleVec = new THREE.Vector3();
const _tempVec = new THREE.Vector3();

/* scratch vectors – avoid per-frame allocations */
const tmp1 = new THREE.Vector3();
const tmp2 = new THREE.Vector3();
const tmp3 = new THREE.Vector3();

let cameraWorldPos = new THREE.Vector3();

const tmpVec = new THREE.Vector3();

const _ctrWS  = new THREE.Vector3();
const _offset = new THREE.Vector3();
const _scale  = new THREE.Vector3();

const _sunWS      = new THREE.Vector3();          // Sun (world space)
const _planetWS   = new THREE.Vector3();          // Planet (world space)
const _cornersLS  = [...Array(8)].map(() => new THREE.Vector3());
const _wsBox      = new THREE.Box3();
const _lsBox      = new THREE.Box3();             // Light-space AABB (reusable)
const _invMat     = new THREE.Matrix4();
const _camDir     = new THREE.Vector3();          // Camera direction (reusable in render loop)

const EARTH_POS    = new THREE.Vector3();         // Earth centre (world)
const SUN_POS      = new THREE.Vector3();         // Sun   centre (world)
const WOBBLE_POS  = new THREE.Vector3();          // WOBBLE   centre (world)
const PERIHELION_OF_EARTH_POS  = new THREE.Vector3();   // PERIHELION-OF-EARTH   centre (world)
const DELTA        = new THREE.Vector3();         // reusable difference-vector
const LOCAL        = new THREE.Vector3();         // world-to-Earth local
const DIRECTION    = new THREE.Vector3();         // direction vector for RA/Dec (wobble-corrected)
const ROT_MATRIX   = new THREE.Matrix4();         // rotation matrix for RA/Dec calculation
const CAM_LOCAL    = new THREE.Vector3();         // camera in Earth local
const CAMERA_POS   = new THREE.Vector3();
const PLANET_POS   = new THREE.Vector3();
const LOOK_DIR     = new THREE.Vector3();
const SPHERICAL    = new THREE.Spherical();

// Reusable vectors for updateFlares()
const _flareSunPos   = new THREE.Vector3();
const _flareCamPos   = new THREE.Vector3();
const _flareCamDir   = new THREE.Vector3();
const _flareToSun    = new THREE.Vector3();
const _flareLineDir  = new THREE.Vector3();
const _flarePos      = new THREE.Vector3();

// Reusable vector for tracePlanet()
const _tracePos = new THREE.Vector3();

const _elSunPos = new THREE.Vector3();
const _elEarthPos = new THREE.Vector3();
const _elTargetPos = new THREE.Vector3();

// Pooled vectors for dynamic inclination calculations
const _eclipticNormalVerified = new THREE.Vector3();
const _eclipticNormalSS = new THREE.Vector3();
const _planetNormal = new THREE.Vector3();

const world = new THREE.Vector3();
const ndc   = new THREE.Vector3();

const _pos        = new THREE.Vector3();
const _camPos     = new THREE.Vector3();
const _starPos    = new THREE.Vector3();
const _linePos    = new THREE.Vector3();

const starsArr = sceneObjects.stars.children;
const constArr = sceneObjects.constellations.children;

let tlapsed = 0;
let posElapsed =0;
let domElapsed =0;  // Separate throttle for DOM label updates (5 Hz)
let uiElapsed =0;
let lightElapsed =0;
let updatePredictionElapsed = 0;
let astroCalcElapsed = 0;  // Throttle for heavy astronomical calculations (10 Hz)
let visualElapsed = 0;  // Throttle for visual effects (30 Hz)

let cameraMoved = true; // Force first update
let positionChanged = false; // Set true when date/time changed externally (GUI, jump, etc.)
let eggTriggered = false;

const DEG = Math.PI / 180;
const KM_TO_MI = 0.62137119;   // 1 kilometre  → 0.621 371 miles

const state = {
  prevJD  : startmodelJD,     // JD at previous animation tick
  deltaT  : deltaTStart    // accumulated ΔT (seconds)
};

// create the golden-spiral line (returns { line, update })
const golden = goldenspiralPerihelionObjects(
  mercuryPerihelionFromEarth,
  venusPerihelionFromEarth,
  marsPerihelionFromEarth,
  jupiterPerihelionFromEarth,
  neptunePerihelionFromEarth,
  saturnPerihelionFromEarth,
  uranusPerihelionFromEarth,
  camera,
  scene
);

/* ------------------------------------------------------------------ */
/*  CONSTANTS & UTILITIES                                             */
/* ------------------------------------------------------------------ */

/* wrap any real angle to 0 … 360° ---------------------------------- */
const wrap360 = x => ((x % 360) + 360) % 360;

// --------------------------------------------------------------
//  GLOBAL helper: store frozen widths per planet name
// --------------------------------------------------------------
const columnCache = {};   // e.g. { earth: "max-content 14ch 6ch", mars: … }

/* ------------------------------------------------------------------ */
/*  Globals used by updateDomLabel()                                  */
/* ------------------------------------------------------------------ */
let labelDismissed = false;
let prevPlanetName = '';
let labelPrevHTML  = '';

/* ------------------------------------------------------------------ */
/*  Static value cache for planetStats performance optimization       */
/*  Values with static:true are computed once when planet changes     */
/* ------------------------------------------------------------------ */
const staticValueCache = {};  // { planetName: { rowIndex: renderedHTML } }
const niceName = s => s.charAt(0).toUpperCase() + s.slice(1);

const PLANET_SYMBOL = {
  sun     : '☉',   mercury : '☿',  venus  : '♀',
  earth   : '♁',   moon    : '☾',
  mars    : '♂',   jupiter : '♃',  saturn : '♄',
  uranus  : '♅',   neptune : '♆',  pluto  : '♇'
};

// put every "big-radius" object that must expand / shrink together in one array
const scalableObjects = [
  sceneObjects.stars,
  sceneObjects.constellations,
  celestialSphere,
  plane,
  invariablePlaneGroup,
  inclinationPathGroup
];

//const baseCamDistance = camera.position.length(); // distance that feels “100 %” size
const zoomFactor = 1.0;   // identical to your star-label code
const minScale   = 0.01;   // clamp values to taste
const maxScale   = 0.9;

const label        = document.getElementById('planetLabel');
const labelContent = label.querySelector('.labelContent');

//*************************************************************
// PLANET HIERARCHY INSPECTOR
//*************************************************************

// Planet registry - maps planet names to their hierarchy chain
const PLANET_HIERARCHIES = {
  mercury: {
    label: 'Mercury',
    fixedPerihelion: () => mercuryFixedPerihelionAtSun,
    perihelionOf: () => mercuryPerihelionFromEarth,
    steps: () => [
      { obj: mercuryPerihelionDurationEcliptic1, name: 'mercuryPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: mercuryPerihelionFromEarth, name: 'mercuryPerihelionFromEarth', parentName: 'mercuryPerihelionDurationEcliptic1' },
      { obj: mercuryPerihelionDurationEcliptic2, name: 'mercuryPerihelionDurationEcliptic2', parentName: 'mercuryPerihelionFromEarth' },
      { obj: mercuryRealPerihelionAtSun, name: 'mercuryRealPerihelionAtSun', parentName: 'mercuryPerihelionDurationEcliptic2' },
      { obj: mercury, name: 'mercury', parentName: 'mercuryRealPerihelionAtSun' }
    ]
  },
  venus: {
    label: 'Venus',
    fixedPerihelion: () => venusFixedPerihelionAtSun,
    perihelionOf: () => venusPerihelionFromEarth,
    steps: () => [
      { obj: venusPerihelionDurationEcliptic1, name: 'venusPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: venusPerihelionFromEarth, name: 'venusPerihelionFromEarth', parentName: 'venusPerihelionDurationEcliptic1' },
      { obj: venusPerihelionDurationEcliptic2, name: 'venusPerihelionDurationEcliptic2', parentName: 'venusPerihelionFromEarth' },
      { obj: venusRealPerihelionAtSun, name: 'venusRealPerihelionAtSun', parentName: 'venusPerihelionDurationEcliptic2' },
      { obj: venus, name: 'venus', parentName: 'venusRealPerihelionAtSun' }
    ]
  },
  mars: {
    label: 'Mars',
    fixedPerihelion: () => marsFixedPerihelionAtSun,
    perihelionOf: () => marsPerihelionFromEarth,
    steps: () => [
      { obj: marsPerihelionDurationEcliptic1, name: 'marsPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: marsPerihelionFromEarth, name: 'marsPerihelionFromEarth', parentName: 'marsPerihelionDurationEcliptic1' },
      { obj: marsPerihelionDurationEcliptic2, name: 'marsPerihelionDurationEcliptic2', parentName: 'marsPerihelionFromEarth' },
      { obj: marsRealPerihelionAtSun, name: 'marsRealPerihelionAtSun', parentName: 'marsPerihelionDurationEcliptic2' },
      { obj: mars, name: 'mars', parentName: 'marsRealPerihelionAtSun' }
    ]
  },
  jupiter: {
    label: 'Jupiter',
    fixedPerihelion: () => jupiterFixedPerihelionAtSun,
    perihelionOf: () => jupiterPerihelionFromEarth,
    steps: () => [
      { obj: jupiterPerihelionDurationEcliptic1, name: 'jupiterPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: jupiterPerihelionFromEarth, name: 'jupiterPerihelionFromEarth', parentName: 'jupiterPerihelionDurationEcliptic1' },
      { obj: jupiterPerihelionDurationEcliptic2, name: 'jupiterPerihelionDurationEcliptic2', parentName: 'jupiterPerihelionFromEarth' },
      { obj: jupiterRealPerihelionAtSun, name: 'jupiterRealPerihelionAtSun', parentName: 'jupiterPerihelionDurationEcliptic2' },
      { obj: jupiter, name: 'jupiter', parentName: 'jupiterRealPerihelionAtSun' }
    ]
  },
  saturn: {
    label: 'Saturn',
    fixedPerihelion: () => saturnFixedPerihelionAtSun,
    perihelionOf: () => saturnPerihelionFromEarth,
    steps: () => [
      { obj: saturnPerihelionDurationEcliptic1, name: 'saturnPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: saturnPerihelionFromEarth, name: 'saturnPerihelionFromEarth', parentName: 'saturnPerihelionDurationEcliptic1' },
      { obj: saturnPerihelionDurationEcliptic2, name: 'saturnPerihelionDurationEcliptic2', parentName: 'saturnPerihelionFromEarth' },
      { obj: saturnRealPerihelionAtSun, name: 'saturnRealPerihelionAtSun', parentName: 'saturnPerihelionDurationEcliptic2' },
      { obj: saturn, name: 'saturn', parentName: 'saturnRealPerihelionAtSun' }
    ]
  },
  uranus: {
    label: 'Uranus',
    fixedPerihelion: () => uranusFixedPerihelionAtSun,
    perihelionOf: () => uranusPerihelionFromEarth,
    steps: () => [
      { obj: uranusPerihelionDurationEcliptic1, name: 'uranusPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: uranusPerihelionFromEarth, name: 'uranusPerihelionFromEarth', parentName: 'uranusPerihelionDurationEcliptic1' },
      { obj: uranusPerihelionDurationEcliptic2, name: 'uranusPerihelionDurationEcliptic2', parentName: 'uranusPerihelionFromEarth' },
      { obj: uranusRealPerihelionAtSun, name: 'uranusRealPerihelionAtSun', parentName: 'uranusPerihelionDurationEcliptic2' },
      { obj: uranus, name: 'uranus', parentName: 'uranusRealPerihelionAtSun' }
    ]
  },
  neptune: {
    label: 'Neptune',
    fixedPerihelion: () => neptuneFixedPerihelionAtSun,
    perihelionOf: () => neptunePerihelionFromEarth,
    steps: () => [
      { obj: neptunePerihelionDurationEcliptic1, name: 'neptunePerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: neptunePerihelionFromEarth, name: 'neptunePerihelionFromEarth', parentName: 'neptunePerihelionDurationEcliptic1' },
      { obj: neptunePerihelionDurationEcliptic2, name: 'neptunePerihelionDurationEcliptic2', parentName: 'neptunePerihelionFromEarth' },
      { obj: neptuneRealPerihelionAtSun, name: 'neptuneRealPerihelionAtSun', parentName: 'neptunePerihelionDurationEcliptic2' },
      { obj: neptune, name: 'neptune', parentName: 'neptuneRealPerihelionAtSun' }
    ]
  },
  pluto: {
    label: 'Pluto',
    fixedPerihelion: () => plutoFixedPerihelionAtSun,
    perihelionOf: () => plutoPerihelionFromEarth,
    steps: () => [
      { obj: plutoPerihelionDurationEcliptic1, name: 'plutoPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: plutoPerihelionFromEarth, name: 'plutoPerihelionFromEarth', parentName: 'plutoPerihelionDurationEcliptic1' },
      { obj: plutoPerihelionDurationEcliptic2, name: 'plutoPerihelionDurationEcliptic2', parentName: 'plutoPerihelionFromEarth' },
      { obj: plutoRealPerihelionAtSun, name: 'plutoRealPerihelionAtSun', parentName: 'plutoPerihelionDurationEcliptic2' },
      { obj: pluto, name: 'pluto', parentName: 'plutoRealPerihelionAtSun' }
    ]
  },
  halleys: {
    label: "Halley's Comet",
    fixedPerihelion: () => halleysFixedPerihelionAtSun,
    perihelionOf: () => halleysPerihelionFromEarth,
    steps: () => [
      { obj: halleysPerihelionDurationEcliptic1, name: 'halleysPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: halleysPerihelionFromEarth, name: 'halleysPerihelionFromEarth', parentName: 'halleysPerihelionDurationEcliptic1' },
      { obj: halleysPerihelionDurationEcliptic2, name: 'halleysPerihelionDurationEcliptic2', parentName: 'halleysPerihelionFromEarth' },
      { obj: halleysRealPerihelionAtSun, name: 'halleysRealPerihelionAtSun', parentName: 'halleysPerihelionDurationEcliptic2' },
      { obj: halleys, name: 'halleys', parentName: 'halleysRealPerihelionAtSun' }
    ]
  },
  eros: {
    label: 'Eros',
    fixedPerihelion: () => erosFixedPerihelionAtSun,
    perihelionOf: () => erosPerihelionFromEarth,
    steps: () => [
      { obj: erosPerihelionDurationEcliptic1, name: 'erosPerihelionDurationEcliptic1', parentName: 'startingPoint' },
      { obj: erosPerihelionFromEarth, name: 'erosPerihelionFromEarth', parentName: 'erosPerihelionDurationEcliptic1' },
      { obj: erosPerihelionDurationEcliptic2, name: 'erosPerihelionDurationEcliptic2', parentName: 'erosPerihelionFromEarth' },
      { obj: erosRealPerihelionAtSun, name: 'erosRealPerihelionAtSun', parentName: 'erosPerihelionDurationEcliptic2' },
      { obj: eros, name: 'eros', parentName: 'erosRealPerihelionAtSun' }
    ]
  }
};

// ================================================================
// PLANET TEST DATES CONFIGURATION
// ================================================================
// Each planet has its own list of Julian Day dates to test.
// - jd: Julian Day number
// - type: 'position', 'longitude', or 'both'
// - label: Human-readable description
// - showOnScreen: true = show in inspector panel, false = Excel only
//
// DATA SOURCES:
// - Mercury transits: https://eclipse.gsfc.nasa.gov/transit/catalog/MercuryCatalog.html (NASA GSFC)
// - Venus transits: https://eclipse.gsfc.nasa.gov/transit/catalog/VenusCatalog.html (NASA GSFC)
// - Mars oppositions: https://stjerneskinn.com/mars-at-opposition.htm (Jean Meeus tables)
//                     https://www.nakedeyeplanets.com/mars-oppositions.htm
// - Jupiter/Saturn conjunctions: https://astropixels.com/ephemeris/planets/jupiter2020.html (JPL DE405)
//                                https://www.astropro.com/features/tables/geo/ju-sa/ju000sa.html
// - Mutual planetary occultations: https://en.wikipedia.org/wiki/List_of_mutual_planetary_eclipses
//                                  https://www.projectpluto.com/mut_pln.htm
//                                  https://www.bogan.ca/astro/occultations/occltlst.htm
// ================================================================
const PLANET_TEST_DATES = {
  mercury: [
    // Model start date: ra is in decimal hours (e.g., 7.682 = 7h 40m 55s)
    { jd: 2451716.5, ra: '7.412897222', dec: '20.8486', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
    // NASA Mercury Transit Catalog: https://eclipse.gsfc.nasa.gov/transit/catalog/MercuryCatalog.html
    { jd: 2307579.3, dec: '-14.68', type: 'position', label: 'NASA date', showOnScreen: true },
    { jd: 2311048.9, dec: '15.61', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2312330.1, dec: '-15.49', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2315800.2, dec: '16.52', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2317080.8, dec: '-16.27', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2321831.5, dec: '-17.02', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2324381.5, dec: '-15.01', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2327851.2, dec: '15.94', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2329132.3, dec: '-15.81', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2332602.5, dec: '16.84', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2333883.0, dec: '-16.58', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2338633.7, dec: '-17.32', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2341183.7, dec: '-15.33', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2344653.5, dec: '16.27', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2345934.5, dec: '-16.12', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2350685.2, dec: '-16.87', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2355435.9, dec: '-17.59', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2356704.5, dec: '15.68', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2357985.9, dec: '-15.65', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2361455.8, dec: '16.59', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2362736.7, dec: '-16.42', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2367487.4, dec: '-17.17', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2370037.4, dec: '-14.91', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2372238.1, dec: '-17.88', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2373506.7, dec: '16.02', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2374788.1, dec: '-15.96', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2378258.0, dec: '16.90', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2379538.9, dec: '-16.73', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2384289.6, dec: '-17.45', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2386839.6, dec: '-15.50', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2390309.0, dec: '16.34', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2391590.3, dec: '-16.27', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2395060.3, dec: '17.21', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2396341.1, dec: '-17.02', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2401091.8, dec: '-17.74', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2403641.8, dec: '-15.81', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2407111.3, dec: '16.66', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2408392.5, dec: '-16.58', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2411862.6, dec: '17.52', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2413143.3, dec: '-17.31', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2417894.0, dec: '-18.01', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2420444.0, dec: '-16.12', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2423913.6, dec: '16.97', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2425194.7, dec: '-16.87', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2428664.9, dec: '17.81', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2429945.5, dec: '-17.59', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2434696.2, dec: '-18.28', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2435964.6, dec: '16.41', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2437246.2, dec: '-16.42', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2440715.8, dec: '17.28', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2441996.9, dec: '-17.17', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2446747.7, dec: '-17.87', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2449297.7, dec: '-15.97', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2451498.4, dec: '-18.54', type: 'position', label: 'NASA date', showOnScreen: true },
    { jd: 2452766.8, dec: '16.73', type: 'position', label: 'NASA date', showOnScreen: true },
    { jd: 2454048.4, dec: '-16.73', type: 'position', label: 'NASA date', showOnScreen: true },
    { jd: 2457518.1, dec: '17.58', type: 'position', label: 'NASA date', showOnScreen: true },
    { jd: 2458799.1, dec: '-17.45', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2463549.9, dec: '-18.14', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2466099.9, dec: '-16.27', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2469569.1, dec: '17.04', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2470850.6, dec: '-17.02', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2474320.4, dec: '17.88', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2475601.3, dec: '-17.73', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2480352.1, dec: '-18.41', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2482902.1, dec: '-16.58', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2486371.4, dec: '17.35', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2487652.8, dec: '-17.31', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2491122.7, dec: '18.16', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2492403.5, dec: '-18.01', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2497154.3, dec: '-18.67', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2499704.3, dec: '-16.87', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2503173.7, dec: '17.65', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2504455.0, dec: '-17.59', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2507925.0, dec: '18.45', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2509205.7, dec: '-18.28', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2513956.5, dec: '-18.92', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2515224.6, dec: '17.12', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2516506.5, dec: '-17.17', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2519975.9, dec: '17.94', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2521257.2, dec: '-17.87', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2526007.9, dec: '-18.54', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2528557.9, dec: '-16.73', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2532026.9, dec: '17.41', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2533308.7, dec: '-17.45', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2536778.2, dec: '18.23', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2538059.4, dec: '-18.14', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2542810.1, dec: '-18.80', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2545360.1, dec: '-17.02', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2548829.2, dec: '17.71', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2550110.9, dec: '-17.73', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2553580.5, dec: '18.50', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2554861.6, dec: '-18.41', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2559612.3, dec: '-19.04', type: 'position', label: 'NASA date', showOnScreen: false },
  ],
  // VENUS TRANSIT DATA
  // NASA Venus Transit Catalog: https://eclipse.gsfc.nasa.gov/transit/catalog/VenusCatalog.html
  venus: [
    { jd: 2451716.5, ra: '6.185725', dec: '23.8844', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
    { jd: 991610.0, dec: '-15.31', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1030146.3, dec: '16.16', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1033066.0, dec: '15.50', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1077446.5, dec: '-16.65', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1080366.0, dec: '-15.91', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1118902.5, dec: '16.83', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1121822.3, dec: '16.20', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1166202.5, dec: '-17.21', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1169122.0, dec: '-16.48', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1207658.7, dec: '17.47', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1210578.5, dec: '16.86', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1254958.5, dec: '-17.74', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1257878.1, dec: '-17.04', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1296415.0, dec: '18.08', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1299334.7, dec: '17.50', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1343714.5, dec: '-18.25', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1346634.1, dec: '-17.58', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1385171.2, dec: '18.67', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1388090.9, dec: '18.11', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1432470.5, dec: '-18.74', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1435390.1, dec: '-18.10', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1476847.1, dec: '18.69', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1521226.5, dec: '-19.21', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1524146.1, dec: '-18.59', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1565603.3, dec: '19.25', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1609982.5, dec: '-19.66', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1654359.5, dec: '19.76', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1698738.5, dec: '-20.08', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1743115.6, dec: '20.25', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1787494.5, dec: '-20.48', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1831871.8, dec: '20.71', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1876250.5, dec: '-20.86', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1920628.0, dec: '21.13', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1923547.7, dec: '20.72', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 1965006.4, dec: '-21.21', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2009384.1, dec: '21.52', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2012303.9, dec: '21.14', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2053762.4, dec: '-21.53', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2098140.3, dec: '21.87', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2101060.0, dec: '21.52', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2142518.4, dec: '-21.83', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2186896.4, dec: '22.18', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2189816.2, dec: '21.87', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2231274.3, dec: '-22.10', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2275652.6, dec: '22.45', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2278572.3, dec: '22.18', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2317110.7, dec: '-22.64', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2320030.3, dec: '-22.34', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2364408.7, dec: '22.69', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2367328.4, dec: '22.44', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2405866.7, dec: '-22.82', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2408786.2, dec: '-22.56', type: 'position', label: 'NASA date', showOnScreen: true },
    { jd: 2453164.8, dec: '22.89', type: 'position', label: 'NASA date', showOnScreen: true },
    { jd: 2456084.6, dec: '22.68', type: 'position', label: 'NASA date', showOnScreen: true },
    { jd: 2494622.6, dec: '-22.97', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2497542.2, dec: '-22.74', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2541921.0, dec: '23.05', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2544840.7, dec: '22.87', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2583378.6, dec: '-23.09', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2586298.1, dec: '-22.90', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2630677.1, dec: '23.17', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2633596.8, dec: '23.02', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2672134.5, dec: '-23.18', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2675054.1, dec: '-23.03', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2719433.2, dec: '23.24', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2722352.9, dec: '23.14', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2760890.5, dec: '-23.24', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2763810.0, dec: '-23.12', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2808189.3, dec: '23.28', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2811109.0, dec: '23.21', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2849646.4, dec: '-23.27', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2896945.4, dec: '23.28', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2899865.1, dec: '23.25', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2938402.3, dec: '-23.26', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2985701.5, dec: '23.24', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 2988621.2, dec: '23.25', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 3027158.3, dec: '-23.23', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 3074457.6, dec: '23.16', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 3077377.3, dec: '23.21', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 3115914.2, dec: '-23.16', type: 'position', label: 'NASA date', showOnScreen: false },
    { jd: 3166133.4, dec: '23.13', type: 'position', label: 'NASA date', showOnScreen: false },
// VENUS OCCULTATIONS (9 events) https://en.wikipedia.org/wiki/List_of_mutual_planetary_eclipses    , https://www.projectpluto.com/mut_pln.htm   , https://www.bogan.ca/astro/occultations/occltlst.htm
// ============================================================
     { jd: 1388944.5, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1601453.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1618742.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1864578.6, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1997689.4, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2012028.8, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2222501.8, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2355634.4, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2500459.1, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
  ],
  // MARS OPPOSITION DATA
  // Sources: https://stjerneskinn.com/mars-at-opposition.htm (Jean Meeus tables)
  //          https://www.nakedeyeplanets.com/mars-oppositions.htm
  mars: [
    { jd: 2451716.5, ra: '6.219366667', dec: '24.2058', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
    // Mars Opposition dates - declination values from astronomical tables
    { jd: 2414673.5, dec: '24.70', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2415437.8, dec: '14.53', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2416202.8, dec: '-0.08', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2416974.3, dec: '-16.95', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2417763.1, dec: '-27.98', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2418573.9, dec: '-4.22', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2419365.7, dec: '21.72', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2420138.3, dec: '26.57', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2420903.6, dec: '19.13', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2421667.8, dec: '5.92', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2422435.9, dec: '-10.35', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2423216.1, dec: '-25.93', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2424021.2, dec: '-17.68', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2424823.9, dec: '14.45', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2425602.1, dec: '26.65', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2426369.3, dec: '22.90', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2427133.3, dec: '11.43', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2427899.2, dec: '-3.87', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2428673.3, dec: '-20.67', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2429467.8, dec: '-26.40', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2430278.0, dec: '3.50', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2431064.3, dec: '24.40', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2431834.5, dec: '25.60', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2432599.2, dec: '16.42', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2433363.7, dec: '2.33', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2434133.6, dec: '-14.28', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2434918.2, dec: '-27.68', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2435727.4, dec: '-10.13', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2436524.1, dec: '19.13', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2437298.9, dec: '26.82', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2438065.0, dec: '20.70', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2438829.0, dec: '8.13', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2439596.0, dec: '-7.72', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2440373.2, dec: '-23.95', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2441173.8, dec: '-22.25', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2441980.6, dec: '10.30', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2442762.1, dec: '26.05', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2443530.5, dec: '24.10', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2444294.7, dec: '13.45', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2445059.9, dec: '-1.35', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2445831.9, dec: '-18.10', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2446621.7, dec: '-27.73', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2447432.6, dec: '-2.12', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2448223.4, dec: '22.63', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2448995.4, dec: '26.27', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2449760.6, dec: '18.17', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2450524.8, dec: '4.67', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2451293.2, dec: '-11.62', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2452074.2, dec: '-26.50', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2452880.2, dec: '-15.82', type: 'position', label: 'Opposition', showOnScreen: true},
    { jd: 2453681.8, dec: '15.90', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2454459.3, dec: '26.77', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2455226.3, dec: '22.15', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2455990.3, dec: '10.28', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2456756.4, dec: '-5.13', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2457531.0, dec: '-21.65', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2458326.7, dec: '-25.50', type: 'position', label: 'Opposition', showOnScreen: true },
    { jd: 2459136.5, dec: '5.45', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2459921.7, dec: '25.00', type: 'position', label: 'Opposition', showOnScreen: true },
    { jd: 2460691.6, dec: '25.12', type: 'position', label: 'Opposition', showOnScreen: true },
    { jd: 2461456.2, dec: '15.37', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2462220.8, dec: '1.07', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2462991.0, dec: '-15.48', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2463776.6, dec: '-27.82', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2464586.3, dec: '-8.03', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2465381.9, dec: '20.27', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2466156.1, dec: '26.68', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2466922.0, dec: '19.83', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2467686.0, dec: '6.93', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2468453.2, dec: '-9.00', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2469231.1, dec: '-24.75', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2470032.8, dec: '-20.73', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2470838.8, dec: '11.97', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2471619.4, dec: '26.33', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2472387.6, dec: '23.45', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2473151.7, dec: '12.33', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2473917.0, dec: '-2.63', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2474689.4, dec: '-19.18', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2475480.4, dec: '-27.32', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2476291.3, dec: '-0.02', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2477080.9, dec: '23.43', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2477852.5, dec: '25.92', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2478617.6, dec: '17.20', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2479381.9, dec: '3.43', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2480150.6, dec: '-12.85', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2480932.3, dec: '-26.97', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2481739.2, dec: '-13.88', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2482539.8, dec: '17.27', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2483316.6, dec: '26.80', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2484083.3, dec: '21.35', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2484847.3, dec: '9.10', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2485613.6, dec: '-6.42', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2486388.8, dec: '-22.60', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2487185.6, dec: '-24.43', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2487994.8, dec: '7.33', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2488779.2, dec: '25.48', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2489548.7, dec: '24.57', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2490313.1, dec: '14.30', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2491077.9, dec: '-0.18', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2491848.4, dec: '-16.62', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2492635.0, dec: '-27.82', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2493445.2, dec: '-5.92', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2494239.6, dec: '21.32', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2495013.3, dec: '26.47', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2495779.0, dec: '18.92', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2496543.1, dec: '5.70', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2497310.5, dec: '-10.25', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2498089.0, dec: '-25.43', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2498891.8, dec: '-19.10', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2499696.9, dec: '13.57', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2500476.8, dec: '26.55', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2501244.6, dec: '22.73', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2502008.7, dec: '11.20', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2502774.2, dec: '-3.92', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2503547.1, dec: '-20.25', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2504339.1, dec: '-26.72', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2505149.9, dec: '2.02', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2505938.4, dec: '24.15', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2506709.7, dec: '25.48', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2507474.6, dec: '16.18', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2508238.9, dec: '2.18', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2509007.9, dec: '-14.05', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2509790.5, dec: '-27.30', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2510598.3, dec: '-11.85', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2511397.6, dec: '18.55', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2512173.8, dec: '26.73', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2512940.3, dec: '20.52', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2513704.3, dec: '7.92', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2514470.8, dec: '-7.68', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2515246.5, dec: '-23.47', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2516044.5, dec: '-23.23', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2516853.1, dec: '9.15', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2517636.6, dec: '25.90', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2518405.8, dec: '23.95', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2519170.1, dec: '13.20', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2519935.0, dec: '-1.45', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2520706.0, dec: '-17.77', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2521493.5, dec: '-27.68', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2522304.0, dec: '-3.78', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2523097.3, dec: '22.27', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2523870.4, dec: '26.18', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2524636.0, dec: '17.95', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2525400.1, dec: '4.48', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2526167.8, dec: '-11.47', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2526947.0, dec: '-26.02', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2527750.9, dec: '-17.33', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2528554.9, dec: '15.10', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2529334.0, dec: '26.67', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2530101.6, dec: '21.98', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2530865.7, dec: '10.03', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2531631.3, dec: '-5.17', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2532404.7, dec: '-21.23', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2533197.8, dec: '-25.98', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2534008.4, dec: '4.02', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2534796.0, dec: '24.78', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2535566.8, dec: '25.00', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2536331.5, dec: '15.13', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2537096.0, dec: '0.93', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2537865.3, dec: '-15.23', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2538648.8, dec: '-27.52', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2539457.3, dec: '-9.77', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2540255.5, dec: '19.73', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2541031.0, dec: '26.60', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2541797.3, dec: '19.63', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2542561.3, dec: '6.72', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2543328.0, dec: '-8.92', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2544104.3, dec: '-24.25', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2544903.5, dec: '-21.87', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2545711.4, dec: '10.90', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2546494.0, dec: '26.22', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2547262.8, dec: '23.30', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2548027.1, dec: '12.10', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2548792.1, dec: '-2.72', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2549563.5, dec: '-18.83', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2550352.0, dec: '-27.38', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2551162.7, dec: '-1.68', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2551954.9, dec: '23.10', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2552727.6, dec: '25.82', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2553493.0, dec: '16.97', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2554257.1, dec: '3.25', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2555025.1, dec: '-12.68', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2555805.1, dec: '-26.53', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2556610.0, dec: '-15.47', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2557413.0, dec: '16.53', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2558191.3, dec: '26.70', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2558958.6, dec: '21.17', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2559722.7, dec: '8.87', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2560488.5, dec: '-6.42', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2561262.3, dec: '-22.15', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2562056.6, dec: '-25.08', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2562866.9, dec: '5.97', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2563653.5, dec: '25.30', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2564423.8, dec: '24.45', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2565188.5, dec: '14.07', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2565953.0, dec: '-0.32', type: 'position', label: 'Opposition', showOnScreen: false },
    { jd: 2566722.7, dec: '-16.37', type: 'position', label: 'Opposition', showOnScreen: false },
// MARS OCCULTATIONS (12 events) https://en.wikipedia.org/wiki/List_of_mutual_planetary_eclipses    , https://www.projectpluto.com/mut_pln.htm   , https://www.bogan.ca/astro/occultations/occltlst.htm
// ============================================================
     { jd: 1382451.4, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1541461.1, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1561025.1, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1623446.3, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1705389.5, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1837063.3, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1932304.3, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2083530.1, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2302080.7, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2480621.6, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2497775.2, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2571132.5, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
  ],
  // JUPITER-SATURN GREAT CONJUNCTIONS (Occultations)
  // Sources: https://astropixels.com/ephemeris/planets/jupiter2020.html (JPL DE405 ephemeris)
  //          https://www.astropro.com/features/tables/geo/ju-sa/ju000sa.html (3000-year table)
  //          https://en.wikipedia.org/wiki/Great_conjunction
  // Longitude values in ecliptic coordinates (tropical zodiac)
  jupiter: [
    { jd: 2451716.5, ra: '3.730069444', dec: '18.8969', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
    // Jupiter-Saturn conjunctions with ecliptic longitude reference
    { jd: 2161655.0, longitude: '55.77', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2168918.0, longitude: '302.97', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: true },
    { jd: 2176423.0, longitude: '199.12', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2183305.0, longitude: '69.70', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2190769.0, longitude: '308.03', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2198068.0, longitude: '210.82', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2198184.0, longitude: '208.08', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2198274.0, longitude: '206.02', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2205166.0, longitude: '77.88', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2212402.0, longitude: '319.02', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2219922.0, longitude: '217.02', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2227028.0, longitude: '85.90', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2234250.0, longitude: '323.77', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2241584.0, longitude: '227.30', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2241616.0, longitude: '226.55', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2241777.0, longitude: '222.67', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2248674.0, longitude: '98.95', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2255882.0, longitude: '334.58', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2263411.0, longitude: '233.18', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2270539.0, longitude: '106.42', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2277729.0, longitude: '339.23', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2285265.0, longitude: '238.08', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2292180.0, longitude: '119.17', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2299361.0, longitude: '350.18', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2306895.0, longitude: '248.32', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2314045.0, longitude: '126.60', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: true },
    { jd: 2321208.0, longitude: '355.12', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2328747.0, longitude: '252.97', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2335695.0, longitude: '139.15', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2335803.0, longitude: '136.72', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2335901.0, longitude: '134.50', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2342843.0, longitude: '6.60', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2350377.0, longitude: '263.32', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2357554.0, longitude: '147.15', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2364694.0, longitude: '12.35', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2372231.0, longitude: '268.12', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2379424.0, longitude: '155.13', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2386336.0, longitude: '24.65', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2393862.0, longitude: '278.90', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2401070.0, longitude: '168.37', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2408189.0, longitude: '31.60', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2415717.0, longitude: '284.00', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2422943.0, longitude: '176.60', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2429850.0, longitude: '44.45', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2429923.0, longitude: '42.47', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2430041.0, longitude: '39.12', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2437350.0, longitude: '295.20', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2444605.0, longitude: '189.50', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2444668.0, longitude: '188.10', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2444810.0, longitude: '184.93', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2451693.0, longitude: '52.72', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2459205.0, longitude: '300.48', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: true },
    { jd: 2466459.0, longitude: '197.93', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2473557.0, longitude: '60.77', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2480839.0, longitude: '311.87', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: true },
    { jd: 2488330.0, longitude: '205.53', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2495204.0, longitude: '74.87', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2502692.0, longitude: '317.08', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2509973.0, longitude: '217.98', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2517071.0, longitude: '83.05', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2524325.0, longitude: '328.32', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2531836.0, longitude: '224.70', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2538722.0, longitude: '96.63', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2538850.0, longitude: '93.42', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2538918.0, longitude: '91.68', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2546176.0, longitude: '333.25', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2553484.0, longitude: '235.98', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2553574.0, longitude: '233.85', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2553690.0, longitude: '231.12', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2560580.0, longitude: '104.73', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2567808.0, longitude: '344.22', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2575332.0, longitude: '242.02', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2582444.0, longitude: '112.53', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2589655.0, longitude: '348.95', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
    { jd: 2597186.0, longitude: '247.42', type: 'position', label: 'Occultation', comparePlanet: 'saturn', showOnScreen: false },
// JUPITER OCCULTATIONS (42 events) https://en.wikipedia.org/wiki/List_of_mutual_planetary_eclipses   , https://www.projectpluto.com/mut_pln.htm    , https://www.bogan.ca/astro/occultations/occltlst.htm
// ============================================================
     { jd: 1363901.0, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1367887.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1395865.3, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1423361.5, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1439704.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1458892.9, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1479205.5, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1494378.0, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1508687.2, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 1519101.5, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1534273.1, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1552248.4, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1624407.2, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1653936.2, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 1667476.2, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1720860.4, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1820586.9, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 1853752.3, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1877682.6, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1901285.5, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 1907175.3, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1970158.4, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1976993.2, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1988594.1, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2024120.8, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2102311.3, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2148655.4, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 2156435.3, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2160931.3, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 2163270.0, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2227923.5, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 2294535.8, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2343999.5, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2345171.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2385073.4, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2475612.0, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2483987.1, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2485975.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2496726.1, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2533329.0, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 2574181.1, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2626372.5, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
  ],
  // SATURN-JUPITER GREAT CONJUNCTIONS (Occultations)
  // Sources: https://astropixels.com/ephemeris/planets/saturn2020.html (JPL DE405 ephemeris)
  //          https://www.astropro.com/features/tables/geo/ju-sa/ju000sa.html (3000-year table)
  //          https://en.wikipedia.org/wiki/Great_conjunction
  // Longitude values in ecliptic coordinates (tropical zodiac)
  saturn: [
    { jd: 2451716.5, ra: '3.580388889', dec: '17.1936', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
    // Saturn-Jupiter conjunctions with ecliptic longitude reference
    { jd: 2161655.0, longitude: '55.77', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2168918.0, longitude: '302.97', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: true },
    { jd: 2176423.0, longitude: '199.12', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2183305.0, longitude: '69.70', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2190769.0, longitude: '308.03', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2198068.0, longitude: '210.82', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2198184.0, longitude: '208.08', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2198274.0, longitude: '206.02', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2205166.0, longitude: '77.88', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2212402.0, longitude: '319.02', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2219922.0, longitude: '217.02', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2227028.0, longitude: '85.90', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2234250.0, longitude: '323.77', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2241584.0, longitude: '227.30', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2241616.0, longitude: '226.55', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2241777.0, longitude: '222.67', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2248674.0, longitude: '98.95', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2255882.0, longitude: '334.58', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2263411.0, longitude: '233.18', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2270539.0, longitude: '106.42', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2277729.0, longitude: '339.23', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2285265.0, longitude: '238.08', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2292180.0, longitude: '119.17', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2299361.0, longitude: '350.18', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2306895.0, longitude: '248.32', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2314045.0, longitude: '126.60', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: true },
    { jd: 2321208.0, longitude: '355.12', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2328747.0, longitude: '252.97', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2335695.0, longitude: '139.15', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2335803.0, longitude: '136.72', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2335901.0, longitude: '134.50', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2342843.0, longitude: '6.60', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2350377.0, longitude: '263.32', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2357554.0, longitude: '147.15', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2364694.0, longitude: '12.35', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2372231.0, longitude: '268.12', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2379424.0, longitude: '155.13', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2386336.0, longitude: '24.65', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2393862.0, longitude: '278.90', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2401070.0, longitude: '168.37', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2408189.0, longitude: '31.60', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2415717.0, longitude: '284.00', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2422943.0, longitude: '176.60', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2429850.0, longitude: '44.45', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2429923.0, longitude: '42.47', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2430041.0, longitude: '39.12', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2437350.0, longitude: '295.20', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2444605.0, longitude: '189.50', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2444668.0, longitude: '188.10', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2444810.0, longitude: '184.93', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2451693.0, longitude: '52.72', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2459205.0, longitude: '300.48', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: true },
    { jd: 2466459.0, longitude: '197.93', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2473557.0, longitude: '60.77', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2480839.0, longitude: '311.87', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: true },
    { jd: 2488330.0, longitude: '205.53', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2495204.0, longitude: '74.87', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2502692.0, longitude: '317.08', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2509973.0, longitude: '217.98', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2517071.0, longitude: '83.05', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2524325.0, longitude: '328.32', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2531836.0, longitude: '224.70', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2538722.0, longitude: '96.63', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2538850.0, longitude: '93.42', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2538918.0, longitude: '91.68', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2546176.0, longitude: '333.25', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2553484.0, longitude: '235.98', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2553574.0, longitude: '233.85', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2553690.0, longitude: '231.12', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2560580.0, longitude: '104.73', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2567808.0, longitude: '344.22', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2575332.0, longitude: '242.02', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2582444.0, longitude: '112.53', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2589655.0, longitude: '348.95', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2597186.0, longitude: '247.42', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
// SATURN OCCULTATIONS (19 events) https://en.wikipedia.org/wiki/List_of_mutual_planetary_eclipses    , https://www.projectpluto.com/mut_pln.htm   , https://www.bogan.ca/astro/occultations/occltlst.htm
// ============================================================
     { jd: 1359023.9, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1661510.6, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1717800.1, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 1750343.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1797617.4, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1809331.7, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1933280.6, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2055100.3, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2056972.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2095910.3, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2179057.9, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2238472.5, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2260754.3, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2260814.1, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 2276995.8, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 2368145.3, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2381761.4, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2540521.7, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2640765.4, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
  ],
  uranus: [
    { jd: 2451716.5, ra: '21.54528889', dec: '-15.3240', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
    { jd: 2314075.2, longitude: 'N/A', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2345089.0, longitude: 'N/A', type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
    { jd: 2376141.7, longitude: 'N/A', type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
// URANUS OCCULTATIONS (14 events) https://en.wikipedia.org/wiki/List_of_mutual_planetary_eclipses   , https://www.projectpluto.com/mut_pln.htm    , https://www.bogan.ca/astro/occultations/occltlst.htm
// ============================================================
     { jd: 1466919.5, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 1517868.3, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1707826.8, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1842746.6, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2073791.2, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2218697.0, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2226429.1, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2314075.2, type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
     { jd: 2345089.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2376141.7, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2543283.0, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2563927.4, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2579841.2, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2604944.6, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
  ],
  neptune: [
    { jd: 2451716.5, ra: '20.56120556', dec: '-18.5374', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
    { jd: 2361567.0, longitude: '125.08', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2366314.0, longitude: '152.67', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2371065.0, longitude: '180.20', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2375586.0, longitude: '233.75', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2375660.0, longitude: '239.07', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2375811.0, longitude: '237.65', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2380321.0, longitude: '267.17', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2385064.0, longitude: '294.35', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2389802.0, longitude: '321.42', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2394300.0, longitude: '320.95', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2394455.0, longitude: '319.33', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2394488.0, longitude: '318.73', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2399010.0, longitude: '344.35', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2403755.0, longitude: '15.58', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2408250.0, longitude: '45.58', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2412981.0, longitude: '73.17', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2417718.0, longitude: '100.83', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2422226.0, longitude: '130.82', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2422392.0, longitude: '129.20', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2422439.0, longitude: '128.75', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2426970.0, longitude: '155.42', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2431721.0, longitude: '185.90', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2436471.0, longitude: '213.30', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2440984.0, longitude: '242.78', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2441094.0, longitude: '241.73', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2441211.0, longitude: '240.62', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2445719.0, longitude: '270.15', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2450458.0, longitude: '297.15', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: true },
    { jd: 2454979.0, longitude: '326.48', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: true },
    { jd: 2455023.0, longitude: '326.03', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2455187.0, longitude: '324.30', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
    { jd: 2459682.0, longitude: '353.30', type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false }, 
// NEPTUNE OCCULTATIONS (16 events) https://en.wikipedia.org/wiki/List_of_mutual_planetary_eclipses    , https://www.projectpluto.com/mut_pln.htm     , https://www.bogan.ca/astro/occultations/occltlst.htm
// ============================================================
     { jd: 1405723.6, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 1439150.7, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1442495.5, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1528047.9, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 1918050.3, type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
     { jd: 1981572.8, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2157251.0, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2188084.1, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
     { jd: 2191071.7, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2242510.8, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2249744.9, type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
     { jd: 2310199.4, type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
     { jd: 2342964.1, type: 'position', label: 'Occultation', comparePlanet: 'jupiter', showOnScreen: false },
     { jd: 2476212.0, type: 'position', label: 'Occultation', comparePlanet: 'mercury', showOnScreen: false },
     { jd: 2489762.6, type: 'position', label: 'Occultation', comparePlanet: 'venus', showOnScreen: false },
     { jd: 2639740.9, type: 'position', label: 'Occultation', comparePlanet: 'mars', showOnScreen: false },
  ],
  pluto: [
    { jd: 2451716.5, ra: '16.73686667', dec: '-10.9377', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
  ],
  halleys: [
    { jd: 2451716.5, ra: '8.720219444', dec: '0.5128', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
  ],
  eros: [
    { jd: 2451716.5, ra: '20.64013056', dec: '-26.1392', type: 'both', label: 'Model start date (21 Jun 2000)', showOnScreen: true },
  ]
};

// Reference constants for longitude validation
const LONGITUDE_PERIHELION_REFS = {
  mercury: mercuryLongitudePerihelion,
  venus: venusLongitudePerihelion,
  mars: marsLongitudePerihelion,
  jupiter: jupiterLongitudePerihelion,
  saturn: saturnLongitudePerihelion,
  uranus: uranusLongitudePerihelion,
  neptune: neptuneLongitudePerihelion,
  pluto: plutoLongitudePerihelion,
  halleys: halleysLongitudePerihelion,
  eros: erosLongitudePerihelion
};

const ASCENDING_NODE_REFS = {
  mercury: mercuryAscendingNode,
  venus: venusAscendingNode,
  mars: marsAscendingNode,
  jupiter: jupiterAscendingNode,
  saturn: saturnAscendingNode,
  uranus: uranusAscendingNode,
  neptune: neptuneAscendingNode,
  pluto: plutoAscendingNode,
  halleys: halleysAscendingNode,
  eros: erosAscendingNode
};

// Planet object references for report generation
const PLANET_OBJECTS = {
  mercury: () => mercury,
  venus: () => venus,
  mars: () => mars,
  jupiter: () => jupiter,
  saturn: () => saturn,
  uranus: () => uranus,
  neptune: () => neptune,
  pluto: () => pluto,
  halleys: () => halleys,
  eros: () => eros
};

// Hierarchy inspector state
const hierarchyInspector = {
  panel: null,
  currentPlanet: 'mercury',
  currentStep: 0,
  highlightActive: false,
  axesHelper: null,
  startPosArrow: null,
  currentPosArrow: null,
  orbitCenterArrow: null,
  rotationArrow: null,
  inclinationPlane: null,
  ascendingNode: null,
  descendingNode: null,
  aboveHalfPlane: null,       // GREEN half-plane (above ecliptic)
  belowHalfPlane: null,       // RED half-plane (below ecliptic)
  highestPointMarker: null,   // GREEN sphere at highest point (90° after ascending node)
  lowestPointMarker: null,    // RED sphere at lowest point (90° after descending node)
  perihelionDot: null,
  perihelionArrow: null,
  earthPerihelionArrow: null, // Green arrow from planet perihelion to Earth perihelion (Step 2)
  // Anomaly visualization elements (updated live)
  anomalyGroup: null,
  perihelionLine: null,
  trueAnomalyLine: null,
  meanAnomalyLine: null,
  trueAnomalyArc: null,
  meanAnomalyArc: null,
  // New anomaly visualization elements (P→Planet, Sun→Planet lines and arcs)
  pToPlanetLine: null,
  sunToPlanetLine: null,
  meanAnomalyArcAtP: null,
  trueAnomalyArcAtSun: null,
  _meanArcAtPRadius: null,
  _trueArcAtSunRadius: null,
  // Temporary perihelion visibility state (for step-based camera focus)
  _tempPerihelionVisible: null,
  _tempPerihelionOriginalVisible: null,
  _tempPerihelionOrbitOriginalVisible: null,
  // Camera control flag - when true, hierarchy inspector controls camera target
  _cameraControlActive: false,
  _cameraTarget: null,  // The object to focus on (for animation loop)
  helpers: {
    showAxes: true,
    showStartPos: true,
    showOrbitCenter: false,  // Solar period reference - off by default
    showRotationDir: true,
    showInclinationPlane: true,
    showPerihelionPoint: true,
    showAnomalies: true
  }
};

// Get parent object by name
function getParentObject(parentName) {
  if (parentName === 'startingPoint') return startingPoint;
  // Search through all hierarchies for the object
  for (const planetKey of Object.keys(PLANET_HIERARCHIES)) {
    const steps = PLANET_HIERARCHIES[planetKey].steps();
    for (const step of steps) {
      if (step.name === parentName) return step.obj;
    }
  }
  return null;
}

// Calculate period from speed (preserves sign to indicate direction)
function speedToPeriod(speed) {
  if (!speed || speed === 0) return Infinity;
  // Preserve sign: negative speed = negative period (opposite direction)
  return (2 * Math.PI) / speed;
}

// Calculate arcseconds per century from period (preserves sign)
function periodToArcsecPerCentury(periodYears) {
  if (!isFinite(periodYears) || periodYears === 0) return 0;
  // Preserve sign: negative period = negative arcsec/century (retrograde precession)
  return 129600000 / periodYears; // 360° * 3600 arcsec/degree * 100 years = 129,600,000 arcsec/century
}

// Format number with precision
function formatNum(val, precision = 4) {
  if (val === undefined || val === null) return 'undefined';
  if (typeof val !== 'number') return String(val);
  if (isNaN(val)) return 'NaN';
  if (!isFinite(val)) return val > 0 ? 'Infinity' : '-Infinity';
  if (Math.abs(val) > 1e9) return '∞';  // show infinity symbol for very large numbers
  return val.toFixed(precision);
}

// Validate a step and return issues
function validateStep(stepData, stepIndex, steps) {
  const issues = [];
  const obj = stepData.obj;

  // Check for NaN values
  if (isNaN(obj.speed)) issues.push({ type: 'error', msg: 'Speed is NaN' });
  if (isNaN(obj.startPos)) issues.push({ type: 'error', msg: 'StartPos is NaN' });
  if (isNaN(obj.orbitRadius)) issues.push({ type: 'error', msg: 'OrbitRadius is NaN' });
  if (isNaN(obj.orbitCentera) || isNaN(obj.orbitCenterb) || isNaN(obj.orbitCenterc)) {
    issues.push({ type: 'error', msg: 'OrbitCenter has NaN values' });
  }

  // Check for zero speed on precession steps (steps 0, 2)
  if ((stepIndex === 0 || stepIndex === 2) && obj.speed === 0) {
    issues.push({ type: 'warning', msg: 'Speed is 0 - no precession will occur' });
  }

  // Check runtime objects exist
  if (!obj.containerObj) issues.push({ type: 'error', msg: 'containerObj not created' });
  if (!obj.pivotObj) issues.push({ type: 'error', msg: 'pivotObj not created' });
  if (!obj.orbitObj) issues.push({ type: 'warning', msg: 'orbitObj not created' });

  // Check parent-child connection
  if (stepIndex > 0) {
    const parentObj = getParentObject(stepData.parentName);
    if (parentObj && parentObj.pivotObj && obj.containerObj) {
      if (obj.containerObj.parent !== parentObj.pivotObj) {
        issues.push({ type: 'error', msg: `Not attached to parent's pivot (${stepData.parentName})` });
      }
    }
  }

  // Check if orbitRadius and orbitCenter both have non-zero values
  if (obj.orbitRadius > 0 && (obj.orbitCentera !== 0 || obj.orbitCenterb !== 0 || obj.orbitCenterc !== 0)) {
    issues.push({ type: 'warning', msg: 'Both orbitRadius and orbitCenter are set' });
  }

  // Step 2 (PerihelionFromEarth) should point at the Sun - calculate angle to Sun
  if (stepIndex === 1 && obj.pivotObj && sun.pivotObj) {
    // Get world positions (using reusable temp vectors)
    obj.pivotObj.getWorldPosition(_hiObjWorldPos);
    sun.pivotObj.getWorldPosition(_hiSunWorldPos);

    // Calculate angle from object to Sun in XZ plane
    const dx = _hiSunWorldPos.x - _hiObjWorldPos.x;
    const dz = _hiSunWorldPos.z - _hiObjWorldPos.z;
    const angleToSunRad = Math.atan2(-dz, dx); // Note: -dz because of coordinate system
    const angleToSunDeg = angleToSunRad * 180 / Math.PI;

    // Get current rotation (startPos + accumulated rotation)
    const startPosRad = (obj.startPos || 0) * Math.PI / 180;
    const currentRotation = obj.orbitObj?.rotation?.y ?? 0;
    const currentAngleRad = startPosRad + currentRotation;
    const currentAngleDeg = currentAngleRad * 180 / Math.PI;

    // Normalize angles to -180 to 180
    const normalizeAngle = (a) => ((a + 180) % 360 + 360) % 360 - 180;
    const normalizedCurrent = normalizeAngle(currentAngleDeg);
    const normalizedToSun = normalizeAngle(angleToSunDeg);
    const angleDiff = Math.abs(normalizeAngle(normalizedCurrent - normalizedToSun));

    issues.push({
      type: 'info',
      msg: `Angle between Perihelion and Sun: ${(normalizedToSun - 90).toFixed(2)}°`
    });

    // Calculate distance between earthPerihelionFromEarth and the planet's perihelion
    if (earthPerihelionFromEarth?.pivotObj && obj.pivotObj) {
      earthPerihelionFromEarth.pivotObj.getWorldPosition(_hiEarthPeriPos);

      const distanceSceneUnits = Math.sqrt(
        Math.pow(_hiObjWorldPos.x - _hiEarthPeriPos.x, 2) +
        Math.pow(_hiObjWorldPos.y - _hiEarthPeriPos.y, 2) +
        Math.pow(_hiObjWorldPos.z - _hiEarthPeriPos.z, 2)
      );
      const distanceAU = distanceSceneUnits / 100; // scene units to AU

      issues.push({
        type: 'info',
        msg: `Calculated distance perihelion Sun barycenter: ${distanceAU.toFixed(6)} AU`
      });
    }

    // Calculate angle from earthPerihelionFromEarth to planet perihelion using apparentRaFromPdA
    // This uses the astronomical Right Ascension calculation for accuracy
    if (earthPerihelionFromEarth && obj) {
      // Reference longitude of perihelion values (expected on model start date)
      const referenceLongitudes = {
        mercury: mercuryLongitudePerihelion,
        venus: venusLongitudePerihelion,
        mars: marsLongitudePerihelion,
        jupiter: jupiterLongitudePerihelion,
        saturn: saturnLongitudePerihelion,
        uranus: uranusLongitudePerihelion,
        neptune: neptuneLongitudePerihelion,
        pluto: plutoLongitudePerihelion,
        halleys: halleysLongitudePerihelion,
        eros: erosLongitudePerihelion
      };

      const currentPlanet = hierarchyInspector.currentPlanet;
      const referenceLong = referenceLongitudes[currentPlanet];

      try {
        const angleDeg = apparentRaFromPdA(earthPerihelionFromEarth, obj);
        issues.push({
          type: 'info',
          msg: `Calculated longitude of perihelion: ${angleDeg.toFixed(6)}°`
        });
      } catch (e) {
        // If calculation fails (e.g., missing ra/distKm), skip silently
      }

      if (referenceLong !== undefined) {
        issues.push({
          type: 'reference',
          msg: `Reference longitude of perihelion: ${referenceLong.toFixed(6)}°`
        });
      }
    }
  }

  // Step 4 (RealPerihelionAtSun) - comprehensive orbital diagnostics
  if (stepIndex === 3) {
    const tiltaDeg = obj.orbitTilta || 0;
    const tiltbDeg = obj.orbitTiltb || 0;
    const startPosDeg = obj.startPos || 0;

    // Calculate the total inclination magnitude
    const totalInclinationDeg = Math.sqrt(tiltaDeg * tiltaDeg + tiltbDeg * tiltbDeg);

    // Calculate the longitude of ascending node from tilt components
    // The encoding formula used in RealPerihelionAtSun objects is:
    //   orbitTilta = cos((-90-Ω) * π/180) * -inclination
    //   orbitTiltb = sin((-90-Ω) * π/180) * -inclination
    // The negative inclination flips signs, equivalent to adding 180°:
    //   orbitTilta = cos((90-Ω) * π/180) * inclination
    //   orbitTiltb = sin((90-Ω) * π/180) * inclination
    // To reverse: θ = atan2(tiltb, tilta) = (90 - Ω), so Ω = 90 - θ
    const theta = Math.atan2(tiltbDeg, tiltaDeg) * 180 / Math.PI;
    let ascNodeAngleDeg = 90 - theta;
    // Normalize to 0-360 range
    ascNodeAngleDeg = ((ascNodeAngleDeg % 360) + 360) % 360;

    issues.push({
      type: 'valid',
      msg: `orbitTilta: ${tiltaDeg.toFixed(4)}° (rotation around X)`
    });
    issues.push({
      type: 'valid',
      msg: `orbitTiltb: ${tiltbDeg.toFixed(4)}° (rotation around Z)`
    });
    issues.push({
      type: 'valid',
      msg: `Total inclination: ${totalInclinationDeg.toFixed(4)}°`
    });

  }

  // Step 5 (actual planet) - RA validation now shown in Position Report section

  if (issues.length === 0) {
    issues.push({ type: 'valid', msg: 'All checks passed' });
  }

  return issues;
}

// Create visual helpers for current step
// Options:
//   skipClear: if true, don't call clearVisualHelpers (caller has already done it)
function createVisualHelpers(stepData, options = {}) {
  const { skipClear = false } = options;
  if (!skipClear) {
    // Force clean all anomaly elements since we're recreating for potentially a new step
    clearVisualHelpers({ forceCleanAnomalies: true });
  }

  const obj = stepData.obj;
  if (!obj.pivotObj) return;

  const scale = Math.max(50, obj.orbitRadius || 50);

  // Axes helper (XYZ)
  if (hierarchyInspector.helpers.showAxes) {
    hierarchyInspector.axesHelper = new THREE.AxesHelper(scale * 0.5);
    obj.pivotObj.add(hierarchyInspector.axesHelper);
  }

  // StartPos direction arrow (WHITE - initial/to-be position)
  if (hierarchyInspector.helpers.showStartPos && obj.startPos !== undefined) {
    const startPosRad = (obj.startPos || 0) * Math.PI / 180;
    const arrowDir = new THREE.Vector3(Math.cos(startPosRad), 0, -Math.sin(startPosRad));
    const arrowLength = scale * 0.4;
    hierarchyInspector.startPosArrow = new THREE.ArrowHelper(
      arrowDir, new THREE.Vector3(0, 0, 0), arrowLength, 0xffd700, arrowLength * 0.15, arrowLength * 0.08
    );
    obj.pivotObj.add(hierarchyInspector.startPosArrow);

    // Current position arrow (WHITE - where object currently is)
    // The current rotation is stored in orbitObj.rotation.y
    const currentRotation = obj.orbitObj?.rotation?.y ?? 0;
    const currentPosRad = startPosRad + currentRotation;
    const currentDir = new THREE.Vector3(Math.cos(currentPosRad), 0, -Math.sin(currentPosRad));
    hierarchyInspector.currentPosArrow = new THREE.ArrowHelper(
      currentDir, new THREE.Vector3(0, 0, 0), arrowLength * 1.1, 0xffffff, arrowLength * 0.15, arrowLength * 0.08
    );
    obj.pivotObj.add(hierarchyInspector.currentPosArrow);
  }

  // Orbit center offset arrow
  if (hierarchyInspector.helpers.showOrbitCenter) {
    const offsetX = obj.orbitCentera || 0;
    const offsetY = obj.orbitCenterc || 0;
    const offsetZ = obj.orbitCenterb || 0;
    if (offsetX !== 0 || offsetY !== 0 || offsetZ !== 0) {
      const offsetVec = new THREE.Vector3(offsetX, offsetY, offsetZ);
      const offsetLength = offsetVec.length();
      hierarchyInspector.orbitCenterArrow = new THREE.ArrowHelper(
        offsetVec.clone().normalize(), new THREE.Vector3(0, 0, 0), offsetLength, 0x00ffff, offsetLength * 0.15, offsetLength * 0.08
      );
      obj.pivotObj.add(hierarchyInspector.orbitCenterArrow);
    }
  }

  // Rotation direction indicator
  if (hierarchyInspector.helpers.showRotationDir && obj.speed !== 0) {
    const isCounterClockwise = obj.speed > 0;
    const color = isCounterClockwise ? 0x00ff00 : 0xff0000;
    const curve = new THREE.EllipseCurve(0, 0, scale * 0.3, scale * 0.3, 0, Math.PI * 1.5, !isCounterClockwise);
    const points = curve.getPoints(32);
    const geometry = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x, 0, p.y)));
    const material = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
    hierarchyInspector.rotationArrow = new THREE.Line(geometry, material);
    obj.pivotObj.add(hierarchyInspector.rotationArrow);
  }

  // Green arrow from planet perihelion to Earth perihelion (Step 2 only)
  if (hierarchyInspector.currentStep === 1 && earthPerihelionFromEarth?.pivotObj && obj.pivotObj) {
    obj.pivotObj.getWorldPosition(_hiPlanetPeriPos);
    earthPerihelionFromEarth.pivotObj.getWorldPosition(_hiEarthPeriPos);

    // Calculate direction and distance (reusing temp vector)
    _hiDirection.subVectors(_hiEarthPeriPos, _hiPlanetPeriPos);
    const distance = _hiDirection.length();

    if (distance > 0.001) {
      _hiDirection.normalize();
      // Create green arrow from planet perihelion pointing to Earth perihelion
      hierarchyInspector.earthPerihelionArrow = new THREE.ArrowHelper(
        _hiDirection,
        _hiPlanetPeriPos,
        distance,
        0x00ff00,  // Green color
        distance * 0.1,  // Head length
        distance * 0.05  // Head width
      );
      scene.add(hierarchyInspector.earthPerihelionArrow);
    }
  }

  // Inclination plane with ascending/descending nodes (Step 4 only - RealPerihelionAtSun)
  // Step 4 is index 3 (0-based), and it has orbitTilta for orbital inclination
  if (hierarchyInspector.helpers.showInclinationPlane &&
      hierarchyInspector.currentStep === 3 &&
      (obj.orbitTilta !== undefined || obj.orbitTiltb !== undefined)) {

    // Get the actual tilt values in degrees (as stored in the object)
    const tiltaDeg = obj.orbitTilta || 0;
    const tiltbDeg = obj.orbitTiltb || 0;
    const tiltaRad = tiltaDeg * Math.PI / 180;
    const tiltbRad = tiltbDeg * Math.PI / 180;

    const planeRadius = scale * 0.5;

    // Create a group to hold the inclined plane and nodes
    hierarchyInspector.inclinationPlane = new THREE.Group();

    // Create ecliptic plane reference (flat ring at y=0) - BLUE DASHED
    const eclipticCurve = new THREE.EllipseCurve(0, 0, planeRadius * 1.05, planeRadius * 1.05, 0, Math.PI * 2, false);
    const eclipticPoints = eclipticCurve.getPoints(64);
    const eclipticGeometry = new THREE.BufferGeometry().setFromPoints(
      eclipticPoints.map(p => new THREE.Vector3(p.x, 0, p.y))
    );
    const eclipticMaterial = new THREE.LineDashedMaterial({
      color: 0x4488ff,
      linewidth: 1,
      dashSize: 5,
      gapSize: 3
    });
    const eclipticLine = new THREE.Line(eclipticGeometry, eclipticMaterial);
    eclipticLine.computeLineDistances();
    hierarchyInspector.inclinationPlane.add(eclipticLine);

    // COORDINATE SYSTEM EXPLANATION:
    // The inclinationPlane is added to obj.pivotObj, which is INSIDE orbitContainer.
    // orbitContainer already has the tilt applied (rotation.x and rotation.z).
    // Therefore, our LOCAL y=0 plane IS the tilted orbital plane in world space.
    // The WORLD ecliptic (world y=0) appears tilted relative to our local frame.
    //
    // To find nodes and color the half-planes correctly, we need to transform
    // LOCAL points to WORLD space to check which side of the ecliptic they're on.
    //
    // The parent (orbitContainer) applies rotation via Euler angles:
    //   rotation.x = tiltaRad, rotation.z = tiltbRad (default 'XYZ' order)
    // We must match this EXACTLY by using the same Euler approach
    const localToWorld = new THREE.Matrix4();
    localToWorld.makeRotationFromEuler(new THREE.Euler(tiltaRad, 0, tiltbRad, 'XYZ'));

    // Get the ACTUAL ascending node angle from the o.xxxAscendingNode property
    // This is the authoritative value that's dynamically calculated for the current date
    const ascNodePropertyMap = {
      mercury: 'mercuryAscendingNode',
      venus: 'venusAscendingNode',
      mars: 'marsAscendingNode',
      jupiter: 'jupiterAscendingNode',
      saturn: 'saturnAscendingNode',
      uranus: 'uranusAscendingNode',
      neptune: 'neptuneAscendingNode',
      pluto: 'plutoAscendingNode',
      halleys: 'halleysAscendingNode',
      eros: 'erosAscendingNode'
    };
    const ascNodeProp = ascNodePropertyMap[hierarchyInspector.currentPlanet];
    const ascNodeAngleDeg = ascNodeProp ? (o[ascNodeProp] || 0) : 0;
    const ascNodeAngleRad = ascNodeAngleDeg * Math.PI / 180;

    // Calculate ascending node position in LOCAL coordinates
    // The ascending node angle is in ecliptic longitude (measured from vernal equinox)
    // Our model is 90° rotated (from March 21 to June 21), so we add 90° counterclockwise
    // Original: X = cos(angle), Z = -sin(angle)
    // After 90° CCW rotation: X = -sin(angle), Z = -cos(angle)
    let ascendingNodePos = new THREE.Vector3(
      planeRadius * -Math.sin(ascNodeAngleRad),
      0,
      planeRadius * -Math.cos(ascNodeAngleRad)
    );

    // Descending node is 180° opposite the ascending node
    let descendingNodePos = new THREE.Vector3(
      -ascendingNodePos.x,
      0,
      -ascendingNodePos.z
    );

    // Find highest and lowest points by sampling the orbit
    // These are 90° after the ascending/descending nodes
    const numSamples = 360;
    let highestLocalPos = new THREE.Vector3();
    let lowestLocalPos = new THREE.Vector3();
    let maxWorldY = -Infinity;
    let minWorldY = Infinity;

    for (let i = 0; i < numSamples; i++) {
      const angle = (i / numSamples) * Math.PI * 2;

      // Point on LOCAL orbital plane (flat circle at local y=0)
      const pLocal = new THREE.Vector3(planeRadius * Math.cos(angle), 0, planeRadius * Math.sin(angle));

      // Transform to WORLD space to check ecliptic position
      const pWorld = pLocal.clone().applyMatrix4(localToWorld);

      // Track highest and lowest points (in WORLD y), but store LOCAL positions for markers
      if (pWorld.y > maxWorldY) {
        maxWorldY = pWorld.y;
        highestLocalPos.copy(pLocal);
      }
      if (pWorld.y < minWorldY) {
        minWorldY = pWorld.y;
        lowestLocalPos.copy(pLocal);
      }
    }

    // ===== BUILD THE ORBITAL PLANE WITH TWO COLORED HALVES =====
    // Geometry is FLAT in LOCAL space (y=0). The parent transform tilts it in world.
    // We color segments based on their WORLD y position (above/below ecliptic).

    // Generate points for the orbit outline (LOCAL y=0 plane)
    const numPoints = 64;
    const orbitPoints = [];        // LOCAL positions for geometry
    const orbitPointsWorld = [];   // WORLD positions for coloring logic
    for (let i = 0; i <= numPoints; i++) {
      const angle = (i / numPoints) * Math.PI * 2;
      const localPoint = new THREE.Vector3(
        planeRadius * Math.cos(angle),
        0,
        planeRadius * Math.sin(angle)
      );
      orbitPoints.push(localPoint);
      orbitPointsWorld.push(localPoint.clone().applyMatrix4(localToWorld));
    }

    // Create the tilted orbit outline - WHITE LINE
    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
    const orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
    const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
    hierarchyInspector.inclinationPlane.add(orbitLine);

    // Create two half-disc meshes for ABOVE and BELOW ecliptic portions
    // Geometry uses LOCAL positions, but we check WORLD y to determine coloring

    // Helper function to create a half-disc mesh
    // localPoints: positions for geometry (in local space)
    // worldPoints: positions for above/below check (in world space)
    const createHalfDisc = (localPoints, worldPoints, color, isAbove) => {
      const vertices = [];
      const indices = [];
      const center = new THREE.Vector3(0, 0, 0);

      // Add center point (local origin)
      vertices.push(center.x, center.y, center.z);

      // Add edge points from LOCAL positions (for geometry)
      for (let i = 0; i < localPoints.length; i++) {
        const p = localPoints[i];
        vertices.push(p.x, p.y, p.z);
      }

      // Create triangles from center to each pair of adjacent points
      // Use WORLD y to determine if segment is above/below ecliptic
      for (let i = 1; i < localPoints.length; i++) {
        const p1World = worldPoints[i - 1];
        const p2World = worldPoints[i];

        // Check if midpoint of this segment is above or below WORLD ecliptic (y=0)
        const midWorldY = (p1World.y + p2World.y) / 2;
        const segmentIsAbove = midWorldY > 0;

        if (segmentIsAbove === isAbove) {
          indices.push(0, i, i + 1);
        }
      }

      if (indices.length === 0) return null;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      const material = new THREE.MeshBasicMaterial({
        color: color,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.3
      });

      return new THREE.Mesh(geometry, material);
    };

    // Create GREEN half for segments ABOVE world ecliptic (world y > 0)
    const aboveHalf = createHalfDisc(orbitPoints, orbitPointsWorld, 0x00ff00, true);
    if (aboveHalf) {
      hierarchyInspector.inclinationPlane.add(aboveHalf);
      hierarchyInspector.aboveHalfPlane = aboveHalf;
    }

    // Create RED half for segments BELOW world ecliptic (world y < 0)
    const belowHalf = createHalfDisc(orbitPoints, orbitPointsWorld, 0xff0000, false);
    if (belowHalf) {
      hierarchyInspector.inclinationPlane.add(belowHalf);
      hierarchyInspector.belowHalfPlane = belowHalf;
    }

    // ===== NODE MARKERS =====

    // Ascending node marker - MAGENTA sphere with UP arrow (planet rises above ecliptic here)
    const ascNodeGeometry = new THREE.SphereGeometry(planeRadius * 0.08, 16, 16);
    const ascNodeMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff }); // Magenta
    hierarchyInspector.ascendingNode = new THREE.Mesh(ascNodeGeometry, ascNodeMaterial);
    hierarchyInspector.ascendingNode.position.copy(ascendingNodePos);
    hierarchyInspector.inclinationPlane.add(hierarchyInspector.ascendingNode);

    // Ascending node arrow pointing up
    const ascArrow = new THREE.ArrowHelper(
      new THREE.Vector3(0, 1, 0),
      ascendingNodePos,
      planeRadius * 0.3,
      0xff00ff, // Magenta
      planeRadius * 0.1,
      planeRadius * 0.05
    );
    hierarchyInspector.inclinationPlane.add(ascArrow);
    hierarchyInspector._ascNodeArrow = ascArrow; // Cache for performance

    // Descending node marker - CYAN sphere with DOWN arrow (planet drops below ecliptic here)
    const descNodeGeometry = new THREE.SphereGeometry(planeRadius * 0.08, 16, 16);
    const descNodeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Cyan
    hierarchyInspector.descendingNode = new THREE.Mesh(descNodeGeometry, descNodeMaterial);
    hierarchyInspector.descendingNode.position.copy(descendingNodePos);
    hierarchyInspector.inclinationPlane.add(hierarchyInspector.descendingNode);

    // Descending node arrow pointing down
    const descArrow = new THREE.ArrowHelper(
      new THREE.Vector3(0, -1, 0),
      descendingNodePos,
      planeRadius * 0.3,
      0x00ffff, // Cyan
      planeRadius * 0.1,
      planeRadius * 0.05
    );
    hierarchyInspector.inclinationPlane.add(descArrow);
    hierarchyInspector._descNodeArrow = descArrow; // Cache for performance

    // Line of nodes (yellow dashed) - connects ascending and descending nodes
    const nodesLineGeometry = new THREE.BufferGeometry().setFromPoints([
      ascendingNodePos, descendingNodePos
    ]);
    const nodesLineMaterial = new THREE.LineDashedMaterial({
      color: 0xffff00,
      linewidth: 2,
      dashSize: 3,
      gapSize: 2
    });
    const nodesLine = new THREE.Line(nodesLineGeometry, nodesLineMaterial);
    nodesLine.computeLineDistances();
    hierarchyInspector.inclinationPlane.add(nodesLine);
    hierarchyInspector._nodesLine = nodesLine; // Cache for performance

    // ===== HIGHEST/LOWEST POINT MARKERS =====
    // Use LOCAL positions (the parent transform will place them correctly in world)

    // Highest point marker - GREEN small sphere (maximum altitude above ecliptic)
    const highGeometry = new THREE.SphereGeometry(planeRadius * 0.05, 12, 12);
    const highMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green
    const highMarker = new THREE.Mesh(highGeometry, highMaterial);
    highMarker.position.copy(highestLocalPos);
    hierarchyInspector.inclinationPlane.add(highMarker);
    hierarchyInspector.highestPointMarker = highMarker;

    const highArrow = new THREE.ArrowHelper(
      new THREE.Vector3(0, 1, 0),  // UP arrow - highest point above ecliptic
      highestLocalPos,
      planeRadius * 0.15,
      0x00ff00, // Green
      planeRadius * 0.05,
      planeRadius * 0.03
    );
    hierarchyInspector.inclinationPlane.add(highArrow);
    hierarchyInspector._highArrow = highArrow;

    // Lowest point marker - RED small sphere (maximum depth below ecliptic)
    const lowGeometry = new THREE.SphereGeometry(planeRadius * 0.05, 12, 12);
    const lowMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red
    const lowMarker = new THREE.Mesh(lowGeometry, lowMaterial);
    lowMarker.position.copy(lowestLocalPos);
    hierarchyInspector.inclinationPlane.add(lowMarker);
    hierarchyInspector.lowestPointMarker = lowMarker;

    const lowArrow = new THREE.ArrowHelper(
      new THREE.Vector3(0, -1, 0),  // DOWN arrow - lowest point below ecliptic
      lowestLocalPos,
      planeRadius * 0.15,
      0xff0000, // Red
      planeRadius * 0.05,
      planeRadius * 0.03
    );
    hierarchyInspector.inclinationPlane.add(lowArrow);
    hierarchyInspector._lowArrow = lowArrow;

    // Add to containerObj (orbitContainer) NOT pivotObj!
    // The inclinationPlane should only inherit the orbital tilt (rotation.x, rotation.z)
    // but NOT the orbit.rotation.y which changes with startPos and animation.
    // The ascending/descending nodes are fixed points in space relative to the ecliptic.
    obj.containerObj.add(hierarchyInspector.inclinationPlane);
  }

  // Arrow from P (FixedPerihelionAtSun) to Sun (Step 4 only)
  // This arrow will be updated dynamically in updateHierarchyLiveData()
  if (hierarchyInspector.helpers.showPerihelionPoint && hierarchyInspector.currentStep === 3) {
    // Get the FixedPerihelionAtSun object for the current planet
    const planetKey = hierarchyInspector.currentPlanet;
    const fixedPerihelionObjects = {
      mercury: mercuryFixedPerihelionAtSun,
      venus: venusFixedPerihelionAtSun,
      mars: marsFixedPerihelionAtSun,
      jupiter: jupiterFixedPerihelionAtSun,
      saturn: saturnFixedPerihelionAtSun,
      uranus: uranusFixedPerihelionAtSun,
      neptune: neptuneFixedPerihelionAtSun,
      pluto: plutoFixedPerihelionAtSun,
      halleys: halleysFixedPerihelionAtSun,
      eros: erosFixedPerihelionAtSun
    };
    const fixedPerihelion = fixedPerihelionObjects[planetKey];

    // Store reference for dynamic updates
    hierarchyInspector._fixedPerihelionObj = fixedPerihelion;
    hierarchyInspector._perihelionArrowScale = scale;

    // Create arrow group that will be updated dynamically
    hierarchyInspector.perihelionArrow = new THREE.Group();

    // Create initial line geometry (will be updated each frame)
    const lineLength = scale * 1.5;
    const lineGeometry = new THREE.BufferGeometry();
    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, -lineLength, 0, 0, lineLength], 3));
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
    hierarchyInspector._perihelionLine = new THREE.Line(lineGeometry, lineMaterial);
    hierarchyInspector.perihelionArrow.add(hierarchyInspector._perihelionLine);

    // Create arrowhead (will be updated each frame)
    hierarchyInspector._perihelionArrowHead = new THREE.ArrowHelper(
      new THREE.Vector3(0, 0, 1),
      new THREE.Vector3(0, 0, lineLength * 0.85),
      lineLength * 0.15,
      0x00ff00,
      lineLength * 0.1,
      lineLength * 0.05
    );
    hierarchyInspector.perihelionArrow.add(hierarchyInspector._perihelionArrowHead);

    // Add to scene (will be positioned in updateHierarchyLiveData)
    scene.add(hierarchyInspector.perihelionArrow);

    // Initialize arrow position immediately to avoid misplacement on first frame
    if (fixedPerihelion) {
      const sourceObj = fixedPerihelion.planetObj || fixedPerihelion.pivotObj;
      if (sourceObj) {
        // Initialize cached vectors
        hierarchyInspector._sunPosVec3 = new THREE.Vector3();
        hierarchyInspector._dirVec3 = new THREE.Vector3();
        hierarchyInspector._defaultDir = new THREE.Vector3(0, 0, 1);
        hierarchyInspector._arrowQuat = new THREE.Quaternion();

        // Get initial positions
        const initialPos = new THREE.Vector3();
        sourceObj.getWorldPosition(initialPos);
        hierarchyInspector.perihelionArrow.position.copy(initialPos);

        // Get Sun's position and calculate direction
        if (sun && sun.pivotObj) {
          sun.pivotObj.getWorldPosition(hierarchyInspector._sunPosVec3);
          hierarchyInspector._dirVec3.subVectors(hierarchyInspector._sunPosVec3, initialPos).normalize();

          // Set initial rotation
          if (hierarchyInspector._dirVec3.lengthSq() > 0.0001) {
            hierarchyInspector._arrowQuat.setFromUnitVectors(hierarchyInspector._defaultDir, hierarchyInspector._dirVec3);
            hierarchyInspector.perihelionArrow.setRotationFromQuaternion(hierarchyInspector._arrowQuat);
          }
        }
      }
    }
  }

  // Anomaly visualization (Step 4 only - RealPerihelionAtSun)
  // Shows True Anomaly and Mean Anomaly as lines/arcs from Sun through orbit
  // Note: currentStep is 0-indexed, so step 4 = index 3
  if (hierarchyInspector.helpers.showAnomalies && hierarchyInspector.currentStep === 3) {
    const anomalyRadius = scale * 0.5; // Match inclination plane radius

    // Arc radii based on the planet's elliptic orbit size (distance between P and orbit center)
    // This makes the visualization proportional to the actual orbit eccentricity
    const ellipticOrbitRadius = obj.orbitRadius || anomalyRadius * 0.5;

    // Only create the anomalyGroup and its contents if it doesn't exist
    // This allows the visualization to persist when toggling OTHER helper checkboxes
    if (!hierarchyInspector.anomalyGroup) {
      // Create a group for anomaly visuals - will be added to scene at Sun's position
      hierarchyInspector.anomalyGroup = new THREE.Group();

      const arcSegments = 32;
      const trueArcRadius = ellipticOrbitRadius * 1.2;   // True anomaly arc (outer)
      const meanArcRadius = ellipticOrbitRadius * 1.0;   // Mean anomaly arc (inner)
      hierarchyInspector._trueArcRadius = trueArcRadius;
      hierarchyInspector._meanArcRadius = meanArcRadius;

      const trueArcGeo = new THREE.BufferGeometry();
      const trueArcPositions = new Float32Array((arcSegments + 1) * 3);
      trueArcGeo.setAttribute('position', new THREE.BufferAttribute(trueArcPositions, 3));
      const trueArcMat = new THREE.LineBasicMaterial({ color: 0xff9800, linewidth: 2 });
      hierarchyInspector.trueAnomalyArc = new THREE.Line(trueArcGeo, trueArcMat);
      hierarchyInspector.anomalyGroup.add(hierarchyInspector.trueAnomalyArc);

      // Mean Anomaly arc (yellow dashed) - shows the uniform angle
      const meanArcGeo = new THREE.BufferGeometry();
      const meanArcPositions = new Float32Array((arcSegments + 1) * 3);
      meanArcGeo.setAttribute('position', new THREE.BufferAttribute(meanArcPositions, 3));
      const meanArcMat = new THREE.LineDashedMaterial({
        color: 0xffeb3b,
        dashSize: 1,
        gapSize: 1,
        linewidth: 2
      });
      hierarchyInspector.meanAnomalyArc = new THREE.Line(meanArcGeo, meanArcMat);
      hierarchyInspector.anomalyGroup.add(hierarchyInspector.meanAnomalyArc);

      // Start marker for True Anomaly arc (small sphere at 0°)
      const trueStartMarkerGeo = new THREE.SphereGeometry(ellipticOrbitRadius * 0.04, 8, 8);
      const trueStartMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff9800 });
      hierarchyInspector.trueAnomalyStartMarker = new THREE.Mesh(trueStartMarkerGeo, trueStartMarkerMat);
      hierarchyInspector.trueAnomalyStartMarker.position.set(trueArcRadius, 0, 0); // At arc start (0°)
      hierarchyInspector.anomalyGroup.add(hierarchyInspector.trueAnomalyStartMarker);

      // Start marker for Mean Anomaly arc (small sphere at 0°)
      const meanStartMarkerGeo = new THREE.SphereGeometry(ellipticOrbitRadius * 0.035, 8, 8);
      const meanStartMarkerMat = new THREE.MeshBasicMaterial({ color: 0xffeb3b });
      hierarchyInspector.meanAnomalyStartMarker = new THREE.Mesh(meanStartMarkerGeo, meanStartMarkerMat);
      hierarchyInspector.meanAnomalyStartMarker.position.set(meanArcRadius, 0, 0); // At arc start (0°)
      hierarchyInspector.anomalyGroup.add(hierarchyInspector.meanAnomalyStartMarker);

      // Direction arrow for True Anomaly (shows counter-clockwise direction)
      // Arrow points in the direction of increasing anomaly (counter-clockwise = -Z in Three.js when starting from +X)
      const trueArrowDir = new THREE.Vector3(0, 0, -1); // Counter-clockwise direction
      hierarchyInspector.trueAnomalyArrow = new THREE.ArrowHelper(
        trueArrowDir,
        new THREE.Vector3(trueArcRadius, 0, 0), // Start at 0° position
        ellipticOrbitRadius * 0.1, // Length
        0xff9800, // Orange
        ellipticOrbitRadius * 0.05, // Head length
        ellipticOrbitRadius * 0.03 // Head width
      );
      hierarchyInspector.anomalyGroup.add(hierarchyInspector.trueAnomalyArrow);

      // Direction arrow for Mean Anomaly (shows counter-clockwise direction)
      const meanArrowDir = new THREE.Vector3(0, 0, -1); // Counter-clockwise direction
      hierarchyInspector.meanAnomalyArrow = new THREE.ArrowHelper(
        meanArrowDir,
        new THREE.Vector3(meanArcRadius, 0, 0), // Start at 0° position
        ellipticOrbitRadius * 0.08, // Length
        0xffeb3b, // Yellow
        ellipticOrbitRadius * 0.04, // Head length
        ellipticOrbitRadius * 0.025 // Head width
      );
      hierarchyInspector.anomalyGroup.add(hierarchyInspector.meanAnomalyArrow);

      // Earth-Sun reference line
      // This shows the direction from Earth through Sun to the opposite side
      // - From Earth to Sun: subtle/transparent
      // - From Sun to beyond mean anomaly circle: same color as mean anomaly
      const earthSunLineLength = meanArcRadius * 1.15; // Extends just past the mean anomaly arc

      // Create a group for the Earth-Sun line (will be rotated to point away from Earth)
      hierarchyInspector.earthSunLine = new THREE.Group();

      // Part 1: Sun to beyond mean anomaly circle (yellow, same as mean anomaly)
      const sunToArcGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(earthSunLineLength, 0, 0)
      ]);
      const sunToArcMat = new THREE.LineBasicMaterial({
        color: 0xffeb3b,
        linewidth: 2
      });
      const sunToArcLine = new THREE.Line(sunToArcGeo, sunToArcMat);
      hierarchyInspector.earthSunLine.add(sunToArcLine);

      // Part 2: Earth to Sun (subtle/transparent) - this will be in negative X direction
      // We'll get the actual Earth distance dynamically, but use a reasonable estimate for now
      const earthToSunGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(-meanArcRadius * 3, 0, 0) // Extends toward Earth (will be clipped by scene)
      ]);
      const earthToSunMat = new THREE.LineBasicMaterial({
        color: 0xffeb3b,
        transparent: true,
        opacity: 0.2
      });
      const earthToSunLine = new THREE.Line(earthToSunGeo, earthToSunMat);
      hierarchyInspector.earthSunLine.add(earthToSunLine);

      hierarchyInspector.anomalyGroup.add(hierarchyInspector.earthSunLine);

      // Add to scene (will be positioned at Sun in updateHierarchyLiveData)
      scene.add(hierarchyInspector.anomalyGroup);
    }

    // P → Planet line (Red) - for Mean Anomaly visualization
    // Shows direction from orbit center (P) to planet position
    // Only create if doesn't already exist (these persist across helper checkbox toggles)
    if (!hierarchyInspector.pToPlanetLine) {
      const pToPlanetGeo = new THREE.BufferGeometry();
      pToPlanetGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
      const pToPlanetMat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
      hierarchyInspector.pToPlanetLine = new THREE.Line(pToPlanetGeo, pToPlanetMat);
      scene.add(hierarchyInspector.pToPlanetLine); // Add to scene, not group (world coords)
    }

    // Sun → Planet line (Amber) - for True Anomaly visualization
    // Shows direction from Sun (focus) to planet position
    if (!hierarchyInspector.sunToPlanetLine) {
      const sunToPlanetGeo = new THREE.BufferGeometry();
      sunToPlanetGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
      const sunToPlanetMat = new THREE.LineBasicMaterial({ color: 0xffbf00, linewidth: 2 });
      hierarchyInspector.sunToPlanetLine = new THREE.Line(sunToPlanetGeo, sunToPlanetMat);
      scene.add(hierarchyInspector.sunToPlanetLine); // Add to scene, not group (world coords)
    }

    // Mean Anomaly Arc (Cyan, dashed) - centered at P (orbit center)
    if (!hierarchyInspector.meanAnomalyArcAtP) {
      const newArcSegments = 64;
      const meanArcAtPGeo = new THREE.BufferGeometry();
      const meanArcAtPPositions = new Float32Array((newArcSegments + 1) * 3);
      meanArcAtPGeo.setAttribute('position', new THREE.BufferAttribute(meanArcAtPPositions, 3));
      const meanArcAtPMat = new THREE.LineDashedMaterial({
        color: 0x00ffff,
        linewidth: 2,
        dashSize: 3,
        gapSize: 2
      });
      hierarchyInspector.meanAnomalyArcAtP = new THREE.Line(meanArcAtPGeo, meanArcAtPMat);
      scene.add(hierarchyInspector.meanAnomalyArcAtP); // Add to scene (world coords)
    }

    // True Anomaly Arc (Amber, solid) - centered at Sun (focus)
    if (!hierarchyInspector.trueAnomalyArcAtSun) {
      const trueArcSegments = 64;
      const trueArcAtSunGeo = new THREE.BufferGeometry();
      const trueArcAtSunPositions = new Float32Array((trueArcSegments + 1) * 3);
      trueArcAtSunGeo.setAttribute('position', new THREE.BufferAttribute(trueArcAtSunPositions, 3));
      const trueArcAtSunMat = new THREE.LineBasicMaterial({ color: 0xffbf00, linewidth: 2 });
      hierarchyInspector.trueAnomalyArcAtSun = new THREE.Line(trueArcAtSunGeo, trueArcAtSunMat);
      scene.add(hierarchyInspector.trueAnomalyArcAtSun); // Add to scene (world coords)
    }

    // Store arc radii for dynamic updates
    if (!hierarchyInspector._meanArcAtPRadius) {
      hierarchyInspector._meanArcAtPRadius = ellipticOrbitRadius * 0.3;
    }
    if (!hierarchyInspector._trueArcAtSunRadius) {
      hierarchyInspector._trueArcAtSunRadius = ellipticOrbitRadius * 0.4;
    }

    // Initialize anomaly group position and arc geometry immediately to avoid misplacement on first frame
    // Position at the SUN (center of solar system), not at the orbital container
    if (sun && sun.pivotObj) {
      sun.pivotObj.getWorldPosition(_hiSunPos);
      hierarchyInspector.anomalyGroup.position.copy(_hiSunPos);

      // Calculate initial rotation to align with perihelion direction
      const planetKey = hierarchyInspector.currentPlanet;
      const initFixedPerihelionObjects = {
        mercury: mercuryFixedPerihelionAtSun,
        venus: venusFixedPerihelionAtSun,
        mars: marsFixedPerihelionAtSun,
        jupiter: jupiterFixedPerihelionAtSun,
        saturn: saturnFixedPerihelionAtSun,
        uranus: uranusFixedPerihelionAtSun,
        neptune: neptuneFixedPerihelionAtSun,
        pluto: plutoFixedPerihelionAtSun,
        halleys: halleysFixedPerihelionAtSun,
        eros: erosFixedPerihelionAtSun
      };
      const initFixedPerihelion = initFixedPerihelionObjects[planetKey];

      if (initFixedPerihelion) {
        const sourceObj = initFixedPerihelion.planetObj || initFixedPerihelion.pivotObj;
        if (sourceObj) {
          sourceObj.getWorldPosition(_hiPerihelionPos);

          // Calculate direction from Sun to Perihelion (P point)
          const dx = _hiPerihelionPos.x - _hiSunPos.x;
          const dz = _hiPerihelionPos.z - _hiSunPos.z;
          // atan2(dz, dx) gives angle from +X to Sun→P direction
          // Add PI to flip 180° so markers are on P side, not Sun side
          const perihelionAngle = Math.atan2(dz, dx);

          // Rotate so local +X points toward P (away from Sun center)
          hierarchyInspector.anomalyGroup.rotation.y = -perihelionAngle + Math.PI;

          // Apply orbital plane tilt
          if (obj && obj.containerObj) {
            hierarchyInspector.anomalyGroup.rotation.x = obj.containerObj.rotation.x;
            hierarchyInspector.anomalyGroup.rotation.z = obj.containerObj.rotation.z;
          }

          // Initialize Earth-Sun line rotation
          if (hierarchyInspector.earthSunLine && earth && earth.pivotObj) {
            earth.pivotObj.getWorldPosition(_hiEarthPos);

            // Direction from Earth to Sun
            const dxE = _hiSunPos.x - _hiEarthPos.x;
            const dzE = _hiSunPos.z - _hiEarthPos.z;
            const earthToSunAngle = Math.atan2(dzE, dxE);

            // Convert to local space
            const groupRotY = hierarchyInspector.anomalyGroup.rotation.y;
            const localAngle = earthToSunAngle + groupRotY;

            hierarchyInspector.earthSunLine.rotation.y = -localAngle;
          }
        }
      }

      // Calculate the Earth-Sun angle in local space for arc initialization
      // This should match what updateHierarchyLiveData does
      let initEarthSunLocalAngle = 0;
      if (earth && earth.pivotObj) {
        earth.pivotObj.getWorldPosition(_hiEarthPos);

        // Direction from Earth to Sun
        const dxE = _hiSunPos.x - _hiEarthPos.x;
        const dzE = _hiSunPos.z - _hiEarthPos.z;
        const earthToSunAngle = Math.atan2(dzE, dxE);

        // Convert to local space
        const groupRotY = hierarchyInspector.anomalyGroup.rotation.y;
        initEarthSunLocalAngle = earthToSunAngle + groupRotY;
      }

      // Use the same angle for both arcs (true anomaly will be adjusted for eccentricity later)
      const trueAnomalyRad = initEarthSunLocalAngle;
      const meanAnomalyRad = initEarthSunLocalAngle;

      // Initialize true anomaly arc geometry
      if (hierarchyInspector.trueAnomalyArc) {
        const arcSegments = 32;
        const arcRadius = hierarchyInspector._trueArcRadius || 50;
        const positions = hierarchyInspector.trueAnomalyArc.geometry.attributes.position.array;
        for (let i = 0; i <= arcSegments; i++) {
          const t = i / arcSegments;
          const angle = t * trueAnomalyRad;
          positions[i * 3] = arcRadius * Math.cos(angle);
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = -arcRadius * Math.sin(angle);
        }
        hierarchyInspector.trueAnomalyArc.geometry.attributes.position.needsUpdate = true;
      }

      // Initialize mean anomaly arc geometry
      if (hierarchyInspector.meanAnomalyArc) {
        const arcSegments = 32;
        const arcRadius = hierarchyInspector._meanArcRadius || 40;
        const positions = hierarchyInspector.meanAnomalyArc.geometry.attributes.position.array;
        for (let i = 0; i <= arcSegments; i++) {
          const t = i / arcSegments;
          const angle = t * meanAnomalyRad;
          positions[i * 3] = arcRadius * Math.cos(angle);
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = -arcRadius * Math.sin(angle);
        }
        hierarchyInspector.meanAnomalyArc.geometry.attributes.position.needsUpdate = true;
        hierarchyInspector.meanAnomalyArc.computeLineDistances();
      }
    }
  }

  // Make RealPerihelionAtSun and FixedPerihelionAtSun visible at Step 4
  // This helps visualize the perihelion movement around the real perihelion point
  if (hierarchyInspector.currentStep === 3) {
    const planetKey = hierarchyInspector.currentPlanet;

    // Mapping of planet keys to their RealPerihelionAtSun and FixedPerihelionAtSun objects
    const perihelionObjects = {
      mercury: { fromSun: mercuryRealPerihelionAtSun, atSun: mercuryFixedPerihelionAtSun },
      venus: { fromSun: venusRealPerihelionAtSun, atSun: venusFixedPerihelionAtSun },
      mars: { fromSun: marsRealPerihelionAtSun, atSun: marsFixedPerihelionAtSun },
      jupiter: { fromSun: jupiterRealPerihelionAtSun, atSun: jupiterFixedPerihelionAtSun },
      saturn: { fromSun: saturnRealPerihelionAtSun, atSun: saturnFixedPerihelionAtSun },
      uranus: { fromSun: uranusRealPerihelionAtSun, atSun: uranusFixedPerihelionAtSun },
      neptune: { fromSun: neptuneRealPerihelionAtSun, atSun: neptuneFixedPerihelionAtSun },
      pluto: { fromSun: plutoRealPerihelionAtSun, atSun: plutoFixedPerihelionAtSun },
      halleys: { fromSun: halleysRealPerihelionAtSun, atSun: halleysFixedPerihelionAtSun },
      eros: { fromSun: erosRealPerihelionAtSun, atSun: erosFixedPerihelionAtSun }
    };

    const objects = perihelionObjects[planetKey];
    if (objects) {
      // Store original state to restore later
      hierarchyInspector._perihelionFromSunOriginalVisible = objects.fromSun.planetObj?.visible;
      hierarchyInspector._perihelionAtSunOriginalVisible = objects.atSun.planetObj?.visible;
      hierarchyInspector._perihelionFromSunOrbitOriginalVisible = objects.fromSun.orbitLineObj?.visible;

      // Make RealPerihelionAtSun visible (purple sphere and orbit line)
      if (objects.fromSun.planetObj) {
        objects.fromSun.planetObj.visible = true;
        // Store original scale and set consistent size (base size varies between objects)
        hierarchyInspector._perihelionFromSunOriginalScale = objects.fromSun.planetObj.scale.clone();
        // Calculate scale to achieve size 1.5: scale = 1.5 / baseSize
        const fromSunScale = 1.5 / (objects.fromSun.size || 1);
        objects.fromSun.planetObj.scale.setScalar(fromSunScale);
        // Change color to purple to distinguish it
        if (objects.fromSun.planetObj.material) {
          hierarchyInspector._perihelionFromSunOriginalColor = objects.fromSun.planetObj.material.color.clone();
          objects.fromSun.planetObj.material.color.setHex(0x9932cc); // Purple
          objects.fromSun.planetObj.material.emissive = new THREE.Color(0x9932cc);
          objects.fromSun.planetObj.material.emissiveIntensity = 0.5;
          // Render on top of scene objects, but below green dot (which has renderOrder 999)
          objects.fromSun.planetObj.material.depthTest = false;
          objects.fromSun.planetObj.renderOrder = 997;
        }

        // Create "P2" label sprite and attach to the planetObj
        // Only show P2 label if purple dot is far enough from green dot
        let showP2Label = true;
        if (objects.atSun.planetObj && objects.fromSun.planetObj) {
          objects.fromSun.planetObj.getWorldPosition(_hiPurpleWorldPos);
          objects.atSun.planetObj.getWorldPosition(_hiGreenWorldPos);
          const distance = _hiPurpleWorldPos.distanceTo(_hiGreenWorldPos);
          // If dots are closer than 3 units, don't show P2 label (green dot would overlap it)
          if (distance < 3) {
            showP2Label = false;
          }
        }

        if (showP2Label) {
          const canvas = document.createElement('canvas');
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 36px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('P2', 32, 32);

          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            depthTest: false,
            transparent: true
          });
          const sprite = new THREE.Sprite(spriteMaterial);
          // Counter-scale to achieve consistent size regardless of parent's scale
          const labelSize = 1.5 / fromSunScale;
          sprite.scale.set(labelSize, labelSize, 1);
          sprite.renderOrder = 998; // Above purple dot (997), below green dot (999)
          objects.fromSun.planetObj.add(sprite);
          hierarchyInspector._perihelionFromSunLabel = sprite;
        }
      }
      // Also make the orbit line visible (this is the elliptical path)
      if (objects.fromSun.orbitLineObj) {
        objects.fromSun.orbitLineObj.visible = true;
        // Store original color and change to purple
        hierarchyInspector._perihelionFromSunOrbitOriginalColor = objects.fromSun.orbitLineObj.material?.color?.clone();
        if (objects.fromSun.orbitLineObj.material) {
          objects.fromSun.orbitLineObj.material.color.setHex(0x9932cc); // Purple
          objects.fromSun.orbitLineObj.material.opacity = 0.8;
        }
      }

      // Make FixedPerihelionAtSun visible (green sphere - the "real" perihelion)
      if (objects.atSun.planetObj) {
        objects.atSun.planetObj.visible = true;
        // Store original scale and set consistent size (base size varies between objects)
        hierarchyInspector._perihelionAtSunOriginalScale = objects.atSun.planetObj.scale.clone();
        // Calculate scale to achieve size 1.5 (slightly bigger): scale = 1.5 / baseSize
        const atSunScale = 1.5 / (objects.atSun.size || 1);
        objects.atSun.planetObj.scale.setScalar(atSunScale);
        // Change color to bright green to distinguish it as the "real" perihelion point
        if (objects.atSun.planetObj.material) {
          hierarchyInspector._perihelionAtSunOriginalColor = objects.atSun.planetObj.material.color.clone();
          objects.atSun.planetObj.material.color.setHex(0x00ff00); // Bright green
          objects.atSun.planetObj.material.emissive = new THREE.Color(0x00ff00);
          objects.atSun.planetObj.material.emissiveIntensity = 0.5;
          // Render on top of other objects, and write to depth buffer so it can occlude P2
          objects.atSun.planetObj.material.depthTest = false;
          objects.atSun.planetObj.material.depthWrite = true;
          objects.atSun.planetObj.renderOrder = 999;
        }

        // Create "P" label sprite and attach to the planetObj
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('P', 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          depthTest: false,
          transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        // Counter-scale to achieve consistent size regardless of parent's scale
        // Parent is scaled by atSunScale, so we divide by it to get consistent world size
        const labelSize = 2.5 / atSunScale;
        sprite.scale.set(labelSize, labelSize, 1);
        sprite.renderOrder = 1001; // Highest - always on top
        objects.atSun.planetObj.add(sprite);
        hierarchyInspector._perihelionLabel = sprite;
      }

      // Store references for cleanup
      hierarchyInspector._perihelionFromSunObj = objects.fromSun;
      hierarchyInspector._perihelionAtSunObj = objects.atSun;
    }
  }

  // Planet locator circle (Step 4 and Step 5 only)
  // Creates a bright circle around the planet to make it easier to find
  if (hierarchyInspector.currentStep === 3 || hierarchyInspector.currentStep === 4) {
    const planetKey = hierarchyInspector.currentPlanet;
    const hierarchy = PLANET_HIERARCHIES[planetKey];
    if (hierarchy) {
      const steps = hierarchy.steps();
      // Get the actual planet (Step 5, index 4)
      const planetStepObj = steps[4]?.obj;
      if (planetStepObj && planetStepObj.planetObj) {
        // Create a circle that will surround the planet
        // Size based on planet's actual size or a minimum visible size
        const planetSize = planetStepObj.size || 1;
        const circleRadius = Math.max(planetSize * 3, 2); // At least 3x planet size, minimum 2 units

        // Create ring geometry (torus for 3D visibility from any angle)
        const ringGeometry = new THREE.TorusGeometry(circleRadius, circleRadius * 0.1, 8, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ffff, // Cyan color
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide,
          depthTest: false // Always visible
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.renderOrder = 998; // Render on top

        // Add to scene (will be positioned in updateHierarchyLiveData)
        scene.add(ring);
        hierarchyInspector._planetLocatorCircle = ring;
        hierarchyInspector._planetLocatorTarget = planetStepObj;

        // Initialize position immediately
        if (planetStepObj.planetObj) {
          planetStepObj.planetObj.getWorldPosition(_hiTempPos);
          ring.position.copy(_hiTempPos);
        }
      }
    }
  }
}

// Clear visual helpers
// Options:
//   forceCleanAnomalies: if true, always clean anomaly elements; if false, only clean if showAnomalies is off or not step 3
function clearVisualHelpers(options = {}) {
  const { forceCleanAnomalies = false } = options;

  // Determine if we should clean anomaly elements
  // Clean them if: forced OR showAnomalies is off OR not on step 3
  const shouldCleanAnomalies = forceCleanAnomalies ||
                               !hierarchyInspector.helpers.showAnomalies ||
                               hierarchyInspector.currentStep !== 3;

  // Restore temporary perihelion visibility (used by step-based camera focus)
  if (hierarchyInspector._tempPerihelionVisible) {
    const prevObj = hierarchyInspector._tempPerihelionVisible;
    if (prevObj.planetObj) {
      prevObj.planetObj.visible = hierarchyInspector._tempPerihelionOriginalVisible ?? false;
    }
    if (prevObj.orbitLineObj) {
      prevObj.orbitLineObj.visible = hierarchyInspector._tempPerihelionOrbitOriginalVisible ?? false;
    }
    hierarchyInspector._tempPerihelionVisible = null;
    hierarchyInspector._tempPerihelionOriginalVisible = null;
    hierarchyInspector._tempPerihelionOrbitOriginalVisible = null;
  }

  if (hierarchyInspector.axesHelper) {
    hierarchyInspector.axesHelper.parent?.remove(hierarchyInspector.axesHelper);
    hierarchyInspector.axesHelper.dispose?.();
    hierarchyInspector.axesHelper = null;
  }
  if (hierarchyInspector.startPosArrow) {
    hierarchyInspector.startPosArrow.parent?.remove(hierarchyInspector.startPosArrow);
    hierarchyInspector.startPosArrow = null;
  }
  if (hierarchyInspector.currentPosArrow) {
    hierarchyInspector.currentPosArrow.parent?.remove(hierarchyInspector.currentPosArrow);
    hierarchyInspector.currentPosArrow = null;
  }
  if (hierarchyInspector.orbitCenterArrow) {
    hierarchyInspector.orbitCenterArrow.parent?.remove(hierarchyInspector.orbitCenterArrow);
    hierarchyInspector.orbitCenterArrow = null;
  }
  if (hierarchyInspector.earthPerihelionArrow) {
    hierarchyInspector.earthPerihelionArrow.parent?.remove(hierarchyInspector.earthPerihelionArrow);
    hierarchyInspector.earthPerihelionArrow.dispose?.();
    hierarchyInspector.earthPerihelionArrow = null;
  }
  if (hierarchyInspector.rotationArrow) {
    hierarchyInspector.rotationArrow.parent?.remove(hierarchyInspector.rotationArrow);
    hierarchyInspector.rotationArrow.geometry?.dispose();
    hierarchyInspector.rotationArrow.material?.dispose();
    hierarchyInspector.rotationArrow = null;
  }
  if (hierarchyInspector.inclinationPlane) {
    hierarchyInspector.inclinationPlane.parent?.remove(hierarchyInspector.inclinationPlane);
    // Dispose all children geometries and materials
    hierarchyInspector.inclinationPlane.traverse((child) => {
      if (child.geometry) child.geometry.dispose();
      if (child.material) child.material.dispose();
    });
    hierarchyInspector.inclinationPlane = null;
    hierarchyInspector.ascendingNode = null;
    hierarchyInspector.descendingNode = null;
    hierarchyInspector.aboveHalfPlane = null;
    hierarchyInspector.belowHalfPlane = null;
    hierarchyInspector.highestPointMarker = null;
    hierarchyInspector.lowestPointMarker = null;
    hierarchyInspector._highArrow = null;
    hierarchyInspector._lowArrow = null;
    hierarchyInspector._ascNodeArrow = null;
    hierarchyInspector._descNodeArrow = null;
    hierarchyInspector._nodesLine = null;
    // Reset tilt cache to force recalculation on next creation
    _lastAscNodeTiltA = null;
    _lastAscNodeTiltB = null;
  }
  if (hierarchyInspector.perihelionDot) {
    hierarchyInspector.perihelionDot.parent?.remove(hierarchyInspector.perihelionDot);
    hierarchyInspector.perihelionDot.geometry?.dispose();
    hierarchyInspector.perihelionDot.material?.dispose();
    hierarchyInspector.perihelionDot = null;
  }
  if (hierarchyInspector.perihelionArrow) {
    hierarchyInspector.perihelionArrow.parent?.remove(hierarchyInspector.perihelionArrow);
    hierarchyInspector.perihelionArrow = null;
    hierarchyInspector._perihelionLine = null;
    hierarchyInspector._perihelionArrowHead = null;
    hierarchyInspector._fixedPerihelionObj = null;
    hierarchyInspector._perihelionArrowScale = null;
    // Clear cached vectors (they'll be recreated if needed)
    hierarchyInspector._sunPosVec3 = null;
    hierarchyInspector._dirVec3 = null;
    hierarchyInspector._defaultDir = null;
    hierarchyInspector._arrowQuat = null;
  }
  // Clean up anomaly visualization elements only when appropriate
  // (when showAnomalies is off, not on step 3, or forced)
  if (shouldCleanAnomalies && hierarchyInspector.anomalyGroup) {
    hierarchyInspector.anomalyGroup.parent?.remove(hierarchyInspector.anomalyGroup);
    hierarchyInspector.anomalyGroup.traverse((child) => {
      if (child.geometry) child.geometry.dispose();
      if (child.material) child.material.dispose();
    });
    hierarchyInspector.anomalyGroup = null;
    hierarchyInspector.trueAnomalyArc = null;
    hierarchyInspector.meanAnomalyArc = null;
    hierarchyInspector.trueAnomalyStartMarker = null;
    hierarchyInspector.meanAnomalyStartMarker = null;
    hierarchyInspector.trueAnomalyArrow = null;
    hierarchyInspector.meanAnomalyArrow = null;
    hierarchyInspector.earthSunLine = null;
    hierarchyInspector._trueArcRadius = null;
    hierarchyInspector._meanArcRadius = null;
  }
  // Clean up new anomaly visualization elements (added to scene directly)
  // Only clean when shouldCleanAnomalies is true
  if (shouldCleanAnomalies) {
    if (hierarchyInspector.pToPlanetLine) {
      hierarchyInspector.pToPlanetLine.parent?.remove(hierarchyInspector.pToPlanetLine);
      hierarchyInspector.pToPlanetLine.geometry?.dispose();
      hierarchyInspector.pToPlanetLine.material?.dispose();
      hierarchyInspector.pToPlanetLine = null;
    }
    if (hierarchyInspector.sunToPlanetLine) {
      hierarchyInspector.sunToPlanetLine.parent?.remove(hierarchyInspector.sunToPlanetLine);
      hierarchyInspector.sunToPlanetLine.geometry?.dispose();
      hierarchyInspector.sunToPlanetLine.material?.dispose();
      hierarchyInspector.sunToPlanetLine = null;
    }
    if (hierarchyInspector.meanAnomalyArcAtP) {
      hierarchyInspector.meanAnomalyArcAtP.parent?.remove(hierarchyInspector.meanAnomalyArcAtP);
      hierarchyInspector.meanAnomalyArcAtP.geometry?.dispose();
      hierarchyInspector.meanAnomalyArcAtP.material?.dispose();
      hierarchyInspector.meanAnomalyArcAtP = null;
    }
    if (hierarchyInspector.trueAnomalyArcAtSun) {
      hierarchyInspector.trueAnomalyArcAtSun.parent?.remove(hierarchyInspector.trueAnomalyArcAtSun);
      hierarchyInspector.trueAnomalyArcAtSun.geometry?.dispose();
      hierarchyInspector.trueAnomalyArcAtSun.material?.dispose();
      hierarchyInspector.trueAnomalyArcAtSun = null;
    }
    hierarchyInspector._meanArcAtPRadius = null;
    hierarchyInspector._trueArcAtSunRadius = null;
  }

  // Restore original state of RealPerihelionAtSun and FixedPerihelionAtSun objects
  if (hierarchyInspector._perihelionFromSunObj) {
    const obj = hierarchyInspector._perihelionFromSunObj;
    if (obj.planetObj) {
      obj.planetObj.visible = hierarchyInspector._perihelionFromSunOriginalVisible ?? false;
      // Restore original scale
      if (hierarchyInspector._perihelionFromSunOriginalScale) {
        obj.planetObj.scale.copy(hierarchyInspector._perihelionFromSunOriginalScale);
      }
      // Restore original color and depth settings
      if (hierarchyInspector._perihelionFromSunOriginalColor && obj.planetObj.material) {
        obj.planetObj.material.color.copy(hierarchyInspector._perihelionFromSunOriginalColor);
        obj.planetObj.material.emissive = new THREE.Color(0x000000);
        obj.planetObj.material.emissiveIntensity = 0;
        obj.planetObj.material.depthTest = true;
        obj.planetObj.renderOrder = 0;
      }
    }
    // Restore orbit line visibility and color
    if (obj.orbitLineObj) {
      obj.orbitLineObj.visible = hierarchyInspector._perihelionFromSunOrbitOriginalVisible ?? false;
      if (hierarchyInspector._perihelionFromSunOrbitOriginalColor && obj.orbitLineObj.material) {
        obj.orbitLineObj.material.color.copy(hierarchyInspector._perihelionFromSunOrbitOriginalColor);
        obj.orbitLineObj.material.opacity = 0.4;
      }
    }
    hierarchyInspector._perihelionFromSunObj = null;
    hierarchyInspector._perihelionFromSunOriginalVisible = null;
    hierarchyInspector._perihelionFromSunOriginalScale = null;
    hierarchyInspector._perihelionFromSunOriginalColor = null;
    hierarchyInspector._perihelionFromSunOrbitOriginalVisible = null;
    hierarchyInspector._perihelionFromSunOrbitOriginalColor = null;
  }
  // Remove RealPerihelionAtSun label sprite (P2)
  if (hierarchyInspector._perihelionFromSunLabel) {
    hierarchyInspector._perihelionFromSunLabel.parent?.remove(hierarchyInspector._perihelionFromSunLabel);
    hierarchyInspector._perihelionFromSunLabel.material?.map?.dispose();
    hierarchyInspector._perihelionFromSunLabel.material?.dispose();
    hierarchyInspector._perihelionFromSunLabel = null;
  }
  if (hierarchyInspector._perihelionAtSunObj) {
    const obj = hierarchyInspector._perihelionAtSunObj;
    if (obj.planetObj) {
      obj.planetObj.visible = hierarchyInspector._perihelionAtSunOriginalVisible ?? false;
      // Restore original scale
      if (hierarchyInspector._perihelionAtSunOriginalScale) {
        obj.planetObj.scale.copy(hierarchyInspector._perihelionAtSunOriginalScale);
      }
      // Restore original color and depth settings
      if (hierarchyInspector._perihelionAtSunOriginalColor && obj.planetObj.material) {
        obj.planetObj.material.color.copy(hierarchyInspector._perihelionAtSunOriginalColor);
        obj.planetObj.material.emissive = new THREE.Color(0x000000);
        obj.planetObj.material.emissiveIntensity = 0;
        obj.planetObj.material.depthTest = true;
        obj.planetObj.renderOrder = 0;
      }
    }
    hierarchyInspector._perihelionAtSunObj = null;
    hierarchyInspector._perihelionAtSunOriginalVisible = null;
    hierarchyInspector._perihelionAtSunOriginalScale = null;
    hierarchyInspector._perihelionAtSunOriginalColor = null;
  }
  // Remove perihelion label sprite
  if (hierarchyInspector._perihelionLabel) {
    hierarchyInspector._perihelionLabel.parent?.remove(hierarchyInspector._perihelionLabel);
    hierarchyInspector._perihelionLabel.material?.map?.dispose();
    hierarchyInspector._perihelionLabel.material?.dispose();
    hierarchyInspector._perihelionLabel = null;
  }
  // Remove planet locator circle
  if (hierarchyInspector._planetLocatorCircle) {
    hierarchyInspector._planetLocatorCircle.parent?.remove(hierarchyInspector._planetLocatorCircle);
    hierarchyInspector._planetLocatorCircle.geometry?.dispose();
    hierarchyInspector._planetLocatorCircle.material?.dispose();
    hierarchyInspector._planetLocatorCircle = null;
    hierarchyInspector._planetLocatorTarget = null;
  }
}

// Focus camera on the current step's pivot object with step-aware positioning
function focusOnStepObject(stepData) {
  const obj = stepData.obj;
  if (!obj.pivotObj) return;

  const step = hierarchyInspector.currentStep;
  const planetKey = hierarchyInspector.currentPlanet;
  const planetData = PLANET_HIERARCHIES[planetKey];

  // Get perihelion object for this planet
  const perihelionObj = planetData.perihelionOf?.();

  // Clean up any previously temporarily shown perihelion
  if (hierarchyInspector._tempPerihelionVisible) {
    const prevObj = hierarchyInspector._tempPerihelionVisible;
    if (prevObj.planetObj) {
      prevObj.planetObj.visible = hierarchyInspector._tempPerihelionOriginalVisible ?? false;
    }
    if (prevObj.orbitLineObj) {
      prevObj.orbitLineObj.visible = hierarchyInspector._tempPerihelionOrbitOriginalVisible ?? false;
    }
    hierarchyInspector._tempPerihelionVisible = null;
    hierarchyInspector._tempPerihelionOriginalVisible = null;
    hierarchyInspector._tempPerihelionOrbitOriginalVisible = null;
  }

  let targetPos = new THREE.Vector3();
  let viewDistance;
  let focusObj = null;  // The object to track in animation loop

  if (step === 0) {
    // Step 1 (index 0): Focus on earthPerihelionFromEarth
    if (earthPerihelionFromEarth?.pivotObj) {
      // Store original visibility and make visible temporarily
      hierarchyInspector._tempPerihelionOriginalVisible = earthPerihelionFromEarth.planetObj?.visible;
      hierarchyInspector._tempPerihelionOrbitOriginalVisible = earthPerihelionFromEarth.orbitLineObj?.visible;
      hierarchyInspector._tempPerihelionVisible = earthPerihelionFromEarth;

      if (earthPerihelionFromEarth.planetObj) earthPerihelionFromEarth.planetObj.visible = true;
      if (earthPerihelionFromEarth.orbitLineObj) earthPerihelionFromEarth.orbitLineObj.visible = true;

      focusObj = earthPerihelionFromEarth;
      earthPerihelionFromEarth.pivotObj.updateMatrixWorld(true);
      earthPerihelionFromEarth.pivotObj.getWorldPosition(targetPos);
      viewDistance = Math.max(100, (earthPerihelionFromEarth.orbitRadius || 50) * 2);
    } else {
      // Fallback to step object
      focusObj = obj;
      obj.pivotObj.updateMatrixWorld(true);
      obj.pivotObj.getWorldPosition(targetPos);
      viewDistance = Math.max(100, (obj.orbitRadius || 50) * 2);
    }
  } else if (step <= 2) {
    // Steps 2, 3 (indices 1, 2): Focus on PERIHELION object
    if (perihelionObj?.pivotObj) {
      // Store original visibility and make visible temporarily
      hierarchyInspector._tempPerihelionOriginalVisible = perihelionObj.planetObj?.visible;
      hierarchyInspector._tempPerihelionOrbitOriginalVisible = perihelionObj.orbitLineObj?.visible;
      hierarchyInspector._tempPerihelionVisible = perihelionObj;

      if (perihelionObj.planetObj) perihelionObj.planetObj.visible = true;
      if (perihelionObj.orbitLineObj) perihelionObj.orbitLineObj.visible = true;

      focusObj = perihelionObj;
      perihelionObj.pivotObj.updateMatrixWorld(true);
      perihelionObj.pivotObj.getWorldPosition(targetPos);
      viewDistance = Math.max(100, (perihelionObj.orbitRadius || 50) * 2);
    } else {
      // Fallback to step object if no perihelion
      focusObj = obj;
      obj.pivotObj.updateMatrixWorld(true);
      obj.pivotObj.getWorldPosition(targetPos);
      viewDistance = Math.max(100, (obj.orbitRadius || 50) * 2);
    }
  } else if (step === 3) {
    // Step 4 (index 3): Focus on Sun
    focusObj = sun;
    sun.pivotObj.updateMatrixWorld(true);
    sun.pivotObj.getWorldPosition(targetPos);
    viewDistance = Math.max(200, (obj.orbitRadius || 100) * 2);
  } else {
    // Step 5 (index 4): Focus on planet
    focusObj = obj;
    obj.pivotObj.updateMatrixWorld(true);
    obj.pivotObj.getWorldPosition(targetPos);
    viewDistance = Math.max(100, (obj.orbitRadius || 50) * 2);
  }

  // Enable hierarchy inspector camera control
  hierarchyInspector._cameraControlActive = true;
  hierarchyInspector._cameraTarget = focusObj;

  // Set camera target
  controls.target.copy(targetPos);

  // Position camera based on step
  if (step <= 3) {
    // Steps 1-4: Looking down on celestial plane (Y+ is up, Earth below, Sun on top)
    camera.position.set(targetPos.x, targetPos.y + viewDistance, targetPos.z);
  } else {
    // Step 5: Looking from Sun towards planet (camera behind planet, looking towards Sun)
    const sunPos = new THREE.Vector3();
    sun.pivotObj.updateMatrixWorld(true);
    sun.pivotObj.getWorldPosition(sunPos);

    const direction = new THREE.Vector3().subVectors(targetPos, sunPos).normalize();
    camera.position.copy(targetPos).add(direction.multiplyScalar(viewDistance));
  }

  // Update controls
  controls.minDistance = 0;
  controls.maxDistance = Infinity;
  controls.update();

  // Reset near plane to default for unrestricted zooming
  camera.near = 0.1;
  camera.updateProjectionMatrix();
}

// Build hierarchy tree HTML
function buildHierarchyTree(steps, currentIdx) {
  let html = '<span style="color:rgba(255,255,255,0.4)">startingPoint</span>\n';
  const indent = '    ';
  steps.forEach((step, idx) => {
    const prefix = indent.repeat(idx + 1) + '\u2514\u2500\u2500 ';
    if (idx === currentIdx) {
      html += `${prefix}<span class="hi-current">\u2605 ${step.name}</span>  \u2190 CURRENT\n`;
    } else {
      html += `${prefix}${step.name}\n`;
    }
  });
  return html;
}

// Update inspector display
function updateInspectorDisplay() {
  const panel = hierarchyInspector.panel;
  if (!panel) return;

  const planetData = PLANET_HIERARCHIES[hierarchyInspector.currentPlanet];
  if (!planetData) return;

  const steps = planetData.steps();
  const stepData = steps[hierarchyInspector.currentStep];
  const obj = stepData.obj;

  // Update step indicator
  panel.querySelector('.hi-step-indicator').textContent =
    `STEP ${hierarchyInspector.currentStep + 1} of ${steps.length}: ${obj.name || stepData.name}`;

  // Step 4 (index 3): Turn off some helpers by default for cleaner anomaly visualization
  const isStep4 = hierarchyInspector.currentStep === 3;
  const step4OffHelpers = ['showAxes', 'showStartPos', 'showRotationDir'];
  step4OffHelpers.forEach(helper => {
    const checkbox = panel.querySelector(`input[data-helper="${helper}"]`);
    if (checkbox) {
      if (isStep4) {
        checkbox.checked = false;
        hierarchyInspector.helpers[helper] = false;
      } else {
        checkbox.checked = true;
        hierarchyInspector.helpers[helper] = true;
      }
    }
  });

  // Show/hide Visual Legend section (only visible on Step 4)
  const legendSection = panel.querySelector('.hi-legend-section');
  if (legendSection) {
    legendSection.style.display = isStep4 ? 'block' : 'none';
  }

  // Show/hide Live Data section (only visible on Step 4)
  const liveSection = panel.querySelector('.hi-live-section');
  if (liveSection) {
    liveSection.style.display = isStep4 ? 'block' : 'none';
  }

  // Show/hide Report section (only visible on Step 5 - index 4)
  const isStep5 = hierarchyInspector.currentStep === 4;
  const reportSection = panel.querySelector('.hi-report-section');
  if (reportSection) {
    reportSection.style.display = isStep5 ? 'block' : 'none';
    if (isStep5) {
      // Generate and display report for Step 5
      generateAndDisplayReport(hierarchyInspector.currentPlanet);
    }
  }

  // Show/hide Step 4 specific helper checkboxes
  const step4Helpers = ['showOrbitCenter', 'showInclinationPlane', 'showPerihelionPoint', 'showAnomalies'];
  step4Helpers.forEach(helper => {
    const label = panel.querySelector(`input[data-helper="${helper}"]`)?.parentElement;
    if (label) {
      label.style.display = isStep4 ? '' : 'none';
    }
  });
  // Also hide the solar period section when not on Step 4
  const solarPeriodSection = panel.querySelector('.hi-solar-period-section');
  if (solarPeriodSection && !isStep4) {
    solarPeriodSection.style.display = 'none';
  }

  // Calculate derived values
  const periodYears = speedToPeriod(obj.speed);
  const arcsecPerCentury = periodToArcsecPerCentury(periodYears);
  const currentRotation = obj.orbitObj?.rotation?.y ?? 0;
  if (obj.pivotObj) obj.pivotObj.getWorldPosition(_hiWorldPos);

  // Build settings section
  const settingsHtml = `
    <div class="hi-props">
      <span class="hi-key">name</span><span class="hi-val">"${obj.name || 'unnamed'}"</span>
      <span class="hi-key">startPos</span><span class="hi-val">${formatNum(obj.startPos, 2)}\u00b0</span>
      <span class="hi-key">speed (raw)</span><span class="hi-val">${formatNum(obj.speed, 8)} rad/yr</span>
      <span class="hi-key">speed (period)</span><span class="hi-val">${formatNum(periodYears, 2)} years</span>
      <span class="hi-key">speed (arcsec)</span><span class="hi-val">${formatNum(arcsecPerCentury, 2)} "/century</span>
      <span class="hi-key">tilt</span><span class="hi-val">${formatNum(obj.tilt, 2)}\u00b0</span>
      <span class="hi-key">orbitRadius</span><span class="hi-val">${formatNum(obj.orbitRadius, 4)}</span>
      <span class="hi-key">orbitCenter</span><span class="hi-val">(${formatNum(obj.orbitCentera, 4)}, ${formatNum(obj.orbitCenterb, 4)}, ${formatNum(obj.orbitCenterc, 4)})</span>
      <span class="hi-key">orbitTilt</span><span class="hi-val">(${formatNum(obj.orbitTilta, 2)}\u00b0, ${formatNum(obj.orbitTiltb, 2)}\u00b0)</span>
      <span class="hi-key">visible</span><span class="hi-val">${obj.visible}</span>
      <span class="hi-key">isNotPhysical</span><span class="hi-val">${obj.isNotPhysicalObject ?? false}</span>
    </div>
  `;
  panel.querySelector('.hi-settings-content').innerHTML = settingsHtml;

  // Build runtime section
  const runtimeHtml = `
    <div class="hi-props">
      <span class="hi-key">Current rotation</span><span class="hi-val">${formatNum(currentRotation, 4)} rad (${formatNum(currentRotation * 180 / Math.PI, 2)}\u00b0)</span>
      <span class="hi-key">World position</span><span class="hi-val">(${formatNum(_hiWorldPos.x, 2)}, ${formatNum(_hiWorldPos.y, 2)}, ${formatNum(_hiWorldPos.z, 2)})</span>
      <span class="hi-key">containerObj</span><span class="hi-val">${obj.containerObj ? '\u2713 exists' : '\u2717 missing'}</span>
      <span class="hi-key">orbitObj</span><span class="hi-val">${obj.orbitObj ? '\u2713 exists' : '\u2717 missing'}</span>
      <span class="hi-key">pivotObj</span><span class="hi-val">${obj.pivotObj ? '\u2713 exists' : '\u2717 missing'}</span>
      <span class="hi-key">planetObj</span><span class="hi-val">${obj.planetObj ? '\u2713 exists' : '\u2717 missing'}</span>
    </div>
  `;
  panel.querySelector('.hi-runtime-content').innerHTML = runtimeHtml;

  // Build validation section
  const issues = validateStep(stepData, hierarchyInspector.currentStep, steps);
  let validationHtml = '';
  issues.forEach(issue => {
    const icon = issue.type === 'valid' ? '\u2713' : issue.type === 'warning' ? '\u26a0' : issue.type === 'info' ? '\u2139' : issue.type === 'reference' ? '\u2192' : '\u2717';
    validationHtml += `<div class="hi-validation-item ${issue.type}"><span class="hi-validation-icon">${icon}</span>${issue.msg}</div>`;
  });
  panel.querySelector('.hi-validation-content').innerHTML = validationHtml;

  // Build hierarchy tree
  panel.querySelector('.hi-tree').innerHTML = buildHierarchyTree(steps, hierarchyInspector.currentStep);

  // Clear Live Data section when not on Step 4 (the section is hidden, but reset cached elements)
  if (hierarchyInspector.currentStep !== 3) {
    _liveDataElements = null;
  }
  // If on Step 4, updateHierarchyLiveData() will populate it

  // Update nav buttons
  panel.querySelector('.hi-prev-btn').disabled = hierarchyInspector.currentStep === 0;
  panel.querySelector('.hi-next-btn').disabled = hierarchyInspector.currentStep === steps.length - 1;

  // Always show visual helpers and focus on the object when panel is open
  createVisualHelpers(stepData);
  focusOnStepObject(stepData);

  // Update highlight button state
  const highlightBtn = panel.querySelector('.hi-highlight-btn');
  highlightBtn.classList.add('active');
  highlightBtn.textContent = 'Hide Helpers';
  hierarchyInspector.highlightActive = true;
}

// Create inspector panel HTML
function createInspectorPanel() {
  const panel = document.createElement('div');
  panel.id = 'hierarchyInspector';
  panel.innerHTML = `
    <div class="hi-header">
      <h2>Planet Inspector</h2>
      <div class="hi-close" title="Close"></div>
    </div>
    <div class="hi-selector">
      <label>Planet:</label>
      <select class="hi-planet-select">
        ${Object.entries(PLANET_HIERARCHIES).map(([key, val]) =>
          `<option value="${key}">${val.label}</option>`
        ).join('')}
      </select>
    </div>
    <div class="hi-step-indicator">STEP 1 of 5</div>
    <div class="hi-body">
      <div class="hi-section">
        <div class="hi-section-title">Settings</div>
        <div class="hi-settings-content"></div>
      </div>
      <div class="hi-section">
        <div class="hi-section-title">Runtime State</div>
        <div class="hi-runtime-content"></div>
      </div>
      <div class="hi-section">
        <div class="hi-section-title">Validation</div>
        <div class="hi-validation-content"></div>
      </div>
      <div class="hi-section hi-live-section" style="display: none;">
        <div class="hi-section-title">Live Data <span style="color:#4caf50; font-size:10px;">(updates in real-time)</span></div>
        <div class="hi-live-content" style="font-family: var(--pl-mono-font); color: #4caf50;"></div>
      </div>
      <div class="hi-section hi-report-section" style="display: none;">
        <div class="hi-section-title">Position Report <span style="color:#64b5f6; font-size:10px;">(Step 5)</span></div>
        <div class="hi-report-content">
          <div class="hi-report-loading">Generating report...</div>
          <pre class="hi-report"></pre>
          <div class="hi-report-buttons">
            <button class="hi-report-btn download">Download Excel</button>
            <button class="hi-report-btn copy">Copy Report</button>
            <label class="hi-report-checkbox-label">
              <input type="checkbox" class="hi-report-show-all">
              <span>Show all results</span>
            </label>
          </div>
        </div>
      </div>
      <div class="hi-section hi-legend-section" style="display: none;">
        <div class="hi-section-title">Visual Legend</div>
        <div class="hi-legend-content" style="font-size: 11px; line-height: 1.6;">
          <div><span style="color:#00ff00">GREEN</span> half-plane: Above ecliptic</div>
          <div><span style="color:#ff0000">RED</span> half-plane: Below ecliptic</div>
          <div><span style="color:#ff00ff">Magenta</span> sphere ↑: Ascending node</div>
          <div><span style="color:#00ffff">Cyan</span> sphere ↓: Descending node</div>
          <div><span style="color:#00ff00">Green</span> sphere ↑: Highest point (max north)</div>
          <div><span style="color:#ff0000">Red</span> sphere ↓: Lowest point (max south)</div>
          <div><span style="color:#800080">Purple</span> line →: Current angle perihelion to Sun</div>
          <div><span style="color:#00ffff">Cyan</span> arrow →: Mean Anomaly angle to perihelion</div>
          <div><span style="color:#ffbf00">Amber</span> arrow →: True Anomaly angle to perihelion</div>
          <div>P point →: Fixed perihelion point</div>
          <div>P2 point →: Real perihelion point (ellipse)</div>
        </div>
      </div>
      <div class="hi-section">
        <div class="hi-section-title">Hierarchy Path</div>
        <div class="hi-tree"></div>
      </div>
      <div class="hi-helpers">
        <div class="hi-helpers-title">Visual Helpers</div>
        <label class="hi-helper-row"><input type="checkbox" data-helper="showAxes" checked> Show Axes (XYZ)</label>
        <label class="hi-helper-row"><input type="checkbox" data-helper="showStartPos" checked> Show StartPos Direction</label>
        <label class="hi-helper-row"><input type="checkbox" data-helper="showRotationDir" checked> Show Rotation Direction</label>
        <label class="hi-helper-row"><input type="checkbox" data-helper="showOrbitCenter"> Show Startpos Reference Information (Step 4)</label>
        <div class="hi-solar-period-section" style="display: none; margin-left: 20px; margin-bottom: 8px; padding: 8px; background: rgba(0,255,255,0.05); border-left: 2px solid #00ffff; font-size: 11px;">
          <div style="color: rgba(255,255,255,0.5); font-size: 10px; margin-bottom: 4px;">SOLAR PERIOD REFERENCE</div>
          <div style="color: rgba(255,255,255,0.4); font-size: 9px; margin-bottom: 6px;">(Planet's position on its orbit around the Sun)</div>
          <div style="display: grid; grid-template-columns: 1fr auto; gap: 2px 8px;">
            <span style="color: #00ffff;">Reference angle on Solar period</span>
            <span data-id="refAngleHelper" style="color: #00ffff;"></span>
            <span style="color: rgba(255,255,255,0.6);">Orbit Period Solar</span>
            <span data-id="orbitPeriodSolarHelper" style="color: rgba(255,255,255,0.6);"></span>
            <span style="color: #00ffff;">Days before next alignment</span>
            <span data-id="daysUntilAlignmentHelper" style="color: #00ffff;"></span>
          </div>
          <div style="color: rgba(255,255,255,0.4); font-size: 9px; margin-top: 4px;">(planet alignment with the cyan arrow = start of planet orbit)</div>
        </div>
        <label class="hi-helper-row"><input type="checkbox" data-helper="showInclinationPlane" checked> Show Inclination Plane (Step 4)</label>
        <label class="hi-helper-row"><input type="checkbox" data-helper="showPerihelionPoint" checked> Show Perihelion Point & Arrow (Step 4)</label>
        <label class="hi-helper-row"><input type="checkbox" data-helper="showAnomalies" checked> Show Anomalies Visualization (Step 4)</label>
      </div>
    </div>
    <div class="hi-footer">
      <button class="hi-nav-btn hi-prev-btn">\u25c0 Prev</button>
      <button class="hi-nav-btn hi-highlight-btn">Highlight in Scene</button>
      <button class="hi-nav-btn hi-next-btn">Next \u25b6</button>
    </div>
  `;
  document.body.appendChild(panel);

  // Event listeners
  panel.querySelector('.hi-close').addEventListener('click', closeHierarchyInspector);

  panel.querySelector('.hi-planet-select').addEventListener('change', (e) => {
    hierarchyInspector.currentPlanet = e.target.value;
    hierarchyInspector.currentStep = 0;
    updateInspectorDisplay();
  });

  panel.querySelector('.hi-prev-btn').addEventListener('click', () => {
    if (hierarchyInspector.currentStep > 0) {
      hierarchyInspector.currentStep--;
      updateInspectorDisplay();
    }
  });

  panel.querySelector('.hi-next-btn').addEventListener('click', () => {
    const steps = PLANET_HIERARCHIES[hierarchyInspector.currentPlanet].steps();
    if (hierarchyInspector.currentStep < steps.length - 1) {
      hierarchyInspector.currentStep++;
      updateInspectorDisplay();
    }
  });

  panel.querySelector('.hi-highlight-btn').addEventListener('click', (e) => {
    hierarchyInspector.highlightActive = !hierarchyInspector.highlightActive;
    e.target.classList.toggle('active', hierarchyInspector.highlightActive);
    e.target.textContent = hierarchyInspector.highlightActive ? 'Hide Helpers' : 'Highlight in Scene';
    if (hierarchyInspector.highlightActive) {
      const steps = PLANET_HIERARCHIES[hierarchyInspector.currentPlanet].steps();
      createVisualHelpers(steps[hierarchyInspector.currentStep]);
    } else {
      // Highlight turned off - force clean everything
      clearVisualHelpers({ forceCleanAnomalies: true });
    }
  });

  // Helper checkboxes
  panel.querySelectorAll('.hi-helper-row input').forEach(checkbox => {
    checkbox.addEventListener('change', (e) => {
      const helperName = e.target.dataset.helper;
      hierarchyInspector.helpers[helperName] = e.target.checked;

      // Toggle solar period section visibility when showOrbitCenter is toggled
      if (helperName === 'showOrbitCenter') {
        const solarPeriodSection = panel.querySelector('.hi-solar-period-section');
        if (solarPeriodSection) {
          solarPeriodSection.style.display = e.target.checked ? 'block' : 'none';
        }
      }

      if (hierarchyInspector.highlightActive) {
        // Only force clean anomaly elements if the showAnomalies checkbox was toggled
        const forceCleanAnomalies = (helperName === 'showAnomalies');
        clearVisualHelpers({ forceCleanAnomalies });
        const steps = PLANET_HIERARCHIES[hierarchyInspector.currentPlanet].steps();
        // Skip clear since we just did it with the right forceCleanAnomalies setting
        createVisualHelpers(steps[hierarchyInspector.currentStep], { skipClear: true });
      }
    });
  });

  // Report buttons (Step 5)
  panel.querySelector('.hi-report-btn.download').addEventListener('click', async () => {
    if (_currentReportData && _currentReportData.excelData) {
      await exportPlanetReportToExcel(_currentReportData.planetKey, _currentReportData.excelData);
    }
  });

  panel.querySelector('.hi-report-btn.copy').addEventListener('click', () => {
    if (_currentReportData && _currentReportData.screenReport) {
      copyReportToClipboard(_currentReportData.screenReport);
    }
  });

  // Show all results checkbox (Step 5)
  panel.querySelector('.hi-report-show-all').addEventListener('change', async (e) => {
    const showAll = e.target.checked;
    hierarchyInspector.showAllResults = showAll;

    // Regenerate report with new setting
    if (_currentReportData && _currentReportData.planetKey) {
      const reportElement = panel.querySelector('.hi-report');
      const loadingElement = panel.querySelector('.hi-report-loading');

      loadingElement.style.display = 'block';
      reportElement.style.display = 'none';

      const result = await generatePlanetReport(_currentReportData.planetKey, showAll);

      _currentReportData.screenReport = result.screenReport;
      reportElement.innerHTML = result.screenReport;

      loadingElement.style.display = 'none';
      reportElement.style.display = 'block';
    }
  });

  // Keyboard navigation
  const keyHandler = (e) => {
    if (!panel.classList.contains('visible')) return;

    // Don't intercept keyboard events when user is typing in an input field
    // (e.g., editing date/time in dat.GUI)
    const activeEl = document.activeElement;
    const isTyping = activeEl && (
      activeEl.tagName === 'INPUT' ||
      activeEl.tagName === 'TEXTAREA' ||
      activeEl.isContentEditable
    );
    if (isTyping) return;

    if (e.key === 'ArrowLeft' || e.key === 'p') {
      panel.querySelector('.hi-prev-btn').click();
    } else if (e.key === 'ArrowRight' || e.key === 'n') {
      panel.querySelector('.hi-next-btn').click();
    } else if (e.key === 'Escape' || e.key === 'q') {
      closeHierarchyInspector();
    }
  };
  document.addEventListener('keydown', keyHandler);

  return panel;
}

// Open the hierarchy inspector
function openHierarchyInspector() {
  if (!hierarchyInspector.panel) {
    hierarchyInspector.panel = createInspectorPanel();
  }
  hierarchyInspector.panel.classList.add('visible');
  hierarchyInspector.panel.querySelector('.hi-planet-select').value = hierarchyInspector.currentPlanet;
  updateInspectorDisplay();
  // Hide the planet data panel while hierarchy inspector is open
  labelDismissed = true;
  const planetLabel = document.getElementById('planetLabel');
  if (planetLabel) {
    planetLabel.style.display = 'none';
  }
  // Hide orbit plane helper of current lookAtObj
  if (o.lookAtObj?.orbitPlaneHelper) {
    o.lookAtObj.orbitPlaneHelper.visible = false;
  }
  // Hide focus ring (shown when looking at Sun)
  if (focusRing) {
    focusRing.visible = false;
  }
}

// Close the hierarchy inspector
function closeHierarchyInspector() {
  if (hierarchyInspector.panel) {
    hierarchyInspector.panel.classList.remove('visible');
    // Set highlightActive to false BEFORE clearVisualHelpers so anomaly elements are cleaned up
    hierarchyInspector.highlightActive = false;
    // Disable hierarchy inspector camera control
    hierarchyInspector._cameraControlActive = false;
    hierarchyInspector._cameraTarget = null;
    // Force clean everything when closing inspector
    clearVisualHelpers({ forceCleanAnomalies: true });
    const highlightBtn = hierarchyInspector.panel.querySelector('.hi-highlight-btn');
    highlightBtn.classList.remove('active');
    highlightBtn.textContent = 'Highlight in Scene';
    // Reset view to Earth with default bird's eye view (same as initial load)
    o.lookAtObj = earth;
    camera.position.set(0, 500, 0);
    controls.target.set(0, 0, 0);
    focusPlanet(earth);
    // Show the planet data panel with Earth data
    labelDismissed = false;
    const planetLabel = document.getElementById('planetLabel');
    if (planetLabel) {
      planetLabel.style.display = 'block';
    }
    // Update the "Look at" dropdown to show Earth
    o.Target = 'Earth';
    // Hide all orbit plane helpers
    planetObjects.forEach(p => {
      if (p.orbitPlaneHelper) p.orbitPlaneHelper.visible = false;
    });
    // Update the GUI dropdown by finding the select element
    const guiContainer = document.getElementById('gui');
    if (guiContainer) {
      const selectElements = guiContainer.querySelectorAll('select');
      selectElements.forEach(select => {
        // Find the "Look at" dropdown by checking its options
        const hasEarthOption = Array.from(select.options).some(opt => opt.value === 'Earth');
        if (hasEarthOption) {
          select.value = 'Earth';
        }
      });
    }
  }
}

// Update live data in hierarchy inspector (called from render loop)
let _lastLiveDataJD = null;
let _lastLiveDataPlanet = null; // Track planet changes to force refresh
let _lastLiveDataStep = null; // Track step changes to force refresh when returning to Step 4
const _liveDataVec3 = new THREE.Vector3(); // Reusable vector for performance
const _liveDataVec3b = new THREE.Vector3(); // Second reusable vector for sun position
const _liveDataInvTiltMatrix = new THREE.Matrix4(); // Reusable inverse tilt matrix
const _liveDataTiltMatrix = new THREE.Matrix4(); // Reusable tilt matrix
const _liveDataFlatPos = new THREE.Vector3(); // Reusable vector for flat orbital position
const _liveDataP1 = new THREE.Vector3(); // Reusable vectors for node sampling
const _liveDataP2 = new THREE.Vector3();
const _liveDataP1World = new THREE.Vector3(); // Reusable vectors for world positions
const _liveDataP2World = new THREE.Vector3();
const _liveDataLocalPt = new THREE.Vector3(); // Reusable for orbit point sampling
const _liveDataWorldPt = new THREE.Vector3();
const _liveDataLocalToWorld = new THREE.Matrix4(); // Reusable transform matrix for node updates
const _liveDataNewAscPos = new THREE.Vector3(); // Reusable for ascending node position
const _liveDataNewDescPos = new THREE.Vector3(); // Reusable for descending node position
const _liveDataNewHighPos = new THREE.Vector3(); // Reusable for highest point position
const _liveDataNewLowPos = new THREE.Vector3(); // Reusable for lowest point position
const _liveDataEuler = new THREE.Euler(); // Reusable Euler for rotation calculations
const _liveDataDebugLocal = new THREE.Vector3(); // Reusable for debug local position
const _liveDataDebugWorld = new THREE.Vector3(); // Reusable for debug world position
const _liveDataDebugMarker = new THREE.Vector3(); // Reusable for debug marker world position
// Pre-allocated arrays for half-disc geometry (64 points + 1 wrap + 1 center = 66 vertices * 3 = 198 floats)
const _halfDiscVertices = new Float32Array(198);
const _halfDiscIndices = []; // Indices array reused between calls
// Reusable vectors for hierarchy inspector validation and display
const _hiObjWorldPos = new THREE.Vector3();
const _hiSunWorldPos = new THREE.Vector3();
const _hiEarthPeriPos = new THREE.Vector3();
const _hiPlanetPeriPos = new THREE.Vector3();
const _hiDirection = new THREE.Vector3();
const _hiWorldPos = new THREE.Vector3();
// Reusable vectors for Step 3 visual helpers
const _hiSunPos = new THREE.Vector3();
const _hiPerihelionPos = new THREE.Vector3();
const _hiEarthPos = new THREE.Vector3();
const _hiPPos = new THREE.Vector3(); // P = orbit center position
const _hiPlanetPos = new THREE.Vector3(); // Current planet position
// Reusable vectors for updatePlanetAnomalies
const _anomalySunPos = new THREE.Vector3();
const _anomalyPPos = new THREE.Vector3();
const _anomalyPlanetPos = new THREE.Vector3();
const _hiPurpleWorldPos = new THREE.Vector3();
const _hiGreenWorldPos = new THREE.Vector3();
const _hiTempPos = new THREE.Vector3();
// Reusable vectors for camera positioning
const _hiTargetPos = new THREE.Vector3();
const _hiCamSunPos = new THREE.Vector3();
const _hiCamDirection = new THREE.Vector3();
let _cachedAscNodeOrbitalAngle = null; // Cached ascending node orbital angle
let _cachedTiltA = null, _cachedTiltB = null; // Cached tilt values to detect changes
let _liveDataElements = null; // Cached DOM element references for live data updates
let _lastAscNodeTiltA = null, _lastAscNodeTiltB = null; // Cache to skip unchanged ascending node updates
let _lastArcTrueAnomaly = null, _lastArcMeanAnomaly = null; // Cache for arc update throttling
function updateHierarchyLiveData() {
  try {
    if (!hierarchyInspector.panel || !hierarchyInspector.panel.classList.contains('visible')) return;

    // If not on Step 4, reset tracking so we refresh when returning to Step 4
    if (hierarchyInspector.currentStep !== 3) {
      _lastLiveDataStep = null;
      return;
    }

  // Only update when simulation is running OR Julian Day has changed OR planet/step changed
  // This allows copy/paste when paused
  const currentJD = o.julianDay;
  const currentPlanet = hierarchyInspector.currentPlanet;
  const currentStep = hierarchyInspector.currentStep;
  const planetChanged = _lastLiveDataPlanet !== currentPlanet;
  const stepChanged = _lastLiveDataStep !== currentStep;

  if (!o.Run && _lastLiveDataJD !== null && Math.abs(currentJD - _lastLiveDataJD) < 0.0001 && !planetChanged && !stepChanged) {
    return; // Simulation paused, no JD change, same planet, and same step - skip update
  }
  _lastLiveDataJD = currentJD;
  _lastLiveDataPlanet = currentPlanet;
  _lastLiveDataStep = currentStep;

  const liveContent = hierarchyInspector.panel.querySelector('.hi-live-content');
  if (!liveContent) return;

  const steps = PLANET_HIERARCHIES[hierarchyInspector.currentPlanet].steps();
  const stepData = steps[hierarchyInspector.currentStep];
  const obj = stepData.obj;

  if (!obj) return;

  // Get the actual planet object (Step 5) to check its real world position
  const planetStep = steps[4]; // Step 5 is the actual planet
  const planetObj = planetStep?.obj;

  // Get tilt values for ascending node calculation
  const tiltaDeg = obj.orbitTilta || 0;
  const tiltbDeg = obj.orbitTiltb || 0;

  // The tilt encoding is:
  //   orbitTilta = cos((-90 - Ω) * π/180) * (-inclination)
  //   orbitTiltb = sin((-90 - Ω) * π/180) * (-inclination)
  // The negative inclination flips signs, equivalent to:
  //   atan2(tiltb, tilta) = 90 - Ω
  // Therefore: Ω = 90 - atan2(tiltb, tilta)
  // But we now use the DYNAMIC ascending node from o.<planet>AscendingNode
  // which accounts for changes in Earth's obliquity over time
  // Map planet keys to their o.xxxAscendingNode property names
  const ascendingNodePropertyMap = {
    mercury: 'mercuryAscendingNode',
    venus: 'venusAscendingNode',
    mars: 'marsAscendingNode',
    jupiter: 'jupiterAscendingNode',
    saturn: 'saturnAscendingNode',
    uranus: 'uranusAscendingNode',
    neptune: 'neptuneAscendingNode',
    pluto: 'plutoAscendingNode',
    halleys: 'halleysAscendingNode',
    eros: 'erosAscendingNode'
  };

  // Use dynamic value if available, otherwise fall back to static calculation
  let ascNodeAngleDeg;
  const ascNodeProperty = ascendingNodePropertyMap[hierarchyInspector.currentPlanet];
  if (ascNodeProperty && o[ascNodeProperty] !== undefined && o[ascNodeProperty] !== 0) {
    ascNodeAngleDeg = o[ascNodeProperty];
  } else {
    // Fallback to static calculation
    const theta = Math.atan2(tiltbDeg, tiltaDeg) * 180 / Math.PI;
    ascNodeAngleDeg = 90 - theta;
    ascNodeAngleDeg = ((ascNodeAngleDeg % 360) + 360) % 360;
  }

  // Get world positions (reuse vector for performance)
  let planetWorldY = 0;
  let planetWorldX = 0, planetWorldZ = 0;

  if (planetObj?.pivotObj) {
    planetObj.pivotObj.getWorldPosition(_liveDataVec3);
    planetWorldX = _liveDataVec3.x;
    planetWorldY = _liveDataVec3.y;
    planetWorldZ = _liveDataVec3.z;
  }

  // Calculate orbital plane height metrics
  const inclinationRad = Math.sqrt(tiltaDeg*tiltaDeg + tiltbDeg*tiltbDeg) * Math.PI / 180;
  const orbitRadius = Math.sqrt(planetWorldX*planetWorldX + planetWorldZ*planetWorldZ);
  const maxY = orbitRadius * Math.sin(inclinationRad);

  // Calculate angle from planet to ascending node
  // The planet's ecliptic longitude from its world position:
  let planetEclipticLong = Math.atan2(-planetWorldZ, planetWorldX) * 180 / Math.PI;
  planetEclipticLong = ((planetEclipticLong % 360) + 360) % 360;

  // Angular distance from the ascending node (measured along the ecliptic)
  let eclipticAngleFromAscNode = planetEclipticLong - ascNodeAngleDeg;
  eclipticAngleFromAscNode = ((eclipticAngleFromAscNode + 180) % 360 + 360) % 360 - 180;

  // The "angle from ascending node" in orbital terms is the argument of latitude (u)
  // u = 0° at ascending node, 90° at highest point, 180° at descending node, 270° at lowest
  //
  // We can calculate this from the planet's Y height relative to maxY:
  // Y/maxY = sin(u) for the ascending half (0° to 180°)
  //
  // To determine which half of the orbit we're in (ascending vs descending),
  // we check if the ecliptic angle is in [0°, 180°] or [-180°, 0°]
  let anglePlanetFromAscNode = 0;
  if (maxY > 0.001) {
    const yRatio = Math.max(-1, Math.min(1, planetWorldY / maxY));
    const yAngle = Math.asin(yRatio) * 180 / Math.PI; // -90 to +90

    // Determine which half of orbit based on ecliptic position
    if (eclipticAngleFromAscNode >= 0 && eclipticAngleFromAscNode <= 180) {
      // Ascending half: angle is directly the yAngle (0 to 90 to 0)
      // But we need to distinguish 0-90 from 90-180
      if (eclipticAngleFromAscNode <= 90) {
        anglePlanetFromAscNode = yAngle; // 0 to 90
      } else {
        anglePlanetFromAscNode = 180 - yAngle; // 90 to 180 (but yAngle goes 90 to 0)
      }
    } else {
      // Descending half: angle is -yAngle (0 to -90 to 0)
      if (eclipticAngleFromAscNode >= -90) {
        anglePlanetFromAscNode = yAngle; // 0 to -90 (yAngle is already negative here)
      } else {
        anglePlanetFromAscNode = -180 - yAngle; // -90 to -180
      }
    }
  }

  // Calculate angle from ascending node (ecliptic longitude based)
  // sun.ra gives the Sun's ecliptic longitude directly (in radians)
  // At June 21 (model start), sun.ra ≈ 90° (summer solstice)
  const sunEclipticLongitude = (sun.ra * 180 / Math.PI + 360) % 360;
  // Angle from ascending node = current ecliptic longitude - ascending node longitude
  let angleFromAscNode = sunEclipticLongitude - ascNodeAngleDeg;
  // Normalize to 0-360 first, then convert to ±180 range
  angleFromAscNode = ((angleFromAscNode % 360) + 360) % 360;
  if (angleFromAscNode > 180) {
    angleFromAscNode = angleFromAscNode - 360; // Convert 181-359 to -179 to -1
  }

  // Calculate angle from longitude of perihelion
  // Get the longitude of perihelion for this planet
  const perihelionLongValues = {
    mercury: o.mercuryPerihelion,
    venus: o.venusPerihelion,
    mars: o.marsPerihelion,
    jupiter: o.jupiterPerihelion,
    saturn: o.saturnPerihelion,
    uranus: o.uranusPerihelion,
    neptune: o.neptunePerihelion,
    pluto: o.plutoPerihelion,
    halleys: o.halleysPerihelion,
    eros: o.erosPerihelion
  };
  const perihelionLong = perihelionLongValues[hierarchyInspector.currentPlanet] ?? 0;
  // Angle from perihelion = current ecliptic longitude - longitude of perihelion
  let angleFromPerihelion = sunEclipticLongitude - perihelionLong;
  // Normalize to 0-360 first, then convert to ±180 range
  angleFromPerihelion = ((angleFromPerihelion % 360) + 360) % 360;
  if (angleFromPerihelion > 180) {
    angleFromPerihelion = angleFromPerihelion - 360; // Convert 181-359 to -179 to -1
  }

  // Get planet label for display
  const planetLabel = PLANET_HIERARCHIES[hierarchyInspector.currentPlanet]?.label || 'Planet';

  // Get celestial coordinates directly from planet/sun objects
  // These are the same values used in info panels
  const planetRA = planetObj?.raDisplay || 'N/A';
  const planetDec = planetObj?.decDisplay || 'N/A';
  const sunDecDisplay = sun.decDisplay || 'N/A';

  // Get raw Dec values in degrees for comparison
  const planetDecValue = planetObj?.dec ? 90 - (planetObj.dec * 180 / Math.PI) : 0;
  const sunDecValue = 90 - (sun.dec * 180 / Math.PI);

  // Determine ecliptic position based on World Y (model's ecliptic plane)
  let orbitalPlanePos, orbitalPlanePosColor;
  const actuallyAbove = planetWorldY > 0.001;
  const actuallyBelow = planetWorldY < -0.001;

  if (!actuallyAbove && !actuallyBelow) {
    orbitalPlanePos = 'ON ecliptic plane';
    orbitalPlanePosColor = '#64b5f6';
  } else if (actuallyAbove) {
    orbitalPlanePos = 'NORTH of ecliptic';
    orbitalPlanePosColor = '#4caf50';
  } else {
    orbitalPlanePos = 'SOUTH of ecliptic';
    orbitalPlanePosColor = '#ffc107';
  }

  // Calculate Dec difference (planet relative to Sun)
  const decDiff = planetDecValue - sunDecValue;
  let decComparison, decComparisonColor;
  if (Math.abs(decDiff) < 0.01) {
    decComparison = 'SAME as Sun';
    decComparisonColor = '#64b5f6';
  } else if (decDiff > 0) {
    decComparison = `${decDiff.toFixed(2)}° NORTH of Sun`;
    decComparisonColor = '#4caf50';
  } else {
    decComparison = `${Math.abs(decDiff).toFixed(2)}° SOUTH of Sun`;
    decComparisonColor = '#ffc107';
  }

  // Calculate reference angle on Solar period (live update)
  // Option A: Starts at startPos value (e.g., 115.71° for Venus at model start)
  // Increases as planet moves, wraps at 360° → 0°
  // Shows 0° when planet aligns with the cyan arrow
  let refAngleDeg = 0;
  if (obj.speed !== undefined && obj.startPos !== undefined) {
    // Get the child planet's speed (actual orbital speed) for the Solar period
    const planetKey = hierarchyInspector.currentPlanet;
    const hierarchy = PLANET_HIERARCHIES[planetKey];
    let childPlanetSpeed = obj.speed;
    let childStartPos = 0;
    if (hierarchy) {
      const steps = hierarchy.steps();
      if (steps.length > 4 && steps[4].obj) {
        if (steps[4].obj.speed !== undefined) childPlanetSpeed = steps[4].obj.speed;
        if (steps[4].obj.startPos !== undefined) childStartPos = steps[4].obj.startPos;
      }
    }

    // Calculate initial angle based on child planet's startPos
    // The RealPerihelionAtSun.startPos = 2 * childStartPos (e.g., mercuryStartpos * 2 = 588)
    //
    // Rules for initial angle (counting DOWN from this value to 0):
    // - If 2 * childStartPos >= 360: initialAngle = childStartPos (e.g., Mercury: 294°)
    // - If 2 * childStartPos < 360: initialAngle = 2 * childStartPos (e.g., Mars: 243.31°)
    //
    // This represents "degrees remaining until alignment with cyan arrow"
    const doubleStartPos = childStartPos * 2;
    let initialAngle;
    if (doubleStartPos >= 360) {
      initialAngle = childStartPos; // Mercury: 294°
    } else {
      initialAngle = doubleStartPos; // Mars: 243.31°
    }

    // Calculate how many degrees the planet has traveled in its Solar period
    // childPlanetSpeed is in rad/year, o.pos is in years (where 1 = meansolaryearlengthinDays)
    // Note: outer planets (Mars, Jupiter, etc.) have NEGATIVE speed, so use absolute value
    const traveledDeg = Math.abs(childPlanetSpeed) * o.pos * 180 / Math.PI;

    // Reference angle COUNTS DOWN: starts at initialAngle, decreases to 0
    // refAngleDeg = initialAngle - traveledDeg (mod 360)
    refAngleDeg = (initialAngle - traveledDeg) % 360;
    if (refAngleDeg < 0) refAngleDeg += 360;

    // Calculate days until next alignment (when refAngleDeg reaches 0)
    // Solar orbit length in days = (holisticyearLength / planetSolarYearCount) * meansolaryearlengthinDays
    const solarYearCounts = {
      mercury: mercurySolarYearCount,
      venus: venusSolarYearCount,
      mars: marsSolarYearCount,
      jupiter: jupiterSolarYearCount,
      saturn: saturnSolarYearCount,
      uranus: uranusSolarYearCount,
      neptune: neptuneSolarYearCount,
      pluto: plutoSolarYearCount,
      halleys: halleysSolarYearCount,
      eros: erosSolarYearCount
    };
    const planetSolarYearCount = solarYearCounts[planetKey];
    const planetSolarOrbitDays = planetSolarYearCount ? (holisticyearLength / planetSolarYearCount) * meansolaryearlengthinDays : 0;
    window._orbitPeriodSolar = planetSolarOrbitDays;
    window._daysUntilAlignment = planetSolarOrbitDays > 0 ? (refAngleDeg / 360) * planetSolarOrbitDays : 0;

  }

  // Calculate True Anomaly and Mean Anomaly dynamically from the model
  // The child planet orbits inside RealPerihelionAtSun container.
  // Its orbital angle θ = speed * pos - startPos * (π/180) [from moveModel]
  // This θ represents the True Anomaly (angle from perihelion direction)

  // Get the child planet object (Step 5 in hierarchy)
  const anomalyPlanetKey = hierarchyInspector.currentPlanet;
  const anomalyHierarchy = PLANET_HIERARCHIES[anomalyPlanetKey];
  let childPlanet = null;
  if (anomalyHierarchy) {
    const steps = anomalyHierarchy.steps();
    if (steps.length > 4 && steps[4].obj) {
      childPlanet = steps[4].obj;
    }
  }

  // Note: The Mean/True Anomaly values are now calculated dynamically
  // in the anomaly visualization update section below, based on the
  // actual Earth-Sun line angle. This ensures the arc always ends
  // exactly at the Earth-Sun line.

  // Check if we need to rebuild DOM structure (planet changed or first time)
  const needsRebuild = !_liveDataElements || _liveDataElements.planet !== hierarchyInspector.currentPlanet;

  if (needsRebuild) {
    // Build the DOM structure once with data-id attributes for efficient updates
    liveContent.innerHTML = `
      <div style="display: grid; grid-template-columns: 200px 1fr; gap: 6px 12px; font-size: 12px;">
        <span style="color: rgba(255,255,255,0.5); font-size: 10px; grid-column: 1 / -1; margin-top: 4px;">CELESTIAL COORDINATES</span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(Position relative to Earth's equator)</span>
        <span style="color: rgba(255,255,255,0.6);">${planetLabel} RA</span>
        <span data-id="planetRA" style="color: #4caf50;"></span>
        <span style="color: rgba(255,255,255,0.6);">${planetLabel} Dec</span>
        <span data-id="planetDec" style="color: #4caf50;"></span>
        <span style="color: rgba(255,255,255,0.6);">Sun Dec</span>
        <span data-id="sunDec" style="color: #4caf50;"></span>
        <span style="color: rgba(255,255,255,0.6);">${planetLabel} vs Sun Dec</span>
        <span data-id="decComparison"></span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(At transit: ${planetLabel} Dec ≈ Sun Dec)</span>

        <span style="color: rgba(255,255,255,0.5); font-size: 10px; grid-column: 1 / -1; margin-top: 8px;">ECLIPTIC POSITION OF PLANET</span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(Height above/below ecliptic plane in 3D model)</span>
        <span style="color: rgba(255,255,255,0.6);">Ecliptic position</span>
        <span data-id="eclipticPos"></span>
        <span style="color: rgba(255,255,255,0.6);">Height above ecliptic</span>
        <span data-id="heightEcliptic"></span>
        <span style="color: rgba(255,255,255,0.6);">Height ratio (% of max)</span>
        <span data-id="heightRatio" style="color: #4caf50;"></span>
        <span style="color: rgba(255,255,255,0.6);">Angle planet from asc. node</span>
        <span data-id="anglePlanetAsc" style="color: #4caf50;"></span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(±90° based on Y height)</span>

        <span style="color: rgba(255,255,255,0.5); font-size: 10px; grid-column: 1 / -1; margin-top: 8px;">CONTROL PERIHELION PLACEMENT IN 3D MODEL</span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(Verify P position matches Long.Peri - startAngle)</span>
        <span style="color: rgba(255,255,255,0.6);">Start Angle of Model</span>
        <span data-id="startAngleModel" style="color: rgba(255,255,255,0.6);"></span>
        <span style="color: rgba(255,255,255,0.6);">Expected P angle (Long.Peri - ${startAngleModel.toFixed(1)}°)</span>
        <span data-id="perihelionExpected" style="color: rgba(255,255,255,0.6);"></span>
        <span style="color: rgba(255,255,255,0.6);">Expected P distance (Sun → P)</span>
        <span data-id="perihelionDistanceExpected" style="color: rgba(255,255,255,0.6);"></span>
        <span style="color: #00ff00;">Actual P angle (Sun → P)</span>
        <span data-id="perihelionAngle3D" style="color: #00ff00;"></span>
        <span style="color: #00ff00;">Actual P distance (Sun → P)</span>
        <span data-id="perihelionDistance3D" style="color: #00ff00;"></span>

        <span style="color: rgba(255,255,255,0.5); font-size: 10px; grid-column: 1 / -1; margin-top: 8px;">CURRENT ASCENDING NODE DISTANCE</span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(Current angle of Earth-Sun view to ascending node & longitude of perihelion)</span>
        <span style="color: #ffff00;">Current Angle from asc. node</span>
        <span data-id="angleFromAsc" style="color: #ffff00;"></span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(±180° Sun ecliptic longitude - ascending node)</span>
        <span style="color: #ffff00;">Current Angle from long. perihelion</span>
        <span data-id="angleFromPeri" style="color: #ffff00;"></span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(±180° Sun ecliptic longitude - longitude of perihelion)</span>

        <span style="color: rgba(255,255,255,0.5); font-size: 10px; grid-column: 1 / -1; margin-top: 8px;">ORBITAL ELEMENTS</span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(The orientation of the plane of the orbit)</span>
        <span style="color: #ff00ff;">Longitude of Ascending Node (Ω)</span>
        <span data-id="ascendingNodeLong" style="color: #ff00ff;"></span>
        <span style="color: #ffffff;">Argument of Periapsis (ω)</span>
        <span data-id="argumentOfPeriapsis" style="color: #ffffff;"></span>
        <span style="color: #00ff00;">Longitude of Perihelion (ϖ)</span>
        <span data-id="longitudeOfPerihelion" style="color: #00ff00;"></span>

        <span style="color: rgba(255,255,255,0.5); font-size: 10px; grid-column: 1 / -1; margin-top: 8px;">ORBITAL ANOMALIES</span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(Angle from perihelion in planet's orbit)</span>
        <span style="color: #00ffff;">Mean Anomaly (M)</span>
        <span data-id="meanAnomaly" style="color: #00ffff;"></span>
        <span style="color: #ffbf00;">True Anomaly (ν)</span>
        <span data-id="trueAnomaly" style="color: #ffbf00;"></span>
        <span style="color: #ff69b4;">Equation of Center (ν − M)</span>
        <span data-id="equationOfCenter" style="color: #ff69b4;"></span>
        <span style="color: rgba(255,255,255,0.4); font-size: 9px; grid-column: 1 / -1;">(M = uniform motion, ν = actual position from perihelion)</span>
        <span style="color: rgba(255,255,255,0.5); font-size: 10px; grid-column: 1 / -1; margin-top: 8px;">REFERENCE ANOMALIES (21 Jun 2000)</span>
        <span style="color: rgba(255,255,255,0.6);">Mean Anomaly (ref)</span>
        <span data-id="refMeanAnomaly" style="color: rgba(255,255,255,0.6);"></span>
        <span style="color: rgba(255,255,255,0.6);">True Anomaly (ref)</span>
        <span data-id="refTrueAnomaly" style="color: rgba(255,255,255,0.6);"></span>
        <span style="color: rgba(255,255,255,0.6);">Equation of Center (ref)</span>
        <span data-id="refEquationOfCenter" style="color: rgba(255,255,255,0.6);"></span>
      </div>
    `;

    // Cache element references for fast updates
    _liveDataElements = {
      planet: hierarchyInspector.currentPlanet,
      planetRA: liveContent.querySelector('[data-id="planetRA"]'),
      planetDec: liveContent.querySelector('[data-id="planetDec"]'),
      sunDec: liveContent.querySelector('[data-id="sunDec"]'),
      decComparison: liveContent.querySelector('[data-id="decComparison"]'),
      eclipticPos: liveContent.querySelector('[data-id="eclipticPos"]'),
      heightEcliptic: liveContent.querySelector('[data-id="heightEcliptic"]'),
      heightRatio: liveContent.querySelector('[data-id="heightRatio"]'),
      anglePlanetAsc: liveContent.querySelector('[data-id="anglePlanetAsc"]'),
      angleFromAsc: liveContent.querySelector('[data-id="angleFromAsc"]'),
      angleFromPeri: liveContent.querySelector('[data-id="angleFromPeri"]'),
      ascendingNodeLong: liveContent.querySelector('[data-id="ascendingNodeLong"]'),
      argumentOfPeriapsis: liveContent.querySelector('[data-id="argumentOfPeriapsis"]'),
      // Solar period reference elements are now in the helper section, not live content
      refAngle: hierarchyInspector.panel.querySelector('[data-id="refAngleHelper"]'),
      orbitPeriodSolar: hierarchyInspector.panel.querySelector('[data-id="orbitPeriodSolarHelper"]'),
      daysUntilAlignment: hierarchyInspector.panel.querySelector('[data-id="daysUntilAlignmentHelper"]'),
      meanAnomaly: liveContent.querySelector('[data-id="meanAnomaly"]'),
      trueAnomaly: liveContent.querySelector('[data-id="trueAnomaly"]'),
      equationOfCenter: liveContent.querySelector('[data-id="equationOfCenter"]'),
      refMeanAnomaly: liveContent.querySelector('[data-id="refMeanAnomaly"]'),
      refTrueAnomaly: liveContent.querySelector('[data-id="refTrueAnomaly"]'),
      refEquationOfCenter: liveContent.querySelector('[data-id="refEquationOfCenter"]'),
      longitudeOfPerihelion: liveContent.querySelector('[data-id="longitudeOfPerihelion"]'),
      startAngleModel: liveContent.querySelector('[data-id="startAngleModel"]'),
      perihelionExpected: liveContent.querySelector('[data-id="perihelionExpected"]'),
      perihelionDistanceExpected: liveContent.querySelector('[data-id="perihelionDistanceExpected"]'),
      perihelionAngle3D: liveContent.querySelector('[data-id="perihelionAngle3D"]'),
      perihelionDistance3D: liveContent.querySelector('[data-id="perihelionDistance3D"]')
    };

    // Get reference anomaly values for current planet (21 Jun 2000 00:00 UTC)
    const refAnomalies = {
      mercury: { mean: mercuryMeanAnomaly, true: mercuryTrueAnomaly },
      venus: { mean: venusMeanAnomaly, true: venusTrueAnomaly },
      mars: { mean: marsMeanAnomaly, true: marsTrueAnomaly },
      jupiter: { mean: jupiterMeanAnomaly, true: jupiterTrueAnomaly },
      saturn: { mean: saturnMeanAnomaly, true: saturnTrueAnomaly },
      uranus: { mean: uranusMeanAnomaly, true: uranusTrueAnomaly },
      neptune: { mean: neptuneMeanAnomaly, true: neptuneTrueAnomaly },
      pluto: { mean: plutoMeanAnomaly, true: plutoTrueAnomaly },
      halleys: { mean: halleysMeanAnomaly, true: halleysTrueAnomaly },
      eros: { mean: erosMeanAnomaly, true: erosTrueAnomaly }
    };
    const refAnomaly = refAnomalies[hierarchyInspector.currentPlanet];
    if (refAnomaly) {
      _liveDataElements.refMeanAnomaly.textContent = refAnomaly.mean.toFixed(2) + '°';
      _liveDataElements.refTrueAnomaly.textContent = refAnomaly.true.toFixed(2) + '°';
      const refEoc = refAnomaly.true - refAnomaly.mean;
      _liveDataElements.refEquationOfCenter.textContent = (refEoc >= 0 ? '+' : '') + refEoc.toFixed(2) + '°';
    }

    // Set expected perihelion distance (one-time, static value)
    // These values are in scene units (AU * 100), so divide by 100 to get AU
    const perihelionDistances = {
      mercury: mercuryPerihelionDistance,
      venus: venusPerihelionDistance,
      mars: marsPerihelionDistance,
      jupiter: jupiterPerihelionDistance,
      saturn: saturnPerihelionDistance,
      uranus: uranusPerihelionDistance,
      neptune: neptunePerihelionDistance,
      pluto: plutoPerihelionDistance,
      halleys: halleysPerihelionDistance,
      eros: erosPerihelionDistance
    };
    const expectedPeriDist = perihelionDistances[hierarchyInspector.currentPlanet];
    if (expectedPeriDist !== undefined) {
      _liveDataElements.perihelionDistanceExpected.textContent = (expectedPeriDist / 100).toFixed(6) + ' AU';
    }
  }

  // Update only the text content (much faster than innerHTML)
  const el = _liveDataElements;
  el.planetRA.textContent = planetRA;
  el.planetDec.textContent = planetDec;
  el.sunDec.textContent = sunDecDisplay;
  el.decComparison.textContent = decComparison;
  el.decComparison.style.color = decComparisonColor;
  el.eclipticPos.textContent = orbitalPlanePos;
  el.eclipticPos.style.color = orbitalPlanePosColor;
  el.heightEcliptic.textContent = planetWorldY.toFixed(4);
  el.heightEcliptic.style.color = planetWorldY > 0 ? '#4caf50' : '#ffc107';
  el.heightRatio.textContent = maxY > 0.001 ? (planetWorldY / maxY * 100).toFixed(1) + '%' : 'N/A';
  el.heightRatio.style.color = planetWorldY > 0 ? '#4caf50' : '#ffc107';
  el.anglePlanetAsc.textContent = anglePlanetFromAscNode.toFixed(2) + '°';
  el.anglePlanetAsc.style.color = planetWorldY > 0 ? '#4caf50' : '#ffc107';
  el.angleFromAsc.textContent = angleFromAscNode.toFixed(2) + '°';
  el.angleFromPeri.textContent = angleFromPerihelion.toFixed(2) + '°';
  el.ascendingNodeLong.textContent = ascNodeAngleDeg.toFixed(4) + '°';

  // Get argument of periapsis for current planet
  const argumentOfPeriapsisValues = {
    mercury: o.mercuryArgumentOfPeriapsis,
    venus: o.venusArgumentOfPeriapsis,
    mars: o.marsArgumentOfPeriapsis,
    jupiter: o.jupiterArgumentOfPeriapsis,
    saturn: o.saturnArgumentOfPeriapsis,
    uranus: o.uranusArgumentOfPeriapsis,
    neptune: o.neptuneArgumentOfPeriapsis,
    pluto: o.plutoArgumentOfPeriapsis,
    halleys: o.halleysArgumentOfPeriapsis,
    eros: o.erosArgumentOfPeriapsis
  };
  const argPeri = argumentOfPeriapsisValues[hierarchyInspector.currentPlanet] ?? 0;
  el.argumentOfPeriapsis.textContent = argPeri.toFixed(4) + '°';

  // Get longitude of perihelion for current planet
  const longitudeOfPerihelionValues = {
    mercury: o.mercuryPerihelion,
    venus: o.venusPerihelion,
    mars: o.marsPerihelion,
    jupiter: o.jupiterPerihelion,
    saturn: o.saturnPerihelion,
    uranus: o.uranusPerihelion,
    neptune: o.neptunePerihelion,
    pluto: o.plutoPerihelion,
    halleys: o.halleysPerihelion,
    eros: o.erosPerihelion
  };
  const longPeri = longitudeOfPerihelionValues[hierarchyInspector.currentPlanet] ?? 0;
  el.longitudeOfPerihelion.textContent = longPeri.toFixed(4) + '°';

  // Show the fixed start angle of the model (Earth→Sun at June 21, 2000 00:00 UTC)
  el.startAngleModel.textContent = startAngleModel.toFixed(8) + '°';

  // Calculate expected perihelion angle: longitude of perihelion - start angle
  let periExpected = ((longPeri - startAngleModel) % 360 + 360) % 360;
  el.perihelionExpected.textContent = periExpected.toFixed(4) + '°';

  // Calculate the actual Sun → P angle from the 3D model
  // Define fixedPerihelionObjects once for reuse below
  const fixedPerihelionObjects = {
    mercury: mercuryFixedPerihelionAtSun,
    venus: venusFixedPerihelionAtSun,
    mars: marsFixedPerihelionAtSun,
    jupiter: jupiterFixedPerihelionAtSun,
    saturn: saturnFixedPerihelionAtSun,
    uranus: uranusFixedPerihelionAtSun,
    neptune: neptuneFixedPerihelionAtSun,
    pluto: plutoFixedPerihelionAtSun,
    halleys: halleysFixedPerihelionAtSun,
    eros: erosFixedPerihelionAtSun
  };
  const fixedPerihelion = fixedPerihelionObjects[hierarchyInspector.currentPlanet];

  // Get sun and perihelion world positions once for reuse throughout this function
  let sunWorldPosX = 0, sunWorldPosZ = 0;
  let periWorldPosX = 0, periWorldPosZ = 0;
  let hasSunPos = false, hasPeriPos = false;

  if (sun && sun.pivotObj) {
    sun.pivotObj.getWorldPosition(_liveDataVec3);
    sunWorldPosX = _liveDataVec3.x;
    sunWorldPosZ = _liveDataVec3.z;
    hasSunPos = true;
  }

  if (fixedPerihelion) {
    const sourceObj = fixedPerihelion.planetObj || fixedPerihelion.pivotObj;
    if (sourceObj) {
      sourceObj.getWorldPosition(_liveDataVec3b);
      periWorldPosX = _liveDataVec3b.x;
      periWorldPosZ = _liveDataVec3b.z;
      hasPeriPos = true;
    }
  }

  if (hasSunPos && hasPeriPos) {
    // Calculate Sun → P angle
    const dxSP = periWorldPosX - sunWorldPosX;
    const dzSP = periWorldPosZ - sunWorldPosZ;
    const sunPAngleRad = Math.atan2(-dzSP, dxSP);
    const sunPAngleDeg = ((sunPAngleRad * 180 / Math.PI) % 360 + 360) % 360;

    // Combined angle = fixed startAngleModel + Sun→P
    const combinedAngle = ((startAngleModel + sunPAngleDeg) % 360 + 360) % 360;

    el.perihelionAngle3D.textContent = combinedAngle.toFixed(4) + '°';

    // Calculate Sun → P distance in AU (scene units / 100 = AU)
    const distanceSceneUnits = Math.sqrt(dxSP * dxSP + dzSP * dzSP);
    const distanceAU = distanceSceneUnits / 100;
    el.perihelionDistance3D.textContent = distanceAU.toFixed(6) + ' AU';
  } else {
    el.perihelionAngle3D.textContent = 'N/A';
    el.perihelionDistance3D.textContent = 'N/A';
  }

  el.refAngle.textContent = refAngleDeg.toFixed(2) + '°';
  el.orbitPeriodSolar.textContent = (window._orbitPeriodSolar?.toFixed(2) ?? '0.00') + ' days';
  el.daysUntilAlignment.textContent = (window._daysUntilAlignment?.toFixed(2) ?? '0.00') + ' days';
  el.meanAnomaly.textContent = (window._meanAnomaly?.toFixed(2) ?? '0.00') + '°';
  el.trueAnomaly.textContent = (window._trueAnomaly?.toFixed(2) ?? '0.00') + '°';
  const eocValue = (window._trueAnomaly ?? 0) - (window._meanAnomaly ?? 0);
  el.equationOfCenter.textContent = (eocValue >= 0 ? '+' : '') + eocValue.toFixed(2) + '°';

  // Update anomaly visualization if it exists
  // The anomaly visualization shows True Anomaly and Mean Anomaly as angles from perihelion
  // It should be centered at the SUN (the focus of the ellipse)
  // Reuse sun and perihelion positions fetched above
  if (hierarchyInspector.anomalyGroup && hasSunPos) {
    // Position the anomaly group at the SUN (center of the solar system)
    // Use _liveDataVec3 which still contains sun position from above
    hierarchyInspector.anomalyGroup.position.set(sunWorldPosX, _liveDataVec3.y, sunWorldPosZ);

    // Calculate the rotation to align the anomaly 0° direction with the perihelion direction
    // The anomaly arcs should start (0°) pointing toward the fixed perihelion point
    // Reuse fixedPerihelionObjects and perihelion position defined above

    if (hasPeriPos) {
      // Calculate direction from Sun to Perihelion (P) in the XZ plane (ecliptic)
      // Using already-fetched positions
      const dx = periWorldPosX - sunWorldPosX;
      const dz = periWorldPosZ - sunWorldPosZ;

      // Calculate the angle to align the anomaly visualization with the perihelion direction
      //
      // Goal: Start markers (at local +X) should be on the P side (far from Sun),
      //       and arcs should sweep counter-clockwise from there toward Earth
      //
      // In Three.js (looking down from +Y / north pole view):
      // - +X is right, +Z is toward viewer (Earth is at -Z roughly)
      // - atan2(dz, dx) gives angle from +X axis to Sun→P direction
      // - Add PI to flip 180° so markers are on the P side, not the Sun side
      const perihelionAngle = Math.atan2(dz, dx);

      // Rotate so local +X points toward P (away from Sun center, toward perihelion)
      hierarchyInspector.anomalyGroup.rotation.y = -perihelionAngle + Math.PI;

      // Apply orbital plane tilt (if any) - this tilts the entire anomaly visualization
      if (obj && obj.containerObj) {
        hierarchyInspector.anomalyGroup.rotation.x = obj.containerObj.rotation.x;
        hierarchyInspector.anomalyGroup.rotation.z = obj.containerObj.rotation.z;
      }
    }

    // Calculate the Earth-Sun line angle in local space of the anomalyGroup
    // This angle is used for both the Earth-Sun line AND the mean anomaly arc
    // so they always align perfectly
    let earthSunLocalAngle = 0;

    if (earth && earth.pivotObj) {
      // Get Earth's world position (Sun position already stored above)
      earth.pivotObj.getWorldPosition(_liveDataVec3b);

      // Calculate direction from Earth to Sun in world space (using stored sun position)
      const dxWorld = sunWorldPosX - _liveDataVec3b.x;
      const dzWorld = sunWorldPosZ - _liveDataVec3b.z;
      const earthToSunAngleWorld = Math.atan2(dzWorld, dxWorld);

      // Convert to local space of anomalyGroup
      // The anomalyGroup is rotated so +X points toward perihelion
      const groupRotY = hierarchyInspector.anomalyGroup.rotation.y;
      earthSunLocalAngle = earthToSunAngleWorld + groupRotY;

      // Update the Earth-Sun reference line to point in this direction
      if (hierarchyInspector.earthSunLine) {
        hierarchyInspector.earthSunLine.rotation.y = -earthSunLocalAngle;
      }
    }

    // =====================================================================
    // PROPER TRUE ANOMALY AND MEAN ANOMALY CALCULATION
    // Based on actual 3D positions, not Earth-Sun line angle
    // - True Anomaly (ν): Angle at SUN from perihelion to planet
    // - Mean Anomaly (M): Angle at P (orbit center) from perihelion to planet
    // =====================================================================

    // Get the fixedPerihelion object for this planet (P = orbit center)
    const fixedPerihelionObj = anomalyHierarchy.fixedPerihelion ? anomalyHierarchy.fixedPerihelion() : null;

    let trueAnomalyRad = 0;
    let meanAnomalyRad = 0;
    let periAngleSun = 0;  // Perihelion direction angle from Sun (for arc drawing)
    let periAngleP = 0;    // Perihelion direction angle from P (for arc drawing)

    // We need: Sun position, P position (orbit center), Planet position, Perihelion position
    if (fixedPerihelionObj && childPlanet && sun && sun.pivotObj) {
      // Get world positions (using pooled vectors for performance)
      sun.pivotObj.getWorldPosition(_hiSunPos);
      fixedPerihelionObj.pivotObj.getWorldPosition(_hiPPos);  // P = orbit center
      if (childPlanet.planetObj) {
        childPlanet.planetObj.getWorldPosition(_hiPlanetPos);
      } else if (childPlanet.pivotObj) {
        childPlanet.pivotObj.getWorldPosition(_hiPlanetPos);
      }
      // Perihelion point (the marker on the orbit)
      if (fixedPerihelionObj.planetObj) {
        fixedPerihelionObj.planetObj.getWorldPosition(_hiPerihelionPos);
      }

      // Calculate direction vectors (in XZ plane - ecliptic)
      // In an elliptical orbit:
      // - P (center) is at the geometric center of the ellipse
      // - Sun (focus) is between P and perihelion, at distance a*e from P
      // - Perihelion is in the direction from P toward Sun, beyond the Sun
      //
      // Layout: P -------- Sun ------- Perihelion
      //
      // So perihelion direction from both P and Sun is: P → Sun direction

      // Perihelion direction (from P toward Sun and perihelion)
      const periDirX = _hiSunPos.x - _hiPPos.x;
      const periDirZ = _hiSunPos.z - _hiPPos.z;

      // For both True Anomaly and Mean Anomaly, the perihelion reference is the same direction
      const periDirFromSunX = periDirX;
      const periDirFromSunZ = periDirZ;
      const periDirFromPX = periDirX;
      const periDirFromPZ = periDirZ;

      // Planet direction from Sun (for True Anomaly)
      const planetDirFromSunX = _hiPlanetPos.x - _hiSunPos.x;
      const planetDirFromSunZ = _hiPlanetPos.z - _hiSunPos.z;

      // Planet direction from P (for Mean Anomaly)
      const planetDirFromPX = _hiPlanetPos.x - _hiPPos.x;
      const planetDirFromPZ = _hiPlanetPos.z - _hiPPos.z;

      // Calculate angles using atan2 (counter-clockwise from +X axis)
      // Note: Three.js uses right-handed coords, +Z toward viewer
      // Negate Z for standard counter-clockwise angle measurement
      periAngleSun = Math.atan2(-periDirFromSunZ, periDirFromSunX);
      const planetAngleSun = Math.atan2(-planetDirFromSunZ, planetDirFromSunX);

      periAngleP = Math.atan2(-periDirFromPZ, periDirFromPX);
      const planetAngleP = Math.atan2(-planetDirFromPZ, planetDirFromPX);

      // True Anomaly: angle at Sun from perihelion to planet
      trueAnomalyRad = planetAngleSun - periAngleSun;

      // Mean Anomaly: angle at P from perihelion to planet
      meanAnomalyRad = planetAngleP - periAngleP;

      // Normalize to 0 to 2*PI range
      trueAnomalyRad = ((trueAnomalyRad % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
      meanAnomalyRad = ((meanAnomalyRad % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);

      // Update the new visualization lines (P→Planet and Sun→Planet)
      if (hierarchyInspector.pToPlanetLine) {
        const positions = hierarchyInspector.pToPlanetLine.geometry.attributes.position.array;
        positions[0] = _hiPPos.x; positions[1] = _hiPPos.y; positions[2] = _hiPPos.z;
        positions[3] = _hiPlanetPos.x; positions[4] = _hiPlanetPos.y; positions[5] = _hiPlanetPos.z;
        hierarchyInspector.pToPlanetLine.geometry.attributes.position.needsUpdate = true;
      }

      if (hierarchyInspector.sunToPlanetLine) {
        const positions = hierarchyInspector.sunToPlanetLine.geometry.attributes.position.array;
        positions[0] = _hiSunPos.x; positions[1] = _hiSunPos.y; positions[2] = _hiSunPos.z;
        positions[3] = _hiPlanetPos.x; positions[4] = _hiPlanetPos.y; positions[5] = _hiPlanetPos.z;
        hierarchyInspector.sunToPlanetLine.geometry.attributes.position.needsUpdate = true;
      }

      // Update Mean Anomaly Arc (centered at P, sweeps from perihelion to planet)
      if (hierarchyInspector.meanAnomalyArcAtP) {
        const arcRadius = hierarchyInspector._meanArcAtPRadius || 20;
        const positions = hierarchyInspector.meanAnomalyArcAtP.geometry.attributes.position.array;
        const arcSegments = 64;

        for (let i = 0; i <= arcSegments; i++) {
          const t = i / arcSegments;
          const angle = periAngleP + t * meanAnomalyRad;
          positions[i * 3] = _hiPPos.x + arcRadius * Math.cos(angle);
          positions[i * 3 + 1] = _hiPPos.y;
          positions[i * 3 + 2] = _hiPPos.z - arcRadius * Math.sin(angle);
        }
        hierarchyInspector.meanAnomalyArcAtP.geometry.attributes.position.needsUpdate = true;
        hierarchyInspector.meanAnomalyArcAtP.computeLineDistances();
      }

      // Update True Anomaly Arc (centered at Sun, sweeps from perihelion to planet)
      if (hierarchyInspector.trueAnomalyArcAtSun) {
        const arcRadius = hierarchyInspector._trueArcAtSunRadius || 25;
        const positions = hierarchyInspector.trueAnomalyArcAtSun.geometry.attributes.position.array;
        const arcSegments = 64;

        for (let i = 0; i <= arcSegments; i++) {
          const t = i / arcSegments;
          const angle = periAngleSun + t * trueAnomalyRad;
          positions[i * 3] = _hiSunPos.x + arcRadius * Math.cos(angle);
          positions[i * 3 + 1] = _hiSunPos.y;
          positions[i * 3 + 2] = _hiSunPos.z - arcRadius * Math.sin(angle);
        }
        hierarchyInspector.trueAnomalyArcAtSun.geometry.attributes.position.needsUpdate = true;
      }
    }

    // Update display values (convert to degrees)
    const meanAnomalyDeg = meanAnomalyRad * 180 / Math.PI;
    const trueAnomalyDeg = trueAnomalyRad * 180 / Math.PI;
    window._meanAnomaly = meanAnomalyDeg;
    window._trueAnomaly = trueAnomalyDeg;

    // Update the UI display immediately after calculation
    // (The earlier display update in the function runs before these values are calculated)
    if (_liveDataElements && _liveDataElements.meanAnomaly) {
      _liveDataElements.meanAnomaly.textContent = meanAnomalyDeg.toFixed(2) + '°';
    }
    if (_liveDataElements && _liveDataElements.trueAnomaly) {
      _liveDataElements.trueAnomaly.textContent = trueAnomalyDeg.toFixed(2) + '°';
    }
    if (_liveDataElements && _liveDataElements.equationOfCenter) {
      const equationOfCenter = trueAnomalyDeg - meanAnomalyDeg;
      _liveDataElements.equationOfCenter.textContent = (equationOfCenter >= 0 ? '+' : '') + equationOfCenter.toFixed(2) + '°';
    }

    // Keep existing arc visualization for Earth-Sun line (legacy, still useful)
    // The arc should sweep counter-clockwise from perihelion (0°) to the Earth-Sun line
    let arcAngle = -earthSunLocalAngle;
    arcAngle = ((arcAngle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);

    // Update true anomaly arc (from perihelion 0° to Earth-Sun line)
    // NOTE: This OLD arc uses arcAngle (Earth-Sun angle), not the new trueAnomalyRad
    if (hierarchyInspector.trueAnomalyArc) {
      const arcSegments = 32;
      const arcRadius = hierarchyInspector._trueArcRadius || 50;
      const positions = hierarchyInspector.trueAnomalyArc.geometry.attributes.position.array;

      for (let i = 0; i <= arcSegments; i++) {
        const t = i / arcSegments;
        const angle = t * arcAngle; // From 0 to Earth-Sun line (NOT trueAnomalyRad!)
        positions[i * 3] = arcRadius * Math.cos(angle);     // X
        positions[i * 3 + 1] = 0;                            // Y
        positions[i * 3 + 2] = -arcRadius * Math.sin(angle); // Z (negative for counter-clockwise)
      }
      hierarchyInspector.trueAnomalyArc.geometry.attributes.position.needsUpdate = true;
    }

    // Update mean anomaly arc (from perihelion 0° to Earth-Sun line)
    // NOTE: This OLD arc uses arcAngle (Earth-Sun angle), not the new meanAnomalyRad
    if (hierarchyInspector.meanAnomalyArc) {
      const arcSegments = 32;
      const arcRadius = hierarchyInspector._meanArcRadius || 40;
      const positions = hierarchyInspector.meanAnomalyArc.geometry.attributes.position.array;

      for (let i = 0; i <= arcSegments; i++) {
        const t = i / arcSegments;
        const angle = t * arcAngle; // From 0 to Earth-Sun line (NOT meanAnomalyRad!)
        positions[i * 3] = arcRadius * Math.cos(angle);     // X
        positions[i * 3 + 1] = 0;                            // Y
        positions[i * 3 + 2] = -arcRadius * Math.sin(angle); // Z (negative for clockwise in Three.js)
      }
      hierarchyInspector.meanAnomalyArc.geometry.attributes.position.needsUpdate = true;
      hierarchyInspector.meanAnomalyArc.computeLineDistances();
    }
  }

  // Update ascending/descending node marker positions based on dynamic ascending node
  // The inclinationPlane is attached to containerObj, which rotates based on dynamic ascending node.
  // We need to recalculate the LOCAL positions where the orbital plane intersects the ecliptic.

  // DEBUG: Check if hierarchy inspector visuals exist
  if (_debugAscendingNodeLogEnabled && hierarchyInspector.currentPlanet === 'mercury') {
    const now = Date.now();
    if (now - _debugAscendingNodeLastLog < _debugAscendingNodeInterval + 150) {
      const hasPlane = !!hierarchyInspector.inclinationPlane;
      const hasAsc = !!hierarchyInspector.ascendingNode;
      const hasDesc = !!hierarchyInspector.descendingNode;
      console.log(`📐 Hierarchy inspector: plane=${hasPlane}, ascNode=${hasAsc}, descNode=${hasDesc}`);
    }
  }

  if (hierarchyInspector.inclinationPlane && hierarchyInspector.ascendingNode && hierarchyInspector.descendingNode) {
    const planetKey = hierarchyInspector.currentPlanet;
    const realPerihelionObjects = {
      mercury: mercuryRealPerihelionAtSun,
      venus: venusRealPerihelionAtSun,
      mars: marsRealPerihelionAtSun,
      jupiter: jupiterRealPerihelionAtSun,
      saturn: saturnRealPerihelionAtSun,
      uranus: uranusRealPerihelionAtSun,
      neptune: neptuneRealPerihelionAtSun,
      pluto: plutoRealPerihelionAtSun,
      halleys: halleysRealPerihelionAtSun,
      eros: erosRealPerihelionAtSun
    };
    const obj = realPerihelionObjects[planetKey];

    if (obj && obj.containerObj) {
      // Get the current container rotation (which reflects the dynamic ascending node)
      const tiltaRad = obj.containerObj.rotation.x;
      const tiltbRad = obj.containerObj.rotation.z;

      // PERFORMANCE: Skip expensive recalculation if tilt hasn't changed significantly (>0.0001 rad ≈ 0.006°)
      const tiltChanged = _lastAscNodeTiltA === null ||
        Math.abs(tiltaRad - _lastAscNodeTiltA) > 0.0001 ||
        Math.abs(tiltbRad - _lastAscNodeTiltB) > 0.0001;

      // DEBUG: Check if tiltChanged is blocking the update
      if (_debugAscendingNodeLogEnabled && hierarchyInspector.currentPlanet === 'mercury') {
        const now = Date.now();
        if (now - _debugAscendingNodeLastLog < _debugAscendingNodeInterval + 200) {
          console.log(`🔄 tiltChanged=${tiltChanged}, tiltaRad=${tiltaRad.toFixed(6)}, lastA=${_lastAscNodeTiltA?.toFixed(6) || 'null'}`);
        }
      }

      if (tiltChanged) {
        _lastAscNodeTiltA = tiltaRad;
        _lastAscNodeTiltB = tiltbRad;

        // Build the local-to-world transformation matrix (reuse pooled matrix and euler)
        _liveDataEuler.set(tiltaRad, 0, tiltbRad, 'XYZ');
        _liveDataLocalToWorld.makeRotationFromEuler(_liveDataEuler);

        // Get the scale used for the inclination plane
        const scale = hierarchyInspector._perihelionArrowScale || 100;
        const planeRadius = scale * 0.5;

        // Get the ACTUAL ascending node angle from the o.xxxAscendingNode property
        // This is the authoritative value that's dynamically calculated for the current date
        const ascNodePropertyMap = {
          mercury: 'mercuryAscendingNode',
          venus: 'venusAscendingNode',
          mars: 'marsAscendingNode',
          jupiter: 'jupiterAscendingNode',
          saturn: 'saturnAscendingNode',
          uranus: 'uranusAscendingNode',
          neptune: 'neptuneAscendingNode',
          pluto: 'plutoAscendingNode',
          halleys: 'halleysAscendingNode',
          eros: 'erosAscendingNode'
        };
        const ascNodeProp = ascNodePropertyMap[hierarchyInspector.currentPlanet];
        const ascNodeAngleDeg = ascNodeProp ? (o[ascNodeProp] || 0) : 0;
        const ascNodeAngleRad = ascNodeAngleDeg * Math.PI / 180;

        // Calculate ascending node position in LOCAL coordinates
        // Our model is 90° rotated (from March 21 to June 21), so we add 90° counterclockwise
        // After 90° CCW rotation: X = -sin(angle), Z = -cos(angle)
        _liveDataNewAscPos.set(
          planeRadius * -Math.sin(ascNodeAngleRad),
          0,
          planeRadius * -Math.cos(ascNodeAngleRad)
        );

        // Descending node is 180° opposite
        _liveDataNewDescPos.set(
          -_liveDataNewAscPos.x,
          0,
          -_liveDataNewAscPos.z
        );

        // Update marker positions
        hierarchyInspector.ascendingNode.position.copy(_liveDataNewAscPos);
        hierarchyInspector.descendingNode.position.copy(_liveDataNewDescPos);

        // Update the arrows attached to the nodes using cached references if available
        // PERFORMANCE: Use cached references instead of searching children
        if (hierarchyInspector._ascNodeArrow) {
          hierarchyInspector._ascNodeArrow.position.copy(_liveDataNewAscPos);
        }
        if (hierarchyInspector._descNodeArrow) {
          hierarchyInspector._descNodeArrow.position.copy(_liveDataNewDescPos);
        }

        // Update the line of nodes using cached reference
        if (hierarchyInspector._nodesLine) {
          const positions = hierarchyInspector._nodesLine.geometry.attributes.position.array;
          positions[0] = _liveDataNewAscPos.x;
          positions[1] = _liveDataNewAscPos.y;
          positions[2] = _liveDataNewAscPos.z;
          positions[3] = _liveDataNewDescPos.x;
          positions[4] = _liveDataNewDescPos.y;
          positions[5] = _liveDataNewDescPos.z;
          hierarchyInspector._nodesLine.geometry.attributes.position.needsUpdate = true;
          hierarchyInspector._nodesLine.computeLineDistances();
        }

        // Update the half-plane geometries (green above / red below ecliptic)
        // PERFORMANCE: Reuse orbit point arrays instead of recreating
        if (hierarchyInspector.aboveHalfPlane && hierarchyInspector.belowHalfPlane) {
          const numPoints = 64;

          // DEBUG: Test if ascending node world Y is ~0 (it should be, since that's where orbit crosses ecliptic)
          if (_debugAscendingNodeLogEnabled && hierarchyInspector.currentPlanet === 'mercury') {
            const now = Date.now();
            if (now - _debugAscendingNodeLastLog < _debugAscendingNodeInterval + 500) {
              const testX = planeRadius * -Math.sin(ascNodeAngleRad);
              const testZ = planeRadius * -Math.cos(ascNodeAngleRad);
              _liveDataDebugLocal.set(testX, 0, testZ);
              _liveDataDebugWorld.copy(_liveDataDebugLocal).applyMatrix4(_liveDataLocalToWorld);
              // Also get actual marker world position
              if (hierarchyInspector.ascendingNode) {
                hierarchyInspector.ascendingNode.getWorldPosition(_liveDataDebugMarker);
              }
              console.log(`🟢🔴 Asc node: local(${testX.toFixed(1)}, 0, ${testZ.toFixed(1)}) → matrixY: ${_liveDataDebugWorld.y.toFixed(4)}, actualWorldPos: (${_liveDataDebugMarker.x.toFixed(1)}, ${_liveDataDebugMarker.y.toFixed(4)}, ${_liveDataDebugMarker.z.toFixed(1)})`);
            }
          }

          // Helper to rebuild half-disc geometry (uses pooled arrays for performance)
          const rebuildHalfDiscGeometry = (mesh, isAbove) => {
            // Center point at index 0
            _halfDiscVertices[0] = 0;
            _halfDiscVertices[1] = 0;
            _halfDiscVertices[2] = 0;

            // Generate points
            for (let i = 0; i <= numPoints; i++) {
              const angle = (i / numPoints) * Math.PI * 2;
              const idx = (i + 1) * 3;
              _halfDiscVertices[idx] = planeRadius * Math.cos(angle);
              _halfDiscVertices[idx + 1] = 0;
              _halfDiscVertices[idx + 2] = planeRadius * Math.sin(angle);
            }

            // Clear and rebuild indices based on world Y position
            _halfDiscIndices.length = 0;
            for (let i = 1; i <= numPoints; i++) {
              const angle1 = ((i - 1) / numPoints) * Math.PI * 2;
              const angle2 = (i / numPoints) * Math.PI * 2;

              // Calculate world Y for midpoint (reuse pooled vectors)
              _liveDataLocalPt.set(planeRadius * Math.cos(angle1), 0, planeRadius * Math.sin(angle1));
              _liveDataWorldPt.copy(_liveDataLocalPt).applyMatrix4(_liveDataLocalToWorld);
              const y1 = _liveDataWorldPt.y;

              _liveDataLocalPt.set(planeRadius * Math.cos(angle2), 0, planeRadius * Math.sin(angle2));
              _liveDataWorldPt.copy(_liveDataLocalPt).applyMatrix4(_liveDataLocalToWorld);
              const y2 = _liveDataWorldPt.y;

              const midWorldY = (y1 + y2) / 2;
              const segmentIsAbove = midWorldY > 0;

              if (segmentIsAbove === isAbove) {
                _halfDiscIndices.push(0, i, i + 1);
              }
            }

            // Update geometry - reuse existing BufferAttribute if possible
            const posAttr = mesh.geometry.attributes.position;
            if (posAttr && posAttr.array.length === _halfDiscVertices.length) {
              posAttr.array.set(_halfDiscVertices);
              posAttr.needsUpdate = true;
            } else {
              mesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute(_halfDiscVertices.slice(), 3));
            }
            mesh.geometry.setIndex(_halfDiscIndices);
            mesh.geometry.computeVertexNormals();
            if (mesh.geometry.index) mesh.geometry.index.needsUpdate = true;
          };

          rebuildHalfDiscGeometry(hierarchyInspector.aboveHalfPlane, true);
          rebuildHalfDiscGeometry(hierarchyInspector.belowHalfPlane, false);
        }

        // Update highest/lowest point markers (90° after ascending/descending nodes)
        // PERFORMANCE: Use pooled vectors
        if (hierarchyInspector.highestPointMarker && hierarchyInspector.lowestPointMarker) {
          let maxWorldY = -Infinity;
          let minWorldY = Infinity;
          _liveDataNewHighPos.set(0, 0, 0);
          _liveDataNewLowPos.set(0, 0, 0);

          const numSamples = 360;
          for (let i = 0; i < numSamples; i++) {
            const angle = (i / numSamples) * Math.PI * 2;
            _liveDataLocalPt.set(planeRadius * Math.cos(angle), 0, planeRadius * Math.sin(angle));
            _liveDataWorldPt.copy(_liveDataLocalPt).applyMatrix4(_liveDataLocalToWorld);

            if (_liveDataWorldPt.y > maxWorldY) {
              maxWorldY = _liveDataWorldPt.y;
              _liveDataNewHighPos.copy(_liveDataLocalPt);
            }
            if (_liveDataWorldPt.y < minWorldY) {
              minWorldY = _liveDataWorldPt.y;
              _liveDataNewLowPos.copy(_liveDataLocalPt);
            }
          }

          // Update marker positions
          hierarchyInspector.highestPointMarker.position.copy(_liveDataNewHighPos);
          hierarchyInspector.lowestPointMarker.position.copy(_liveDataNewLowPos);

          // Update arrows
          if (hierarchyInspector._highArrow) {
            hierarchyInspector._highArrow.position.copy(_liveDataNewHighPos);
          }
          if (hierarchyInspector._lowArrow) {
            hierarchyInspector._lowArrow.position.copy(_liveDataNewLowPos);
          }
        }
      } // End of tiltChanged block
    }
  }

  // Update perihelion arrow (green line from P to Sun)
  if (hierarchyInspector.perihelionArrow && hierarchyInspector._fixedPerihelionObj) {
    const fixedPerihelion = hierarchyInspector._fixedPerihelionObj;

    // Use planetObj if available, otherwise fall back to pivotObj
    const sourceObj = fixedPerihelion.planetObj || fixedPerihelion.pivotObj;
    if (sourceObj) {
      // Reuse vectors for performance (using existing _liveDataVec3 pattern)
      sourceObj.getWorldPosition(_liveDataVec3);

      // Get Sun's world position using a second reusable vector
      if (!hierarchyInspector._sunPosVec3) {
        hierarchyInspector._sunPosVec3 = new THREE.Vector3();
      }
      if (sun && sun.pivotObj) {
        sun.pivotObj.getWorldPosition(hierarchyInspector._sunPosVec3);
      }

      // Position the arrow group at the P point
      hierarchyInspector.perihelionArrow.position.copy(_liveDataVec3);

      // Calculate direction to Sun and make the arrow look at it
      if (!hierarchyInspector._dirVec3) {
        hierarchyInspector._dirVec3 = new THREE.Vector3();
        hierarchyInspector._defaultDir = new THREE.Vector3(0, 0, 1);
        hierarchyInspector._arrowQuat = new THREE.Quaternion();
      }
      hierarchyInspector._dirVec3.subVectors(hierarchyInspector._sunPosVec3, _liveDataVec3).normalize();

      // Only update rotation if direction is valid (not zero length)
      if (hierarchyInspector._dirVec3.lengthSq() > 0.0001) {
        hierarchyInspector._arrowQuat.setFromUnitVectors(hierarchyInspector._defaultDir, hierarchyInspector._dirVec3);
        hierarchyInspector.perihelionArrow.setRotationFromQuaternion(hierarchyInspector._arrowQuat);
      }
    }
  }

  // Update planet locator circle position (follows the planet)
  if (hierarchyInspector._planetLocatorCircle && hierarchyInspector._planetLocatorTarget) {
    const target = hierarchyInspector._planetLocatorTarget;
    if (target.planetObj) {
      target.planetObj.getWorldPosition(_liveDataVec3);
      hierarchyInspector._planetLocatorCircle.position.copy(_liveDataVec3);
      // Make the circle face the camera for better visibility
      hierarchyInspector._planetLocatorCircle.lookAt(camera.position);
    }
  }
  } catch (err) {
    console.error('[HierarchyLiveData] Error:', err);
  }
}

//*************************************************************
// CREATE SETTINGS AND SETUP GUI
//*************************************************************
setupGUI()
function setupGUI() {
  const gui = new dat.GUI({ width: 300 });
  gui.domElement.id = 'gui';
  gui.add(o, 'Date').name('Date (Y-M-D)').listen().onFinishChange(() => {
    if (isValidDate(o.Date)) {
      updatePosition();
    }
  });
  
  gui.add(o, 'Time').name('Time (UTC)').listen().onFinishChange(function() {
    if (isValidTime(o.Time)) {
      updatePosition();
    } 
  });

//  gui.add(o, 'julianDay').name('Julian day').listen().onFinishChange(() => {
//    if (isNumeric(o.julianDay)) {
//      o.Day = o.julianDay - startmodelJD;
//      o.pos = sDay * o.Day + timeToPos(o.Time);
//      const p = dayToDateNew(o.julianDay,'julianday','perihelion-calendar');
//      o.perihelionDate = `${p.date}`;
//    }
//  });
  
  gui.add(o, 'julianDay').name('Julian day').listen()
  .onFinishChange(() => {
    if (!isNumeric(o.julianDay)) return;
    
    const newJD = Number(o.julianDay);
    const currentJD = dateTimeToJulianDay(o.Date, o.Time);
    
    // Skip if value hasn't meaningfully changed
    if (Math.abs(newJD - currentJD) < 0.0000001) {
      return;
    }

    // Convert Julian Day to date and time  <-- THIS IS THE MISSING PART
    const converted = dayToDate(newJD);
    o.Date = converted.date;
    o.Time = converted.time;

    // Update internal state (now using the NEW o.Time)
    o.Day = newJD - startmodelJD;
    o.pos = sDay * o.Day;  // Day already includes the time fraction

    // Update perihelion calendar display
    const p = dayToDateNew(newJD, 'julianday', 'perihelion-calendar');
    o.perihelionDate = `${p.date}`;

    positionChanged = true; // Signal animation loop to update scene
  });
  
  const perihelionController = gui.add(o, 'perihelionDate')
  .name('Perihelion Date')
  .listen(); // display-only

  if (perihelionController.__li) {
  perihelionController.__li.classList.add('highlight-perihelion');
  }
  
  let ctrlFolder = gui.addFolder('Simulation Controls')
  ctrlFolder.add(o, 'Run').listen();
  ctrlFolder.add(o, '1 second equals', 
                 {  '1 second': sSecond, 
                    '1 minute': sMinute, 
                    '1 hour': sHour, 
                    '1 day': sDay, 
                    '1 week': sWeek, 
                    '1 month': sMonth,  
                    '1 year': sYear, 
                    '10 years': sYear*10,
                    '100 years': sYear*100,
                    '1000 years': sYear*1000,
                 }).onFinishChange(function() {
    o.speedFact = Number(o['1 second equals']);});
  ctrlFolder.add(o, 'speed', -5, 5).step(0.5).name('Speed multiplier');
  
  function toggleCtrl (ctrl, show) {
  if (ctrl && ctrl.__li) ctrl.__li.style.display = show ? '' : 'none';
  }
  
  ctrlFolder.add(o, 'traceBtn').name('Enable Tracing').onFinishChange(() => {
  if (o.traceBtn) {
    // Tracing turned ON → reset and re-init
    resetAllTraces();
  } else {
    // Tracing turned OFF → remove all traces and stop drawing
    tracePlanets.forEach(obj => {
      if (obj.traceLine && obj.traceLine instanceof THREE.Object3D) {
        scene.remove(obj.traceLine);
      }
      obj.traceLine = undefined;
      obj.traceArrIndex = 0;
      obj.traceStartPos = o.pos;
      obj.traceCurrPos = o.pos;
    });
  }
  });

  let folderT = ctrlFolder.addFolder('Select objects to Trace')  
  
  tracePlanets.forEach(obj => {
    folderT.add(obj, 'traceOn').name(obj.name).onFinishChange(()=>{resetAllTraces(obj)})
  });

  ctrlFolder.add(o, 'Step forward' );
  ctrlFolder.add(o, 'Step backward' );
  ctrlFolder.add(o, 'Reset' );
  ctrlFolder.add(o, 'Now (time in UTC)' );
  
  let planetList = {}
  let isHelper = {}
  
  planetObjects.forEach(obj => {
    const isHelperObj =
        (obj.isNotPhysicalObject === true) || (obj.visible === false);
    if (isHelperObj) {
      isHelper[obj.name]  = obj.name;   // put in helper list
    } else {
      planetList[obj.name] = obj.name;  // put in normal-planet list
    }
  });

  ctrlFolder
  .add(o, 'Target', { 'Please select': "", ...planetList }).name('Look at').onFinishChange(value => {

    /* value === ''  →  no planet selected */
    o.lookAtObj = planetObjects.find(p => p.name === value) || undefined;

    /* Disable hierarchy inspector camera control when user manually changes target */
    hierarchyInspector._cameraControlActive = false;
    hierarchyInspector._cameraTarget = null;

    /* Signal animation loop to update scene (needed when idle) */
    positionChanged = true;

    /* Reset camera parameters for the new target */
    focusPlanet(o.lookAtObj);

    /* hide every orbit-plane helper … */
    planetObjects.forEach(p => {
      if (p.orbitPlaneHelper) p.orbitPlaneHelper.visible = false;
    });

    /* … and show only the helper of the chosen planet (if any) */
    if (o.lookAtObj?.orbitPlaneHelper) {
      o.lookAtObj.orbitPlaneHelper.visible = true;
    }
  });
  focusPlanet(o.lookAtObj);
  ctrlFolder.open() 
  
  let astroFolder = gui.addFolder('Predictions Holistic Universe Model');

    let daysFolder = astroFolder.addFolder('Length of Days Predictions');
      daysFolder.add(predictions, 'lengthofDay').name('Length of Day (sec)').step(0.000001).listen();
      daysFolder.add(predictions, 'lengthofsiderealDayRealLOD').name('Length of Sidereal Day (sec)').step(0.000001).listen();
      daysFolder.add(predictions, 'lengthofstellarDayRealLOD').name('Length of Stellar Day (sec)').step(0.000001).listen();  
    daysFolder.open();
  
    let yearsFolder = astroFolder.addFolder('Length of Solar Year Predictions'); 
      yearsFolder.add(predictions, 'lengthofsolarYearSecRealLOD').name('Length of Solar Year (sec)').step(0.000001).listen();
      yearsFolder.add(predictions, 'lengthofsolarYear').name('Length of Solar Year (days)').step(0.000001).listen();
    yearsFolder.open(); 
  
    let siderealFolder = astroFolder.addFolder('Length of Sidreal Year Predictions'); 
      siderealFolder.add(predictions, 'lengthofsiderealYear').name('Length of Sidereal Year (sec)').step(0.000001).listen(); 
      siderealFolder.add(predictions, 'lengthofsiderealYearDaysRealLOD').name('Length of Sidereal Year (days)').step(0.000001).listen();
    siderealFolder.open(); 
  
    let anomalisticFolder = astroFolder.addFolder('Length of Anomalistic Year - Predictions');
      anomalisticFolder.add(predictions, 'lengthofanomalisticYearRealLOD').name('Length of Anomalistic Year (sec)').step(0.000001).listen();
      anomalisticFolder.add(predictions, 'lengthofanomalisticDaysRealLOD').name('Length of Anomalistic Year (days)').step(0.000001).listen();
    anomalisticFolder.open(); 
  
    let precessionFolder = astroFolder.addFolder('Length of Precession - Predictions');
      precessionFolder.add(predictions, 'perihelionPrecessionRealLOD').name('Perihelion Precession (yrs)').step(0.000001).listen();
      precessionFolder.add(predictions, 'axialPrecessionRealLOD').name('Axial Precession (yrs)').step(0.000001).listen();
      precessionFolder.add(predictions, 'inclinationPrecessionRealLOD').name('Inclination Precession (yrs)').step(0.000001).listen();
      precessionFolder.add(predictions, 'eclipticPrecessionRealLOD').name('Length Ecliptic Cycle (yrs)').step(0.000001).listen();
      precessionFolder.add(predictions, 'obliquityPrecessionRealLOD').name('Length Obliquity Cycle (yrs)').step(0.000001).listen();
    precessionFolder.open(); 
  
    let orbitalFolder = astroFolder.addFolder('Orbital Elements Predictions');
      orbitalFolder.add(predictions, 'eccentricityEarth').name('Earth Orbital Eccentricity (AU)').step(0.000001).listen();
      orbitalFolder.add(predictions, 'obliquityEarth').name('Earth Obliquity (°)').step(0.000001).listen();
      orbitalFolder.add(predictions, 'earthInvPlaneInclinationDynamic').name('Earth Inclination to invariable plane (°)').step(0.000001).listen();
      orbitalFolder.add(predictions, 'longitudePerihelion').name('Earth Longitude of Perihelion (°)').step(0.000001).listen();
      orbitalFolder.add(predictions, 'lengthofAU').name('Length of AU (km)').step(0.000001).listen();
      //orbitalFolder.add(predictions, 'anomalisticMercury').name('Missing Mercury Advance (arcsec)').step(0.000001).listen();
    orbitalFolder.open(); 
  
  //    let ephemerisFolder = astroFolder.addFolder('86400 sec/day - Predictions'); 
  //      ephemerisFolder.add(predictions, 'predictedDeltat').name('Delta-T (sec)').step(0.000001).listen();
  //      ephemerisFolder.add(predictions, 'predictedDeltatPerYear').name('ΔT change (sec/year)').step(0.000001).listen();
  //    ephemerisFolder.add(predictions, 'lengthofsolarDay').name('86400 sec/day - Length of Solar Day (sec)').step(0.000001).listen();
  //    ephemerisFolder.add(predictions, 'lengthofsiderealDay').name('86400 sec/day - Length of Sidereal Day (sec)').step(0.000001).listen();
  //    ephemerisFolder.add(predictions, 'lengthofstellarDay').name('86400 sec/day - Length of Stellar Day (sec)').step(0.000001).listen();
  //    ephemerisFolder.add(predictions, 'lengthofsolarYearinDays').name('86400 sec/day - Length of Solar Year (days)').step(0.000001).listen();
  //    ephemerisFolder.add(predictions, 'lengthofsiderealYearDays').name('86400 sec/day - Length of Sidereal Year (days)').step(0.000001).listen();
  //    ephemerisFolder.add(predictions, 'lengthofanomalisticYearinDays').name('86400 sec/day - Length of Anomalistic Year (days)').step(0.000001).listen();
  //  ephemerisFolder.open();
  
  astroFolder.close();
  
  let posFolder = gui.addFolder('Celestial Positions')
  posFolder
  .add(o, 'displayFormat', ['sexagesimal', 'decimal'])
  .name('RA/Dec Format')
  .onChange(() => {
    updatePositions();
    updatePositionDisplayStrings(); // Update display strings immediately
  });

  posFolder
  .add(o, 'distanceUnit', ['AU', 'km', 'mi'])
  .name('Distance Format')
  .onChange(() => {
    updatePositions();
    updatePositionDisplayStrings(); // Update display strings immediately
  });
  
  const helperFolder = posFolder.addFolder('Show Helper Objects');
  
  tracePlanets.forEach(obj => {
  const isHelperObj  = Boolean(isHelper[obj.name]);
  // helpers → helperFolder, planets → posFolder directly
  const targetFolder = isHelperObj ? helperFolder : posFolder;

  const sub = targetFolder.addFolder(obj.name);
  sub.add(obj, 'raDisplay').name('RA').listen();
  sub.add(obj, 'decDisplay').name('Dec').listen();
  sub.add(obj, 'distDisplay').name('Distance to Earth').listen();
  sub.add(obj, 'sunDistDisplay').name('Distance to Sun').listen();
  sub.open();
  });
  
  let folderPerihelion = gui.addFolder('Perihelion Planets')
  folderPerihelion.add(golden.goldenLine, 'visible').name('Perihelion Spiral').onChange( v => golden.setHelpersVisible(v) );
  addInfoButton( folderPerihelion, 'https://wgc.jpl.nasa.gov:8443/webgeocalc/#OrbitalElements' );
  // Earth-frame (fluctuates with Earth's precession cycles)
  folderPerihelion.add(o,"mercuryPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Mercury (Earth)")
  folderPerihelion.add(o,"mercuryPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Mercury (Ecliptic)")
  folderPerihelion.add(o,"venusPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Venus (Earth)")
  folderPerihelion.add(o,"venusPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Venus (Ecliptic)")
  folderPerihelion.add(o,"earthPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Earth Perihelion")
  folderPerihelion.add(o,"marsPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Mars (Earth)")
  folderPerihelion.add(o,"marsPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Mars (Ecliptic)")
  folderPerihelion.add(o,"jupiterPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Jupiter (Earth)")
  folderPerihelion.add(o,"jupiterPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Jupiter (Ecliptic)")
  folderPerihelion.add(o,"saturnPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Saturn (Earth)")
  folderPerihelion.add(o,"saturnPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Saturn (Ecliptic)")
  folderPerihelion.add(o,"uranusPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Uranus (Earth)")
  folderPerihelion.add(o,"uranusPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Uranus (Ecliptic)")
  folderPerihelion.add(o,"neptunePerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Neptune (Earth)")
  folderPerihelion.add(o,"neptunePerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Neptune (Ecliptic)")
  folderPerihelion.add(o,"plutoPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Pluto (Earth)")
  folderPerihelion.add(o,"plutoPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Pluto (Ecliptic)")
  folderPerihelion.add(o,"halleysPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Halleys (Earth)")
  folderPerihelion.add(o,"halleysPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Halleys (Ecliptic)")
  folderPerihelion.add(o,"erosPerihelion").min(0.0).max(360.0).step(0.000001).listen().name("Eros (Earth)")
  folderPerihelion.add(o,"erosPerihelionEcliptic").min(0.0).max(360.0).step(0.000001).listen().name("Eros (Ecliptic)")   
  
  let folderO = gui.addFolder('Celestial Tools')
  folderO.add(zodiac, 'visible').name('Zodiac');
  folderO.add(o, 'zodiacSize', 0.01, 10).step(0.1).name('Zodiac size').onChange(()=>{changeZodiacScale()})
  folderO.add(o, 'Polar line').onFinishChange(()=>{
    polarLine.visible = o['Polar line']
  });
  folderO.add(o, 'polarLineLength', 0.1, 50).name('Line length').onChange(()=>{
      polarLine.scale.y = o.polarLineLength
  });
  
  folderO.add(sceneObjects.stars, 'visible').name('Stars visible');

  folderO.add(o, 'starNamesVisible').name('Star names')
  .onChange(visible => {
    sceneObjects.stars.children.forEach(child => {
      if (child instanceof CSS2DObject) {
        child.visible = visible;
      }
    });
    needsLabelUpdate = true;  // ensure your next frame re‐draws all labels
  });

  folderO.add(sceneObjects.constellations, 'visible').name('Constellations visible');
  folderO.add(o, 'constellationLayout', {
  'Traditional (Asterism)': 'asterism',
  'Artistic (Curved)':  'stellarium'
  })
  .name('Constellation Style')
  .onChange(() => {
    initConstellations();   // re–draw with the new style
  });
  
  folderO.add(o, 'starDistanceScaleFact', 0.1, 2).step(0.1).name('Star distance').onChange(factor => {

    // scale all Three.js objects (Mesh, Group, etc.)
    scalableObjects.forEach(obj => obj.scale.setScalar(factor));

    // 2 – tell the label renderer that it has to recompute the screen-space position of every CSS2DObject next frame
    needsLabelUpdate = true;
    
  });

  // ← no star-size here; that slider lives inside initStars()

  folderO.add(celestialSphere, 'visible').name('Celestial sphere')
  folderO.add(plane, 'visible').name('Ecliptic grid')
  folderO.add(sunCenteredInvPlane, 'visible').name('Invariable plane').onChange(function(value) {
    // Show/hide node markers and height label when toggling
    sunCenteredNodeMarkers.visible = value;
    setCSS2DVisibility(sunCenteredNodeMarkers, value);
    sunCenteredHeightLabel.visible = value;
    // Force immediate update when becoming visible
    if (value) {
      updateSunCenteredInvPlane();
    }
    needsLabelUpdate = true;
  });
  folderO.add(invariablePlaneGroup, 'visible').name('Earth Inclination to Invariable plane').onChange(function(value) {
    // Show/hide the markers group (separate from tilted plane)
    if (invariablePlaneGroup.userData.markersGroup) {
      invariablePlaneGroup.userData.markersGroup.visible = value;
    }
    // Show/hide all labels when toggling the plane
    // Must set CSS2DObject.visible property (not just div.style.display)
    // because the patched labelRenderer checks obj.visible and overrides display style
    if (invariablePlaneGroup.userData.highLabelObj) {
      invariablePlaneGroup.userData.highLabelObj.visible = value;
    }
    if (invariablePlaneGroup.userData.lowLabelObj) {
      invariablePlaneGroup.userData.lowLabelObj.visible = value;
    }
    if (invariablePlaneGroup.userData.meanLabel1Obj) {
      invariablePlaneGroup.userData.meanLabel1Obj.visible = value;
    }
    if (invariablePlaneGroup.userData.meanLabel2Obj) {
      invariablePlaneGroup.userData.meanLabel2Obj.visible = value;
    }
    // Earth height indicator label (annual crossing)
    if (invariablePlaneGroup.userData.earthHeightLabelObj) {
      invariablePlaneGroup.userData.earthHeightLabelObj.visible = value;
    }
    // Force immediate update of Earth height indicator when becoming visible
    if (value) {
      updateInvariablePlanePosition();
    }
    // Also toggle inclination path visibility
    inclinationPathGroup.visible = value;
    if (value) {
      // Force immediate position update when becoming visible
      _lastInclinationUpdateYear = null; // Reset throttle
      updateInclinationPathMarker();
    } else {
      // Hide label immediately when toggling off
      const labelObject = inclinationPathGroup.userData.labelObject;
      if (labelObject) labelObject.visible = false;
    }
    needsLabelUpdate = true; // Force label renderer to redraw immediately
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // INVARIABLE PLANE POSITIONS PANEL
  // Shows all planets' heights relative to the invariable plane
  // ═══════════════════════════════════════════════════════════════════════════
  const invPlanePositionsFolder = gui.addFolder('Invariable Plane Positions');

  // Helper to add tooltip to dat.GUI controller
  const addTooltip = (controller, text) => {
    if (controller.domElement && controller.domElement.parentElement) {
      controller.domElement.parentElement.title = text;
    }
    return controller;
  };

  // Validation subfolder (Option A vs B comparison) - at top for easy access
  const validationFolder = invPlanePositionsFolder.addFolder('Validate position of Invariable plane (Option A vs B)');
  addTooltip(validationFolder.add(o, 'calculatedPlaneTilt', 0, 10).step(0.0001).name('Calc. Tilt (°)').listen(),
    'Invariable plane tilt from ecliptic, calculated from angular momentum vectors (Option A). Expected: 1.5787° (Souami & Souchay 2012). This is constant - defined by orbital elements.');
  addTooltip(validationFolder.add(o, 'calculatedAscendingNode', 0, 360).step(0.01).name('Calc. Asc.Node (°)').listen(),
    'Ascending node of invariable plane on ecliptic (Option A). Expected: ~107°. This is where the invariable plane crosses the ecliptic going north. Constant value.');
  addTooltip(validationFolder.add(o, 'jupiterAngularMomentumPercent', 0, 100).step(0.01).name('Jupiter L (%)').listen(),
    'Jupiter\'s contribution to total planetary angular momentum. Expected: 58-62%. Jupiter dominates the invariable plane orientation.');
  addTooltip(validationFolder.add(o, 'saturnAngularMomentumPercent', 0, 100).step(0.01).name('Saturn L (%)').listen(),
    'Saturn\'s contribution to total planetary angular momentum. Expected: 23-26%. Second largest contributor after Jupiter.');
  addTooltip(validationFolder.add(o, 'optionABDifference', 0, 10).step(0.0001).name('A vs B Diff (°)').listen(),
    'Difference between Option A (calculated) and Option B (Souami & Souchay data). Should be <0.5° if orbital elements are correct.');

  validationFolder.close(); // Start collapsed

  // Planet heights (read-only displays via .listen())
  // Use step(0.0001) to show 4 decimal places for small AU values
  addTooltip(invPlanePositionsFolder.add(o, 'mercuryHeightAboveInvPlane', -1, 1).step(0.0001).name('Mercury (AU)').listen(),
    'Height above invariable plane in AU. Positive = above, negative = below. Mercury has highest inclination (6.35°), max height ~0.05 AU.');
  addTooltip(invPlanePositionsFolder.add(o, 'venusHeightAboveInvPlane', -1, 1).step(0.0001).name('Venus (AU)').listen(),
    'Height above invariable plane in AU. Venus inclination: 2.15°, max height ~0.02 AU.');
  addTooltip(invPlanePositionsFolder.add(o, 'earthHeightAboveInvPlane', -1, 1).step(0.0001).name('Earth (AU)').listen(),
    'Height above invariable plane in AU. Earth inclination: 1.57°, max height ~0.027 AU. Crosses plane in July (ascending) and January (descending).');
  addTooltip(invPlanePositionsFolder.add(o, 'marsHeightAboveInvPlane', -1, 1).step(0.0001).name('Mars (AU)').listen(),
    'Height above invariable plane in AU. Mars inclination: 1.63°, max height ~0.04 AU.');
  addTooltip(invPlanePositionsFolder.add(o, 'jupiterHeightAboveInvPlane', -1, 1).step(0.0001).name('Jupiter (AU)').listen(),
    'Height above invariable plane in AU. Jupiter has lowest inclination (0.32°) because it dominates the plane. Max height ~0.03 AU.');
  addTooltip(invPlanePositionsFolder.add(o, 'saturnHeightAboveInvPlane', -1, 1).step(0.0001).name('Saturn (AU)').listen(),
    'Height above invariable plane in AU. Saturn inclination: 0.93°, max height ~0.15 AU due to large orbit.');
  addTooltip(invPlanePositionsFolder.add(o, 'uranusHeightAboveInvPlane', -1, 1).step(0.0001).name('Uranus (AU)').listen(),
    'Height above invariable plane in AU. Uranus inclination: 0.99°, max height ~0.34 AU.');
  addTooltip(invPlanePositionsFolder.add(o, 'neptuneHeightAboveInvPlane', -1, 1).step(0.0001).name('Neptune (AU)').listen(),
    'Height above invariable plane in AU. Neptune inclination: 0.74°, max height ~0.39 AU due to large orbit.');

  // Balance indicators
  addTooltip(invPlanePositionsFolder.add(o, 'massWeightedBalance', -1, 1).step(0.000001).name('Mass Balance (AU)').listen(),
    'Mass-weighted average height: Σ(mass × height) / total_mass. Should oscillate around zero over long timescales. Jupiter (71%) and Saturn (21%) dominate.');
  addTooltip(invPlanePositionsFolder.add(o, 'planetsAboveInvPlane').name('Planets Above').listen(),
    'Number of planets currently above the invariable plane (positive height).');
  addTooltip(invPlanePositionsFolder.add(o, 'planetsBelowInvPlane').name('Planets Below').listen(),
    'Number of planets currently below the invariable plane (negative height).');

  // Balance Trend Analysis subfolder
  const trendFolder = invPlanePositionsFolder.addFolder('Balance Trend Analysis');

  // Start/Stop button - changes label based on state
  const trackingButton = { label: 'Start Tracking' };
  const trackingController = trendFolder.add(trackingButton, 'label').name('▶ Start Tracking');
  trackingController.domElement.parentElement.style.cursor = 'pointer';
  trackingController.domElement.querySelector('input').style.display = 'none';
  trackingController.domElement.parentElement.addEventListener('click', () => {
    if (o.balanceTrackingActive) {
      stopBalanceTracking();
      trackingController.name('▶ Start Tracking');
    } else {
      startBalanceTracking();
      trackingController.name('⏹ Stop Tracking');
    }
  });
  trackingController.domElement.parentElement.title = 'Click to start/stop recording balance samples. Run for 165+ years (one Neptune orbit) for meaningful average.';

  // Tracking status display
  addTooltip(trendFolder.add(o, 'balanceTrackingActive').name('Tracking Active').listen(),
    'Whether balance tracking is currently recording samples.');
  addTooltip(trendFolder.add(o, 'balanceTrackingStartYear', -100000, 100000).step(0.1).name('Started (year)').listen(),
    'Simulation year when tracking began.');
  addTooltip(trendFolder.add(o, 'balanceYearsTracked', 0, 1000000).step(0.1).name('Years Tracked').listen(),
    'Duration of tracking in simulated years. Need 165+ years (one Neptune orbit) for meaningful average.');
  addTooltip(trendFolder.add(o, 'balanceSampleCount', 0, 1000000).step(1).name('Sample Count').listen(),
    'Number of yearly samples collected. More samples = more accurate average.');
  addTooltip(trendFolder.add(o, 'balanceCumulativeSum', -1000, 1000).step(0.000001).name('Cumulative Sum').listen(),
    'Running sum of all balance samples. Divide by sample count to get lifetime average.');
  addTooltip(trendFolder.add(o, 'balanceLifetimeAverage', -1, 1).step(0.000001).name('Lifetime Avg (AU)').listen(),
    'KEY METRIC: Should converge to ~0 over 165+ years if invariable plane is correctly positioned. This validates the plane orientation.');
  addTooltip(trendFolder.add(o, 'balanceMinSeen', -1, 1).step(0.000001).name('Min Seen (AU)').listen(),
    'Most negative (below plane) balance observed during tracking. Shows lower bound of oscillation.');
  addTooltip(trendFolder.add(o, 'balanceMaxSeen', -1, 1).step(0.000001).name('Max Seen (AU)').listen(),
    'Most positive (above plane) balance observed during tracking. Shows upper bound of oscillation.');

  // Reset button
  const resetButton = { reset: () => { resetBalanceTracking(); trackingController.name('▶ Start Tracking'); } };
  const resetController = trendFolder.add(resetButton, 'reset').name('↺ Reset Tracking');
  resetController.domElement.parentElement.title = 'Clear all tracking data and start fresh. Use after jumping to a new simulation date.';

  trendFolder.close(); // Start collapsed

  invPlanePositionsFolder.close(); // Start collapsed

  let sFolder = gui.addFolder('Settings')

  // Hierarchy Inspector - first item in Settings
  sFolder.add({ inspect: openHierarchyInspector }, 'inspect').name('Planet Inspector');

  sFolder.add(params, 'sizeBoost', 0, 1, 0.01).name('Planet size  0  = real').onChange(updatePlanetSizes);
  
  /* --- Output file  -------------------------------------------- */
  const testSettings = sFolder.addFolder('Create Object File');

  const modeCtrl   = testSettings.add(o, 'testMode', ['List', 'Range']).name('Mode');
  const listCtrl   = testSettings.add(o, 'testJDsText').name('JD list (CSV)');
  const startCtrl  = testSettings.add(o, 'rangeStart').name('Start JD');
  const endCtrl    = testSettings.add(o, 'rangeEnd').name('End JD');
  const pieceCtrl  = testSettings.add(o, 'rangePieces').name('# points').min(2).step(1);

  //testSettings.add(o, 'runRATestButton').name('Create file (be patient)');
  const runCtrl = testSettings
  .add(o, 'runRATestToggle')
  .name('Create file (be patient)')
  .listen();
  
  runCtrl.onChange(async val => {
  if (!val || o._raTestBusy) return;   // only react on first tick

  o._raTestBusy = true;
  try {
    await runRATest();                // heavy work runs **after** the UI paints
  } finally {
    o.runRATestToggle = false;        // untick when finished
    runCtrl.updateDisplay();
    o._raTestBusy = false;
  }
  });
  
  /* --- show only the relevant rows ------------------------------- */
  function syncVis () {
  const list = o.testMode === 'List';
  toggleCtrl(listCtrl,  list);
  toggleCtrl(startCtrl, !list);
  toggleCtrl(endCtrl,   !list);
  toggleCtrl(pieceCtrl, !list);
  }
  syncVis();
  modeCtrl.onChange(syncVis);
  
  /* --- Solstice file --------------------------------------------------- */
  const solFolder = sFolder.addFolder('Create Solstice File');

  const modeCtrl2  = solFolder.add(o, 'solMode', ['Range', 'List']).name('Mode');
  const yearList   = solFolder.add(o, 'solYearsText').name('Year list (CSV)');
  const startCtrl2 = solFolder.add(o, 'solRangeStart').name('Start year').step(1);
  const endCtrl2   = solFolder.add(o, 'solRangeEnd').name('End year').step(1);

  const runCtrl2 = solFolder
  .add(o, 'runSolToggle')
  .name('Create file (be patient)')
  .listen();

  /* --- show only the relevant rows ------------------------------------ */
  function syncSolVis() {
  const list = o.solMode === 'List';
  toggleCtrl(yearList,  list);      // show list box only in List mode
  toggleCtrl(startCtrl2, !list);    // show range fields only in Range mode
  toggleCtrl(endCtrl2,   !list);
  }
  syncSolVis();
  modeCtrl2.onChange(syncSolVis);

  /* --- run button ------------------------------------------------------ */
  runCtrl2.onChange(async ticked => {
  if (!ticked || o._solBusy) return;   // ignore untick or double-click
  o._solBusy = true;
  try {
    const yrs = buildYearArray();      // builds array from List or Range
    if (!yrs.length) {
      alert('No valid years — check your input.');
      return;
    }
    await runSolsticeExport(yrs);      // heavy work
  } finally {
    o.runSolToggle = false;            // untick when finished
    runCtrl2.updateDisplay();
    o._solBusy = false;
  }
  });

  /* --- Year Analysis Report ------------------------------------------------- */
  const yearAnalysisFolder = sFolder.addFolder('Create Year Analysis Report');

  const modeCtrl3  = yearAnalysisFolder.add(o, 'yearAnalysisMode', ['Range', 'List']).name('Mode');
  const yearList3  = yearAnalysisFolder.add(o, 'yearAnalysisYearsText').name('Year list (CSV)');
  const startCtrl3 = yearAnalysisFolder.add(o, 'yearAnalysisRangeStart').name('Start year').step(1);
  const endCtrl3   = yearAnalysisFolder.add(o, 'yearAnalysisRangeEnd').name('End year').step(1);

  const runCtrl3 = yearAnalysisFolder
    .add(o, 'runYearAnalysisToggle')
    .name('Create file (be patient)')
    .listen();

  /* --- show only the relevant rows ------------------------------------------ */
  function syncYearAnalysisVis() {
    const list = o.yearAnalysisMode === 'List';
    toggleCtrl(yearList3,  list);      // show list box only in List mode
    toggleCtrl(startCtrl3, !list);     // show range fields only in Range mode
    toggleCtrl(endCtrl3,   !list);
  }
  syncYearAnalysisVis();
  modeCtrl3.onChange(syncYearAnalysisVis);

  /* --- run button ----------------------------------------------------------- */
  runCtrl3.onChange(async ticked => {
    if (!ticked || o._yearAnalysisBusy) return;   // ignore untick or double-click
    o._yearAnalysisBusy = true;
    try {
      const yrs = buildYearAnalysisArray();       // builds array from List or Range
      if (!yrs.length) {
        alert('No valid years — check your input.');
        return;
      }
      await runYearAnalysisExport(yrs);           // heavy work
    } finally {
      o.runYearAnalysisToggle = false;            // untick when finished
      runCtrl3.updateDisplay();
      o._yearAnalysisBusy = false;
    }
  });

  /* --- Console Tests (F12) ------------------------------------------------- */
  const calibFolder = sFolder.addFolder('Console Tests (F12)');

  // Configuration
  calibFolder.add(o, 'calibrationYearStart').name('Start year').step(1);
  calibFolder.add(o, 'calibrationYearEnd').name('End year').step(1);

  // Year Length Analysis
  const calibTropicalCtrl = calibFolder
    .add(o, 'runTropicalYearAnalysis')
    .name('Analyze Year at June Solstice')
    .listen();

  const calibDecemberSolsticeCtrl = calibFolder
    .add(o, 'runDecemberSolsticeAnalysis')
    .name('Analyze Year at December Solstice')
    .listen();

  const calibEquinoxCtrl = calibFolder
    .add(o, 'runEquinoxAnalysis')
    .name('Analyze Year Length by Cardinal')
    .listen();

  const calibAnoministicCtrl = calibFolder
    .add(o, 'runAnoministicAnalysis')
    .name('Analyze Anomalistic Year')
    .listen();

  const calibSiderealYearCtrl = calibFolder
    .add(o, 'runSiderealYearAnalysis')
    .name('Analyze Sidereal Year')
    .listen();

  const calibAllAlignmentsCtrl = calibFolder
    .add(o, 'runAllAlignments')
    .name('Analyze All Alignments')
    .listen();

  // Day Length Analysis
  const calibSiderealDayCtrl = calibFolder
    .add(o, 'runSiderealDayAnalysis')
    .name('Analyze Sidereal Day')
    .listen();

  const calibSolarDayCtrl = calibFolder
    .add(o, 'runSolarDayAnalysis')
    .name('Analyze Solar Day')
    .listen();

  const calibStellarDayCtrl = calibFolder
    .add(o, 'runStellarDayAnalysis')
    .name('Analyze Stellar Day')
    .listen();

  // Day Rotation Diagnostics - hidden, call diagnoseDayRotation() from console if needed
  // const calibDayDiagnosticsCtrl = calibFolder
  //   .add(o, 'runDayDiagnostics')
  //   .name('Day Rotation Diagnostics')
  //   .listen();

  // RA Rate Diagnostics - hidden, call diagnoseRARate() from console if needed
  // const calibRADiagnosticsCtrl = calibFolder
  //   .add(o, 'runRADiagnostics')
  //   .name('RA Rate Diagnostics')
  //   .listen();

  // Parameter Verification
  const calibTestCtrl = calibFolder
    .add(o, 'runCalibrationTest')
    .name('Verify Obliquity Calibration')
    .listen();

  const calibVerifyPerihelionCtrl = calibFolder
    .add(o, 'runVerifyPerihelionRate')
    .name('Verify Perihelion Rate')
    .listen();

  const calibInvestigateCtrl = calibFolder
    .add(o, 'runInvestigateParams')
    .name('Investigate Parameters')
    .listen();

  // Optimization
  const calibOptimalCtrl = calibFolder
    .add(o, 'runFindOptimalRA')
    .name('Find Optimal earthRAAngle')
    .listen();

  /* --- Tropical Year Analysis (June Solstice) ----------------------------- */
  calibTropicalCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeTropicalYearLength();
    } finally {
      o.runTropicalYearAnalysis = false;
      calibTropicalCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- December Solstice Year Analysis ------------------------------------ */
  calibDecemberSolsticeCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeDecemberSolsticeYearLength();
    } finally {
      o.runDecemberSolsticeAnalysis = false;
      calibDecemberSolsticeCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Verify Obliquity Calibration ---------------------------------------- */
  calibTestCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await runObliquityCalibrationTest();
    } finally {
      o.runCalibrationTest = false;
      calibTestCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Investigate Parameter Effects -------------------------------------- */
  calibInvestigateCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await investigateParameterEffects();
    } finally {
      o.runInvestigateParams = false;
      calibInvestigateCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Find Optimal earthRAAngle ------------------------------------------ */
  calibOptimalCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await findOptimalEarthRAAngle();
    } finally {
      o.runFindOptimalRA = false;
      calibOptimalCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Verify Perihelion Rate --------------------------------------------- */
  calibVerifyPerihelionCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await verifyPerihelionRate();
    } finally {
      o.runVerifyPerihelionRate = false;
      calibVerifyPerihelionCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Equinox Intervals Analysis ----------------------------------------- */
  calibEquinoxCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeEquinoxIntervals();
    } finally {
      o.runEquinoxAnalysis = false;
      calibEquinoxCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Anomalistic Year Analysis ------------------------------------------ */
  calibAnoministicCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeAnoministicYear();
    } finally {
      o.runAnoministicAnalysis = false;
      calibAnoministicCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Sidereal Year Analysis --------------------------------------------- */
  calibSiderealYearCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeSiderealYear();
    } finally {
      o.runSiderealYearAnalysis = false;
      calibSiderealYearCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- All Alignments Analysis -------------------------------------------- */
  calibAllAlignmentsCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeAllAlignments();
    } finally {
      o.runAllAlignments = false;
      calibAllAlignmentsCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Analyze Sidereal Day ------------------------------------------------ */
  calibSiderealDayCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeSiderealDay();
    } finally {
      o.runSiderealDayAnalysis = false;
      calibSiderealDayCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Analyze Solar Day --------------------------------------------------- */
  calibSolarDayCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeSolarDay();
    } finally {
      o.runSolarDayAnalysis = false;
      calibSolarDayCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  /* --- Analyze Stellar Day ------------------------------------------------- */
  calibStellarDayCtrl.onChange(async ticked => {
    if (!ticked || o._calibrationBusy) return;
    o._calibrationBusy = true;
    try {
      console.clear();
      await analyzeStellarDay();
    } finally {
      o.runStellarDayAnalysis = false;
      calibStellarDayCtrl.updateDisplay();
      o._calibrationBusy = false;
    }
  });

  // /* --- Day Rotation Diagnostics -------------------------------------------- */
  // calibDayDiagnosticsCtrl.onChange(async ticked => {
  //   if (!ticked || o._calibrationBusy) return;
  //   o._calibrationBusy = true;
  //   try {
  //     console.clear();
  //     // Use the June solstice of calibration start year as starting point
  //     const startSolstice = solsticeForYear(o.calibrationYearStart);
  //     if (startSolstice) {
  //       diagnoseDayRotation(startSolstice.jd, 25);
  //     } else {
  //       console.error('Could not find solstice for diagnostic');
  //     }
  //   } finally {
  //     o.runDayDiagnostics = false;
  //     calibDayDiagnosticsCtrl.updateDisplay();
  //     o._calibrationBusy = false;
  //   }
  // });

  // /* --- RA Rate Diagnostics ------------------------------------------------- */
  // calibRADiagnosticsCtrl.onChange(async ticked => {
  //   if (!ticked || o._calibrationBusy) return;
  //   o._calibrationBusy = true;
  //   try {
  //     console.clear();
  //     diagnoseRARate();
  //   } finally {
  //     o.runRADiagnostics = false;
  //     calibRADiagnosticsCtrl.updateDisplay();
  //     o._calibrationBusy = false;
  //   }
  // });

  let folderPlanets = sFolder.addFolder('Planets show/hide');
  folderPlanets.add(o, 'Orbits' ).onFinishChange(()=>{
    showHideOrbits();
  });

  folderPlanets.add(o, 'Size', 0.4, 1.4).onChange(()=>{changePlanetScale()})
  planetObjects.forEach(obj => {
    if (!obj.isNotPhysicalObject) {
      folderPlanets.add(obj, 'visible').name(obj.name).onFinishChange(()=>{
        showHideObject(obj);
      });
    }
  })
 
  let folderDef = sFolder.addFolder('Objects show/hide');
  planetObjects.forEach(obj => {
    if (obj.isNotPhysicalObject) {
      folderDef.add(obj, 'visible').name(obj.name).onFinishChange(()=>{
        showHideObject(obj);
      });
    }
  })
  
  let folderElongations=sFolder.addFolder("Elongations show/hide");
  folderElongations.add(o,"moonElongation").min(0.0).max(180.0).listen().name("Moon")
  folderElongations.add(o,"mercuryElongation").min(0.0).max(180.0).listen().name("Mercury")
  folderElongations.add(o,"venusElongation").min(0.0).max(180.0).listen().name("Venus")
  folderElongations.add(o,"marsElongation").min(0.0).max(180.0).listen().name("Mars")
  folderElongations.add(o,"jupiterElongation").min(0.0).max(180.0).listen().name("Jupiter")
  folderElongations.add(o,"saturnElongation").min(0.0).max(180.0).listen().name("Saturn")  
  folderElongations.add(o,"uranusElongation").min(0.0).max(180.0).listen().name("Uranus") 
  folderElongations.add(o,"neptuneElongation").min(0.0).max(180.0).listen().name("Neptune") 
  folderElongations.add(o,"plutoElongation").min(0.0).max(180.0).listen().name("Pluto") 
  folderElongations.add(o,"halleysElongation").min(0.0).max(180.0).listen().name("Halleys") 
  folderElongations.add(o,"erosElongation").min(0.0).max(180.0).listen().name("Eros") 
  
  let folderCamera = sFolder.addFolder('Camera show/hide')

  folderCamera.add(o, 'worldCamRa').name('RA').listen()
  folderCamera.add(o, 'worldCamDec').name('Dec').listen()
  folderCamera.add(o, 'worldCamDist').name('AU distance').listen()

  // Debug folder for ascending node debugging (only shown when debugOn flag is true)
  if (debugOn) {
    let debugFolder = sFolder.addFolder('Debug');
    debugFolder.add(o, 'debugAscendingNode').name('Log Ascending Nodes').onChange((val) => {
      _debugAscendingNodeLogEnabled = val;
      if (val) {
        console.log('🔍 Ascending Node debugging ENABLED - check console for logs every second');
        console.log('   Go to a date like 12000-07-16 to see drift behavior');
      } else {
        console.log('🔍 Ascending Node debugging DISABLED');
      }
    });
  }

  /* ---------------------------------------------------------
  * width-toggle badge (does NOT consume a controller slot)
  * --------------------------------------------------------- */
  addWidthToggle(gui);
}  

//*************************************************************
// USE STATISTICS (WHEN NEEDED)
//*************************************************************
const stats = new Stats()
//stats.showPanel(2); // 0: fps, 1: ms, 2: MB
document.body.appendChild( stats.dom )
if (!o.Performance) stats.dom.style.display = 'none';
//if (!o.Performance) stats.dom.style.display = 'visible';
//stats.dom.style.display = 'none';    // completely removes it from layout
// OR
//stats.dom.style.visibility = 'hidden'; // hides but still takes up space
//stats.dom.style.display = 'block';   // or '' if you want default style
// OR
//stats.dom.style.visibility = 'visible';

//*************************************************************
// THE ANIMATE/RENDER LOOP (BE CAREFUL WITH ADDING/ CHANGING)
//*************************************************************
function render(now) {
  requestAnimationFrame(render);
  //stats.begin();
  //stats.update();

  // 1) Delta and FPS throttle
  const deltaMs = now - lastFrameTime;
  lastFrameTime = now;
  const delta   = deltaMs * 0.001;    // seconds/frame
  const fps     = 1000 / deltaMs;
  smoothedFps   = smoothedFps * 0.9 + fps * 0.1;

  if (smoothedFps < 30 && !lowPerformanceMode) {
    renderer.setPixelRatio(1);
    lowPerformanceMode = true;
  } else if (smoothedFps > 40 && lowPerformanceMode) {
    renderer.setPixelRatio(window.devicePixelRatio);
    lowPerformanceMode = false;
  }

  // 2) Did the camera move?
  const { x, y, z } = camera.position;
  cameraMoved = (x !== lastCameraX || y !== lastCameraY || z !== lastCameraZ);
  lastCameraX = x; lastCameraY = y; lastCameraZ = z;

  // 3) OrbitControls: point at your selected pivot
  // If hierarchy inspector is controlling camera, use its target instead
  if (hierarchyInspector._cameraControlActive && hierarchyInspector._cameraTarget?.pivotObj) {
    controls.target.copy(
      hierarchyInspector._cameraTarget.pivotObj.getWorldPosition(tmpVec)
    );
  } else if (o.lookAtObj && o.lookAtObj.pivotObj) {
    controls.target.copy(
      o.lookAtObj.pivotObj.getWorldPosition(tmpVec)
    );
  }
  controls.update();

  // Enforce minimum distance after damping (prevents drifting into planet)
  // Skip when hierarchy inspector is controlling camera (it has its own targets)
  if (!hierarchyInspector._cameraControlActive && o.lookAtObj?.planetObj && o.lookAtObj.size) {
    // Use rotationAxis scale (where blow-up slider applies) not planetObj scale
    const scale = o.lookAtObj.rotationAxis?.scale?.x ?? 1;
    const visualRadius = o.lookAtObj.size * scale;
    const multiplier = getCameraMinDistMultiplier(o.lookAtObj.name);
    const minDist = visualRadius * multiplier;
    const dist = camera.position.distanceTo(controls.target);
    if (dist < minDist) {
      // Push camera back to minimum distance
      _camDir.copy(camera.position).sub(controls.target).normalize();
      camera.position.copy(controls.target).add(_camDir.multiplyScalar(minDist));
    }
  }

  // 4) Throttle the human-readable GUI (20 Hz)
  //    Also force update when positionChanged (position jumped externally)
  let uiUpdateThisFrame = false;
  uiElapsed += delta;
  if (uiElapsed >= 0.05 || positionChanged) {
    if (uiElapsed >= 0.05) uiElapsed = 0;
    uiUpdateThisFrame = true;
    o.Day           = posToDays(o.pos);
    o.Date          = daysToDate(o.Day);
    o.Time          = posToTime(o.pos);
    o.julianDay     = dateTimeToJulianDay(o.Date, o.Time);
    const p         = dayToDateNew(o.julianDay,'julianday','perihelion-calendar');
    o.perihelionDate = `${p.date} ${p.time}`;
    o.currentYear = julianDateToDecimalYear(o.julianDay)
    o.perihelionprecessioncycleYear = yearInCycle(o.currentYear, balancedYear, holisticyearLength);

    o.juliandaysbalancedJD = o.julianDay - balancedJD;
    //console.log(o.perihelionprecessioncycleYear)
    // Easter egg/ Can be added later
    //     if (isPerihelionCycle(o.periheliondate, 'perihelionday', ) && !eggTriggered) {
    //       eggTriggered = true;
    //       triggerPerihelionEasterEgg();
    //     }

    o.worldCamX = Math.round(x);
    o.worldCamY = Math.round(y);
    o.worldCamZ = Math.round(z);
  }

  // 5) Advance the simulation time (once per frame)
  if (o.Run) {
    o.pos += Number(o.speedFact) * o.speed * delta;
  }

  // 6) Skip heavy updates when idle (not running and camera not moving)
  const needsUpdate = o.Run || cameraMoved || positionChanged;
  const forceAllUpdates = positionChanged; // When position jumps, force all throttled updates immediately

  if (needsUpdate) {
    positionChanged = false; // Reset flag after handling
    // 6a) Must-run-every-frame: updates your models
    trace(o.pos);
    moveModel(o.pos);
    //detectAndUpdateDeltaT(); // can calculate Delta T but is quite heavy. If you switch it on, also switch on the menu-items/ info-box-itms.
    updatePositions();
    // Throttle display string updates (20 Hz) - must be after updatePositions() sets numeric values
    if (uiUpdateThisFrame || forceAllUpdates) {
      updatePositionDisplayStrings();
    }
    // 6b) Throttle heavy astronomical calculations (10 Hz)
    astroCalcElapsed += delta;
    if (astroCalcElapsed >= 0.1 || forceAllUpdates) {
      astroCalcElapsed = 0;
      updatePredictions(); // Heavy - 50+ computations, values change slowly
      updateAscendingNodes(); // Must be before updateHierarchyLiveData() so dynamic values are current
      updatePlanetAnomalies(); // Must be after updateAscendingNodes(), calculates Mean/True Anomaly for all planets
      updatePlanetInvariablePlaneHeights(); // Must be after updatePlanetAnomalies(), calculates height above invariable plane
      updateDynamicInclinations(); // Must be after updatePlanetInvariablePlaneHeights(), calculates ecliptic inclination to ecliptic
      updateInvariablePlaneBalance(); // Must be after updatePlanetInvariablePlaneHeights(), calculates mass-weighted balance
      updateBalanceTrendAnalysis(); // Must be after updateInvariablePlaneBalance(), records samples when tracking active
      updateBalanceMinMax(); // Must be after updateInvariablePlaneBalance(), tracks min/max every frame
      calculateInvariablePlaneFromAngularMomentum(); // Validation: Option A calculation (fixed J2000 elements)
      updateHierarchyLiveData(); // Must be after updatePositions() which sets raDisplay/decDisplay
      updateInclinationPathMarker();
      updateInvariablePlanePosition();
      updateSunCenteredInvPlane(); // Sun-centered invariable plane for all planets
    }
    // 6c) Throttle visual effects (30 Hz) - smooth enough for eye, saves CPU
    visualElapsed += delta;
    if (visualElapsed >= 0.033 || forceAllUpdates) {
      visualElapsed = 0;
      updateLightingForFocus();
      updateFlares();
    }
    if (earth._updateSunDirFunc) earth._updateSunDirFunc(sun.planetObj);
    if (earth._updateEraFunc)    earth._updateEraFunc(o.julianDay);
    updateSunGlow();

    // 7) Throttle astro-heavy updates (10 Hz)
    posElapsed += delta;
    if (posElapsed >= 0.1 || forceAllUpdates) {
      posElapsed = 0;
      updateElongations();
      updatePerihelion();
      // updateAscendingNodes() is now called every frame before updateHierarchyLiveData()
      updateOrbitOrientations();
      golden.update();
    }

    // 7b) Throttle DOM label updates (5 Hz) - separated from astro updates for performance
    domElapsed += delta;
    if (domElapsed >= 0.2 || forceAllUpdates) {
      domElapsed = 0;
      updateDomLabel();
    }

    // 8) Throttle lighting/glow (10 Hz)
    lightElapsed += delta;
    if (lightElapsed >= 0.1 || forceAllUpdates) {
      lightElapsed = 0;
      updateFocusRing();
      animateGlow(); // zodiac animation
    }
  }

  // Always run cloud animation (even when idle)
  if (earth._updateCloudsFunc) earth._updateCloudsFunc(delta);

  // 9) Camera-move-dependent fades & flares
  if (cameraMoved) {
    // star‐tag fades
  }

  // 10) Last thing: draw
  renderer.render(scene, camera);
  if (needsLabelUpdate) {
    // 3a) sync the CSS2D internal size
    labelRenderer.setSize(window.innerWidth, window.innerHeight);

    // 3b) call your patched render (it will clear & re-append all labels)
    labelRenderer.render(scene, camera);

    needsLabelUpdate = false;
  }
  //stats.end();
}
requestAnimationFrame(render);

//*************************************************************
// FUNCTIONS
//*************************************************************
function solsticeForYear(year, prevSolsticeJD = null) {
  let approxJD;
  let searchRange;

  if (prevSolsticeJD !== null) {
    // Chain from previous solstice - tropical year is ~365.24 days
    approxJD = prevSolsticeJD + 365.24;
    searchRange = 288;  // ±6 days is enough when chained
  } else {
    // First search: estimate from year + 0.5 (June solstice is mid-year)
    approxJD = startmodelJD +
          ((year + 0.5) - startmodelYear) * meansolaryearlengthinDays;
    searchRange = 480;  // ±10 days for first search
  }

  const step    = 0.5 / 24;         // 0.5 h in days
  let bestK     = 0;
  let bestObliq = -Infinity;

  /* Phase 1: Coarse search with 30-minute samples */
  const samples = [];                             // store all samples for interpolation
  for (let k = -searchRange; k <= searchRange; ++k) {             // samples of 30 minutes interval around the approxJD.
    const jd   = approxJD + k * step;

    // Jump to JD and let forceSceneUpdate derive o.Time from o.pos
    // (Fixed: removed manual o.Time setting which used wrong epoch)
    jumpToJulianDay(jd);
    forceSceneUpdate();

    if (!Number.isFinite(sun?.dec)) continue;

    const obDeg = 90 - sun.dec * 180 / Math.PI;
    samples[k + searchRange] = { k, jd, obDeg };
    if (obDeg > bestObliq) { bestObliq = obDeg; bestK = k; }
  }

  const bestIdx = bestK + searchRange;
  if (!samples[bestIdx]) return null;

  /* Phase 2: Parabolic interpolation for sub-sample precision
   * Given 3 points around maximum: (t₋₁, y₋₁), (t₀, y₀), (t₊₁, y₊₁)
   * The vertex of the fitted parabola is at:
   *   t_max = t₀ + (step/2) × (y₋₁ - y₊₁) / (y₋₁ - 2y₀ + y₊₁)
   */
  let refinedJD = samples[bestIdx].jd;
  let refinedObliq = bestObliq;

  if (samples[bestIdx - 1] && samples[bestIdx + 1]) {
    const y_m1 = samples[bestIdx - 1].obDeg;      // y at t-1
    const y_0  = samples[bestIdx].obDeg;          // y at t0 (best)
    const y_p1 = samples[bestIdx + 1].obDeg;      // y at t+1

    const denom = y_m1 - 2 * y_0 + y_p1;
    if (Math.abs(denom) > 1e-12) {                // avoid division by zero
      const offset = (step / 2) * (y_m1 - y_p1) / denom;
      refinedJD = samples[bestIdx].jd + offset;

      // Also interpolate the obliquity value at the refined time
      // Using parabola: y = a*t² + b*t + c, evaluated at t = offset/step
      const t = offset / step;                    // normalized offset (-0.5 to 0.5)
      refinedObliq = y_0 + 0.5 * t * (y_p1 - y_m1) + 0.5 * t * t * (y_p1 - 2 * y_0 + y_m1);
    }
  }

  /* Final scene state at refined time */
  // Jump to refined JD and let forceSceneUpdate derive o.Date/o.Time from o.pos
  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  return {
    jd      : refinedJD,  // Use refinedJD directly for precision
    raDeg   : (sun.ra * 180 / Math.PI + 360) % 360,
    obliqDeg: refinedObliq
  };
}

/**
 * Detect when sun.ra crosses a target angle (cardinal point detection)
 * @param {number} year - The year to find the crossing for
 * @param {number} targetRA - Target RA in degrees (0, 90, 180, 270)
 * @param {number} prevJD - Previous crossing JD for chaining (optional)
 * @param {boolean} debug - Enable debug output
 * @returns {object} - { jd, raDeg, decDeg }
 *
 * Cardinal points:
 *   0° = Vernal Equinox (March)
 *  90° = Summer Solstice (June)
 * 180° = Autumnal Equinox (September)
 * 270° = Winter Solstice (December)
 */
function sunRACrossingForYear(year, targetRA, prevJD = null, debug = false) {
  let approxJD;
  let searchRange;

  if (prevJD !== null) {
    // Chain from previous - tropical year is ~365.24 days
    approxJD = prevJD + 365.24;
    searchRange = 288;  // ±6 days is enough when chained
  } else {
    // First search: estimate from target RA
    // Model starts at June solstice (RA=90°), year 2000.5
    // yearFraction maps RA to approximate calendar position:
    //   RA=0° → ~0.21 (March), RA=90° → ~0.47 (June)
    //   RA=180° → ~0.73 (Sept), RA=270° → ~0.97 (Dec)
    const yearFraction = 0.21 + (targetRA / 360);  // Approximate
    approxJD = startmodelJD +
          ((year + yearFraction) - startmodelYear) * meansolaryearlengthinDays;
    searchRange = 960;  // ±20 days for first search
  }

  if (debug) {
    console.log(`sunRACrossingForYear(${year}, targetRA=${targetRA}°): approxJD=${approxJD.toFixed(2)}, searchRange=±${searchRange}`);
  }

  const step = 0.5 / 24;  // 0.5 h in days

  /* Phase 1: Coarse search - sample sun.ra values */
  const samples = [];
  for (let k = -searchRange; k <= searchRange; ++k) {
    const jd = approxJD + k * step;

    jumpToJulianDay(jd);
    forceSceneUpdate();

    if (!Number.isFinite(sun?.ra)) continue;

    const raDeg = (sun.ra * 180 / Math.PI + 360) % 360;
    samples[k + searchRange] = { k, jd, raDeg };
  }

  /* Phase 2: Find the crossing of targetRA */
  let refinedJD = null;

  for (let i = 1; i < samples.length; i++) {
    if (!samples[i] || !samples[i-1]) continue;

    let ra1 = samples[i-1].raDeg;
    let ra2 = samples[i].raDeg;

    // Handle wraparound at 0°/360°
    if (targetRA === 0) {
      // Looking for RA crossing 0° (wraparound from ~359° to ~1°)
      if (ra1 > 300 && ra2 < 60) {
        ra2 += 360;
        const t = (360 - ra1) / (ra2 - ra1);
        refinedJD = samples[i-1].jd + t * step;
        if (debug) {
          console.log(`  Found 0° crossing at i=${i}: ra1=${samples[i-1].raDeg.toFixed(4)}°, ra2=${samples[i].raDeg.toFixed(4)}°, t=${t.toFixed(4)}`);
        }
        break;
      }
    } else {
      // Looking for RA crossing targetRA (90°, 180°, or 270°)
      if (ra1 < targetRA && ra2 >= targetRA) {
        const t = (targetRA - ra1) / (ra2 - ra1);
        refinedJD = samples[i-1].jd + t * step;
        if (debug) {
          console.log(`  Found ${targetRA}° crossing at i=${i}: ra1=${ra1.toFixed(4)}°, ra2=${ra2.toFixed(4)}°, t=${t.toFixed(4)}`);
        }
        break;
      }
    }
  }

  if (refinedJD === null) {
    if (debug) {
      const validSamples = samples.filter(s => s);
      if (validSamples.length > 0) {
        const minRA = Math.min(...validSamples.map(s => s.raDeg));
        const maxRA = Math.max(...validSamples.map(s => s.raDeg));
        console.log(`  WARNING: No ${targetRA}° crossing found! RA range: ${minRA.toFixed(2)}° to ${maxRA.toFixed(2)}°`);
      }
    }
    return null;
  }

  /* Final scene state at refined time */
  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  return {
    jd: refinedJD,
    raDeg: (sun.ra * 180 / Math.PI + 360) % 360,
    decDeg: 90 - sun.dec * 180 / Math.PI
  };
}

/**
 * Detect when sun RA (from wobble center) crosses a target angle - Method B
 * Uses calculateRAFromWobbleCenter() to eliminate the ~26s wobble parallax artifact.
 * This gives the "true" tropical year as measured from a stable reference point.
 *
 * @param {number} year - The year to search in
 * @param {number} targetRA - Target RA in degrees (0, 90, 180, or 270)
 * @param {number|null} prevJD - Previous crossing JD for chaining (improves accuracy)
 * @param {boolean} debug - Enable debug output
 * @returns {object|null} - { jd, raDeg, decDeg } or null if not found
 */
function sunRACrossingForYearMethodB(year, targetRA, prevJD = null, debug = false) {
  let approxJD;
  let searchRange;

  if (prevJD !== null) {
    // Chain from previous - tropical year is ~365.24 days
    approxJD = prevJD + 365.24;
    searchRange = 288;  // ±6 days is enough when chained
  } else {
    // First search: estimate from target RA
    const yearFraction = 0.21 + (targetRA / 360);  // Approximate
    approxJD = startmodelJD +
          ((year + yearFraction) - startmodelYear) * meansolaryearlengthinDays;
    searchRange = 960;  // ±20 days for first search
  }

  if (debug) {
    console.log(`sunRACrossingForYearMethodB(${year}, targetRA=${targetRA}°): approxJD=${approxJD.toFixed(2)}, searchRange=±${searchRange}`);
  }

  const step = 0.5 / 24;  // 0.5 h in days

  /* Phase 1: Coarse search - sample sun RA from wobble center */
  const samples = [];
  for (let k = -searchRange; k <= searchRange; ++k) {
    const jd = approxJD + k * step;

    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Use wobble-center RA instead of Earth-based RA
    const sunRAFromWobble = calculateRAFromWobbleCenter(sun);
    if (!Number.isFinite(sunRAFromWobble)) continue;

    const raDeg = (sunRAFromWobble * 180 / Math.PI + 360) % 360;
    samples[k + searchRange] = { k, jd, raDeg };
  }

  /* Phase 2: Find the crossing of targetRA */
  let refinedJD = null;

  for (let i = 1; i < samples.length; i++) {
    if (!samples[i] || !samples[i-1]) continue;

    let ra1 = samples[i-1].raDeg;
    let ra2 = samples[i].raDeg;

    // Handle wraparound at 0°/360°
    if (targetRA === 0) {
      // Looking for RA crossing 0° (wraparound from ~359° to ~1°)
      if (ra1 > 300 && ra2 < 60) {
        ra2 += 360;
        const t = (360 - ra1) / (ra2 - ra1);
        refinedJD = samples[i-1].jd + t * step;
        if (debug) {
          console.log(`  Found 0° crossing at i=${i}: ra1=${samples[i-1].raDeg.toFixed(4)}°, ra2=${samples[i].raDeg.toFixed(4)}°, t=${t.toFixed(4)}`);
        }
        break;
      }
    } else {
      // Looking for RA crossing targetRA (90°, 180°, or 270°)
      if (ra1 < targetRA && ra2 >= targetRA) {
        const t = (targetRA - ra1) / (ra2 - ra1);
        refinedJD = samples[i-1].jd + t * step;
        if (debug) {
          console.log(`  Found ${targetRA}° crossing at i=${i}: ra1=${ra1.toFixed(4)}°, ra2=${ra2.toFixed(4)}°, t=${t.toFixed(4)}`);
        }
        break;
      }
    }
  }

  if (refinedJD === null) {
    if (debug) {
      const validSamples = samples.filter(s => s);
      if (validSamples.length > 0) {
        const minRA = Math.min(...validSamples.map(s => s.raDeg));
        const maxRA = Math.max(...validSamples.map(s => s.raDeg));
        console.log(`  WARNING: No ${targetRA}° crossing found! RA range: ${minRA.toFixed(2)}° to ${maxRA.toFixed(2)}°`);
      }
    }
    return null;
  }

  /* Final scene state at refined time */
  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  const finalRA = calculateRAFromWobbleCenter(sun);
  return {
    jd: refinedJD,
    raDeg: (finalRA * 180 / Math.PI + 360) % 360,
    decDeg: 90 - sun.dec * 180 / Math.PI
  };
}

/**
 * Detect when sun RA (from earthPerihelionFromEarth) crosses a target angle - Method C
 * Uses calculateRAFromEarthPerihelion() to measure RA from the perihelion point.
 * This is for comparison with Method A (Earth-based) and Method B (wobble-center).
 *
 * @param {number} year - The year to search in
 * @param {number} targetRA - Target RA in degrees (0, 90, 180, or 270)
 * @param {number|null} prevJD - Previous crossing JD for chaining (improves accuracy)
 * @param {boolean} debug - Enable debug output
 * @returns {object|null} - { jd, raDeg, decDeg } or null if not found
 */
function sunRACrossingForYearMethodC(year, targetRA, prevJD = null, debug = false) {
  let approxJD;
  let searchRange;

  if (prevJD !== null) {
    // Chain from previous - tropical year is ~365.24 days
    approxJD = prevJD + 365.24;
    searchRange = 288;  // ±6 days is enough when chained
  } else {
    // First search: estimate from target RA
    const yearFraction = 0.21 + (targetRA / 360);  // Approximate
    approxJD = startmodelJD +
          ((year + yearFraction) - startmodelYear) * meansolaryearlengthinDays;
    searchRange = 960;  // ±20 days for first search
  }

  if (debug) {
    console.log(`sunRACrossingForYearMethodC(${year}, targetRA=${targetRA}°): approxJD=${approxJD.toFixed(2)}, searchRange=±${searchRange}`);
  }

  const step = 0.5 / 24;  // 0.5 h in days

  /* Phase 1: Coarse search - sample sun RA from perihelion point */
  const samples = [];
  for (let k = -searchRange; k <= searchRange; ++k) {
    const jd = approxJD + k * step;

    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Use perihelion-point RA instead of Earth-based RA
    const sunRAFromPeri = calculateRAFromEarthPerihelion(sun);
    if (!Number.isFinite(sunRAFromPeri)) continue;

    const raDeg = (sunRAFromPeri * 180 / Math.PI + 360) % 360;
    samples[k + searchRange] = { k, jd, raDeg };
  }

  /* Phase 2: Find the crossing of targetRA */
  let refinedJD = null;

  for (let i = 1; i < samples.length; i++) {
    if (!samples[i] || !samples[i-1]) continue;

    let ra1 = samples[i-1].raDeg;
    let ra2 = samples[i].raDeg;

    // Handle wraparound at 0°/360°
    if (targetRA === 0) {
      // Looking for RA crossing 0° (wraparound from ~359° to ~1°)
      if (ra1 > 300 && ra2 < 60) {
        ra2 += 360;
        const t = (360 - ra1) / (ra2 - ra1);
        refinedJD = samples[i-1].jd + t * step;
        if (debug) {
          console.log(`  Found 0° crossing at i=${i}: ra1=${samples[i-1].raDeg.toFixed(4)}°, ra2=${samples[i].raDeg.toFixed(4)}°, t=${t.toFixed(4)}`);
        }
        break;
      }
    } else {
      // Looking for RA crossing targetRA (90°, 180°, or 270°)
      if (ra1 < targetRA && ra2 >= targetRA) {
        const t = (targetRA - ra1) / (ra2 - ra1);
        refinedJD = samples[i-1].jd + t * step;
        if (debug) {
          console.log(`  Found ${targetRA}° crossing at i=${i}: ra1=${ra1.toFixed(4)}°, ra2=${ra2.toFixed(4)}°, t=${t.toFixed(4)}`);
        }
        break;
      }
    }
  }

  if (refinedJD === null) {
    if (debug) {
      const validSamples = samples.filter(s => s);
      if (validSamples.length > 0) {
        const minRA = Math.min(...validSamples.map(s => s.raDeg));
        const maxRA = Math.max(...validSamples.map(s => s.raDeg));
        console.log(`  WARNING: No ${targetRA}° crossing found! RA range: ${minRA.toFixed(2)}° to ${maxRA.toFixed(2)}°`);
      }
    }
    return null;
  }

  /* Final scene state at refined time */
  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  const finalRA = calculateRAFromEarthPerihelion(sun);
  return {
    jd: refinedJD,
    raDeg: (finalRA * 180 / Math.PI + 360) % 360,
    decDeg: 90 - sun.dec * 180 / Math.PI
  };
}

/**
 * Legacy wrapper for equinoxForYear - calls sunRACrossingForYear
 */
function equinoxForYear(year, which = 0, prevEquinoxJD = null, debug = false) {
  const targetRA = which === 0 ? 0 : 180;
  return sunRACrossingForYear(year, targetRA, prevEquinoxJD, debug);
}

/**
 * Detect perihelion passage for a given year
 * @param {number} year - The year to find perihelion for
 * @returns {object} - { jd, distance, raDeg }
 */
function perihelionForYear(year, debug = false, prevPerihelionJD = null) {
  // If we have a previous perihelion, search ~1 anomalistic year after it
  // Otherwise, estimate from start date (less accurate over long spans)
  let approxJD;
  let searchRange;  // Half-width of search in samples

  if (prevPerihelionJD !== null) {
    // Anomalistic year is ~365.26 days - search around that offset from previous
    approxJD = prevPerihelionJD + 365.26;
    searchRange = 288;  // ±6 days is enough when we have a good prior
  } else {
    // First search: estimate perihelion position accounting for precession
    // At perihelionalignmentYear (1246), perihelion is in early January (~0.03 into year)
    // Perihelion precesses through the year over HY/16 = 20,868 years
    const perihelionCycle = holisticyearLength / 16;  // 20,868 years
    const perihelionAtReference = 0.03;  // Fraction of year (early January at 1246)

    // Calculate how much perihelion has shifted from reference year
    const yearsSinceReference = year - perihelionalignmentYear;
    const perihelionShift = (yearsSinceReference / perihelionCycle) % 1;  // Fraction of year shift

    // New perihelion position in year (0 = Jan 1, 0.5 = July 1)
    let perihelionFraction = (perihelionAtReference + perihelionShift) % 1;
    if (perihelionFraction < 0) perihelionFraction += 1;

    approxJD = startmodelJD +
          ((year + perihelionFraction) - startmodelYear) * meansolaryearlengthinDays;
    searchRange = 960;  // ±20 days for first search (no prior)

  }

  const step = 0.5 / 24;  // 0.5 h in days
  let bestK = 0;
  let bestDistance = Infinity;

  /* Phase 1: Coarse search - find minimum Earth-Sun distance */
  const samples = [];
  let minDist = Infinity, maxDist = -Infinity;
  for (let k = -searchRange; k <= searchRange; ++k) {
    const jd = approxJD + k * step;

    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Get Earth-Sun distance from the sun object (distAU is computed in updatePositions)
    const distance = sun.distAU;
    if (distance < minDist) minDist = distance;
    if (distance > maxDist) maxDist = distance;

    samples[k + searchRange] = { k, jd, distance };

    if (distance < bestDistance) {
      bestDistance = distance;
      bestK = k;
    }
  }

  const bestIdx = bestK + searchRange;

  // Warn if minimum was found at edge of search range
  if (debug && (bestK === -searchRange || bestK === searchRange)) {
    console.warn(`  WARNING: Minimum at edge of search range (k=${bestK}). Actual perihelion may be outside search window!`);
  }
  if (!samples[bestIdx]) return null;

  /* Phase 2: Parabolic interpolation for sub-sample precision */
  let refinedJD = samples[bestIdx].jd;
  let refinedDistance = bestDistance;

  if (samples[bestIdx - 1] && samples[bestIdx + 1]) {
    const y_m1 = samples[bestIdx - 1].distance;
    const y_0  = samples[bestIdx].distance;
    const y_p1 = samples[bestIdx + 1].distance;

    const denom = y_m1 - 2 * y_0 + y_p1;
    if (Math.abs(denom) > 1e-12) {
      const offset = (step / 2) * (y_m1 - y_p1) / denom;
      refinedJD = samples[bestIdx].jd + offset;

      const t = offset / step;
      refinedDistance = y_0 + 0.5 * t * (y_p1 - y_m1) + 0.5 * t * t * (y_p1 - 2 * y_0 + y_m1);
    }
  }

  /* Final scene state at refined time */
  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  if (debug) {
    const windowDays = (searchRange * step).toFixed(1);
    // Convert JD to calendar date for readability
    const jdToDate = (jd) => {
      const date = new Date((jd - 2440587.5) * 86400000);
      return date.toISOString().replace('T', ' ').replace('Z', ' UTC');
    };
    console.log(`perihelionForYear(${year}): ${jdToDate(refinedJD)} | JD=${refinedJD.toFixed(6)}`);
    console.log(`  minDist=${minDist.toFixed(8)}, maxDist=${maxDist.toFixed(8)}, range=${(maxDist-minDist).toFixed(8)} AU`);
    console.log(`  searchWindow=±${windowDays} days, approxJD=${approxJD.toFixed(4)}, refinedJD=${refinedJD.toFixed(4)}, offset=${(refinedJD - approxJD).toFixed(4)} days`);
    console.log(`  bestK=${bestK} (of ±${searchRange}), refinedDistance=${refinedDistance.toFixed(8)} AU`);
    // At perihelion, Earth is at the perihelion point, so earthPerihelionFromEarth.distAU should be ~0
    // Also check earthPerihelionFromEarth.sunDistAU (distance from perihelion point to Sun)
    if (typeof earthPerihelionFromEarth !== 'undefined') {
      const periToEarth = earthPerihelionFromEarth.distAU;
      const periToSun = earthPerihelionFromEarth.sunDistAU;
      const sunToEarth = sun.distAU;
      console.log(`  Perihelion alignment: periPoint→Earth=${periToEarth?.toFixed(10) ?? 'N/A'} AU, periPoint→Sun=${periToSun?.toFixed(10) ?? 'N/A'} AU, Sun→Earth=${sunToEarth.toFixed(10)} AU`);
      // At exact perihelion: periToEarth should be minimum (or 0 if Earth is exactly at perihelion point)
      // And: periToSun + periToEarth should equal sunToEarth (when aligned)
      if (periToSun !== undefined) {
        const alignmentSum = periToSun + periToEarth;
        const alignmentDiff = sunToEarth - alignmentSum;
        console.log(`  Alignment sum: periToSun+periToEarth=${alignmentSum.toFixed(10)}, diff from sun.distAU=${alignmentDiff.toFixed(10)} AU`);
      }
    }
  }

  return {
    jd: refinedJD,
    distance: refinedDistance,
    raDeg: (sun.ra * 180 / Math.PI + 360) % 360
  };
}

/**
 * Detect perihelion passage for the TRUE ANOMALISTIC YEAR
 * This measures distance from the FIXED wobble center (inertial frame origin) to the Sun.
 *
 * Two reference frames for perihelion detection:
 *
 * 1. EARTH-FRAME PERIHELION INTERVAL (perihelionForYear):
 *    - Measures minimum Earth→Sun distance
 *    - Earth moves due to axial precession wobble (HY/13 = 25,684 years clockwise)
 *    - This is what an observer on Earth would measure
 *    - ~127 seconds shorter than true anomalistic year (currently)
 *    - Will oscillate faster/slower than true anomalistic year over the wobble cycle
 *
 * 2. TRUE ANOMALISTIC YEAR (this function):
 *    - Measures minimum WobbleCenter→Sun distance (fixed inertial reference)
 *    - Matches IAU definition and HY/16 formula to within ~5 seconds
 *    - This is the standard astronomical anomalistic year
 */
function perihelionForYearMethodB(year, debug = false, prevPerihelionJD = null) {
  let approxJD;
  let searchRange;

  if (prevPerihelionJD !== null) {
    approxJD = prevPerihelionJD + 365.26;
    searchRange = 288;
  } else {
    // First search: estimate perihelion position accounting for precession
    // At perihelionalignmentYear (1246), perihelion is in early January (~0.03 into year)
    // Perihelion precesses through the year over HY/16 = 20,868 years
    const perihelionCycle = holisticyearLength / 16;  // 20,868 years
    const perihelionAtReference = 0.03;  // Fraction of year (early January at 1246)

    // Calculate how much perihelion has shifted from reference year
    const yearsSinceReference = year - perihelionalignmentYear;
    const perihelionShift = (yearsSinceReference / perihelionCycle) % 1;  // Fraction of year shift

    // New perihelion position in year (0 = Jan 1, 0.5 = July 1)
    let perihelionFraction = (perihelionAtReference + perihelionShift) % 1;
    if (perihelionFraction < 0) perihelionFraction += 1;

    approxJD = startmodelJD +
          ((year + perihelionFraction) - startmodelYear) * meansolaryearlengthinDays;
    searchRange = 960;
  }

  const step = 0.5 / 24;  // 0.5 h in days
  let bestK = 0;
  let bestDistance = Infinity;

  const samples = [];
  const WOBBLE_POS = new THREE.Vector3();
  const SUN_POS = new THREE.Vector3();

  for (let k = -searchRange; k <= searchRange; ++k) {
    const jd = approxJD + k * step;

    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Get WobbleCenter-Sun distance instead of Earth-Sun distance
    earthWobbleCenter.planetObj.getWorldPosition(WOBBLE_POS);
    sun.planetObj.getWorldPosition(SUN_POS);
    const distance = WOBBLE_POS.distanceTo(SUN_POS) / 100;  // scene units to AU

    samples[k + searchRange] = { k, jd, distance };

    if (distance < bestDistance) {
      bestDistance = distance;
      bestK = k;
    }
  }

  const bestIdx = bestK + searchRange;
  if (!samples[bestIdx]) return null;

  /* Phase 2: Parabolic interpolation for sub-sample precision */
  let refinedJD = samples[bestIdx].jd;
  let refinedDistance = bestDistance;

  if (samples[bestIdx - 1] && samples[bestIdx + 1]) {
    const y_m1 = samples[bestIdx - 1].distance;
    const y_0  = samples[bestIdx].distance;
    const y_p1 = samples[bestIdx + 1].distance;

    const denom = y_m1 - 2 * y_0 + y_p1;
    if (Math.abs(denom) > 1e-12) {
      const offset = (step / 2) * (y_m1 - y_p1) / denom;
      refinedJD = samples[bestIdx].jd + offset;

      const t = offset / step;
      refinedDistance = y_0 + 0.5 * t * (y_p1 - y_m1) + 0.5 * t * t * (y_p1 - 2 * y_0 + y_m1);
    }
  }

  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  if (debug) {
    const jdToDate = (jd) => {
      const date = new Date((jd - 2440587.5) * 86400000);
      return date.toISOString().replace('T', ' ').replace('Z', ' UTC');
    };
    console.log(`perihelionForYearMethodB(${year}): ${jdToDate(refinedJD)} | JD=${refinedJD.toFixed(6)}`);
    console.log(`  WobbleCenter→Sun distance: ${refinedDistance.toFixed(8)} AU`);
    console.log(`  Earth→Sun distance (for comparison): ${sun.distAU.toFixed(8)} AU`);
  }

  return {
    jd: refinedJD,
    distance: refinedDistance
  };
}

/**
 * Detect aphelion passage for the TRUE ANOMALISTIC YEAR
 * This measures maximum distance from the FIXED wobble center (inertial frame origin) to the Sun.
 * Companion to perihelionForYearMethodB for consistent anomalistic year measurements.
 */
function aphelionForYearMethodB(year, debug = false, prevAphelionJD = null) {
  let approxJD;
  let searchRange;

  if (prevAphelionJD !== null) {
    approxJD = prevAphelionJD + 365.26;
    searchRange = 288;
  } else {
    // First search: estimate aphelion position accounting for precession
    // Aphelion is 180° (0.5 year) opposite to perihelion
    // At perihelionalignmentYear (1246), perihelion is at ~0.03 into year, so aphelion is at ~0.53
    const perihelionCycle = holisticyearLength / 16;  // 20,868 years
    const aphelionAtReference = 0.53;  // Fraction of year (early July at 1246)

    // Calculate how much aphelion has shifted from reference year
    const yearsSinceReference = year - perihelionalignmentYear;
    const aphelionShift = (yearsSinceReference / perihelionCycle) % 1;  // Fraction of year shift

    // New aphelion position in year
    let aphelionFraction = (aphelionAtReference + aphelionShift) % 1;
    if (aphelionFraction < 0) aphelionFraction += 1;

    approxJD = startmodelJD +
          ((year + aphelionFraction) - startmodelYear) * meansolaryearlengthinDays;
    searchRange = 960;
  }

  const step = 0.5 / 24;  // 0.5 h in days
  let bestK = 0;
  let bestDistance = -Infinity;

  const samples = [];
  const WOBBLE_POS = new THREE.Vector3();
  const SUN_POS = new THREE.Vector3();

  for (let k = -searchRange; k <= searchRange; ++k) {
    const jd = approxJD + k * step;

    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Get WobbleCenter-Sun distance instead of Earth-Sun distance
    earthWobbleCenter.planetObj.getWorldPosition(WOBBLE_POS);
    sun.planetObj.getWorldPosition(SUN_POS);
    const distance = WOBBLE_POS.distanceTo(SUN_POS) / 100;  // scene units to AU

    samples[k + searchRange] = { k, jd, distance };

    if (distance > bestDistance) {
      bestDistance = distance;
      bestK = k;
    }
  }

  const bestIdx = bestK + searchRange;
  if (!samples[bestIdx]) return null;

  /* Phase 2: Parabolic interpolation for sub-sample precision */
  let refinedJD = samples[bestIdx].jd;
  let refinedDistance = bestDistance;

  if (samples[bestIdx - 1] && samples[bestIdx + 1]) {
    const y_m1 = samples[bestIdx - 1].distance;
    const y_0  = samples[bestIdx].distance;
    const y_p1 = samples[bestIdx + 1].distance;

    const denom = y_m1 - 2 * y_0 + y_p1;
    if (Math.abs(denom) > 1e-12) {
      const offset = (step / 2) * (y_m1 - y_p1) / denom;
      refinedJD = samples[bestIdx].jd + offset;

      const t = offset / step;
      refinedDistance = y_0 + 0.5 * t * (y_p1 - y_m1) + 0.5 * t * t * (y_p1 - 2 * y_0 + y_m1);
    }
  }

  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  if (debug) {
    const jdToDate = (jd) => {
      const date = new Date((jd - 2440587.5) * 86400000);
      return date.toISOString().replace('T', ' ').replace('Z', ' UTC');
    };
    console.log(`aphelionForYearMethodB(${year}): ${jdToDate(refinedJD)} | JD=${refinedJD.toFixed(6)}`);
    console.log(`  WobbleCenter→Sun distance: ${refinedDistance.toFixed(8)} AU`);
    console.log(`  Earth→Sun distance (for comparison): ${sun.distAU.toFixed(8)} AU`);
  }

  return {
    jd: refinedJD,
    distance: refinedDistance
  };
}

/**
 * Detect aphelion passage for a given year (maximum Earth-Sun distance)
 * At aphelion, Earth passes through the perihelion point (which is at 1 AU from Sun)
 * so periToSun + periToEarth should equal sunToEarth
 * @param {number} year - The year to find aphelion for
 * @returns {object} - { jd, distance, raDeg, alignmentDiff }
 */
function aphelionForYear(year, debug = false, prevAphelionJD = null) {
  // Aphelion is 180° opposite to perihelion - position shifts with perihelion precession
  let approxJD;
  let searchRange;

  if (prevAphelionJD !== null) {
    approxJD = prevAphelionJD + 365.26;
    searchRange = 288;  // ±6 days
  } else {
    // First search: estimate aphelion position accounting for precession
    // At perihelionalignmentYear (1246), perihelion is at ~0.03 into year, so aphelion is at ~0.53
    const perihelionCycle = holisticyearLength / 16;  // 20,868 years
    const aphelionAtReference = 0.53;  // Fraction of year (early July at 1246)

    // Calculate how much aphelion has shifted from reference year
    const yearsSinceReference = year - perihelionalignmentYear;
    const aphelionShift = (yearsSinceReference / perihelionCycle) % 1;  // Fraction of year shift

    // New aphelion position in year
    let aphelionFraction = (aphelionAtReference + aphelionShift) % 1;
    if (aphelionFraction < 0) aphelionFraction += 1;

    approxJD = startmodelJD +
          ((year + aphelionFraction) - startmodelYear) * meansolaryearlengthinDays;
    searchRange = 960;  // ±20 days for first search
  }

  const step = 0.5 / 24;  // 0.5 h in days
  let bestK = 0;
  let bestDistance = -Infinity;

  /* Phase 1: Coarse search - find maximum Earth-Sun distance */
  const samples = [];
  let minDist = Infinity, maxDist = -Infinity;
  for (let k = -searchRange; k <= searchRange; ++k) {
    const jd = approxJD + k * step;

    jumpToJulianDay(jd);
    forceSceneUpdate();

    const distance = sun.distAU;
    if (distance < minDist) minDist = distance;
    if (distance > maxDist) maxDist = distance;

    samples[k + searchRange] = { k, jd, distance };

    if (distance > bestDistance) {
      bestDistance = distance;
      bestK = k;
    }
  }

  const bestIdx = bestK + searchRange;

  if (debug && (bestK === -searchRange || bestK === searchRange)) {
    console.warn(`  WARNING: Maximum at edge of search range (k=${bestK}). Actual aphelion may be outside search window!`);
  }
  if (!samples[bestIdx]) return null;

  /* Phase 2: Parabolic interpolation for sub-sample precision */
  let refinedJD = samples[bestIdx].jd;
  let refinedDistance = bestDistance;

  if (samples[bestIdx - 1] && samples[bestIdx + 1]) {
    const y_m1 = samples[bestIdx - 1].distance;
    const y_0  = samples[bestIdx].distance;
    const y_p1 = samples[bestIdx + 1].distance;

    const denom = y_m1 - 2 * y_0 + y_p1;
    if (Math.abs(denom) > 1e-12) {
      // For maximum, the offset formula is the same but we're finding a peak
      const offset = (step / 2) * (y_m1 - y_p1) / denom;
      refinedJD = samples[bestIdx].jd + offset;

      const t = offset / step;
      refinedDistance = y_0 + 0.5 * t * (y_p1 - y_m1) + 0.5 * t * t * (y_p1 - 2 * y_0 + y_m1);
    }
  }

  /* Final scene state at refined time */
  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  // Calculate alignment difference
  let alignmentDiff = null;
  if (typeof earthPerihelionFromEarth !== 'undefined') {
    const periToEarth = earthPerihelionFromEarth.distAU;
    const periToSun = earthPerihelionFromEarth.sunDistAU;
    const sunToEarth = sun.distAU;
    if (periToSun !== undefined) {
      alignmentDiff = sunToEarth - (periToSun + periToEarth);
    }
  }

  if (debug) {
    const windowDays = (searchRange * step).toFixed(1);
    const jdToDate = (jd) => {
      const date = new Date((jd - 2440587.5) * 86400000);
      return date.toISOString().replace('T', ' ').replace('Z', ' UTC');
    };
    console.log(`aphelionForYear(${year}): ${jdToDate(refinedJD)} | JD=${refinedJD.toFixed(6)}`);
    console.log(`  minDist=${minDist.toFixed(8)}, maxDist=${maxDist.toFixed(8)}, range=${(maxDist-minDist).toFixed(8)} AU`);
    console.log(`  searchWindow=±${windowDays} days, refinedDistance=${refinedDistance.toFixed(8)} AU`);

    if (typeof earthPerihelionFromEarth !== 'undefined') {
      const periToEarth = earthPerihelionFromEarth.distAU;
      const periToSun = earthPerihelionFromEarth.sunDistAU;
      const sunToEarth = sun.distAU;
      console.log(`  Alignment: periPoint→Earth=${periToEarth?.toFixed(10) ?? 'N/A'} AU, periPoint→Sun=${periToSun?.toFixed(10) ?? 'N/A'} AU, Sun→Earth=${sunToEarth.toFixed(10)} AU`);
      if (periToSun !== undefined) {
        const alignmentSum = periToSun + periToEarth;
        console.log(`  Alignment sum: ${alignmentSum.toFixed(10)}, diff from sun.distAU=${alignmentDiff?.toFixed(10)} AU`);
      }
    }
  }

  return {
    jd: refinedJD,
    distance: refinedDistance,
    raDeg: (sun.ra * 180 / Math.PI + 360) % 360,
    alignmentDiff
  };
}

async function runSolsticeExport(years) {

  console.log('Solstice export for years:', years);

  /* A · freeze viewer */
  const oldRun  = o.Run;
  const oldJD   = o.julianDay;
  const oldTime = o.Time;
  o.Run = false;

  /* B · rows */
  const rows = [['Date', 'Time', 'Year', 'JD', 'RA (°)', 'Obliquity (°)']];
  const YIELD_EVERY = 25;
  let done = 0;

  for (const y of years) {
    const r = solsticeForYear(y);
    if (!r) continue;

    rows.push([
      o.Date,
      o.Time,
      y,
      r.jd.toFixed(6),
      r.raDeg.toFixed(6),
      r.obliqDeg.toFixed(6)
    ]);
    if (++done % YIELD_EVERY === 0) {
      await new Promise(requestAnimationFrame);
    }
  }

  /* C · restore viewer */
  o.Time = oldTime;
  jumpToJulianDay(oldJD);
  o.Run  = oldRun;

  /* D · write file */
  if (done) {
    await ensureSheetJs();
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb,
        XLSX.utils.aoa_to_sheet(rows), 'Solstice Dates');
    const url = URL.createObjectURL(workbookToBlob(wb));
    Object.assign(document.createElement('a'), {
      href: url,
      download: 'Holistic_solstice_results.xlsx'
    }).click();
    URL.revokeObjectURL(url);
    console.log(`Export finished – ${done} rows`);
  } else {
    console.error('No valid years – nothing written');
  }
}

/* ══════════════════════════════════════════════════════════════════════════
   YEAR ANALYSIS REPORT EXPORT
   Creates an Excel file with comprehensive alignment analysis data
   (same data as "Analyze All Alignments" console test but in Excel format)

   TRUE SINGLE-PASS IMPLEMENTATION: All data is collected in one loop through
   the year range for optimal performance and clear progress indication.
   ══════════════════════════════════════════════════════════════════════════ */

async function runYearAnalysisExport(years) {
  if (!years || years.length < 1) {
    alert('Need at least 1 year to generate report.');
    return;
  }

  // Sort and dedupe the requested years
  const requestedYears = [...new Set(years)].sort((a, b) => a - b);

  // For intervals, we need year-1 for each requested year
  // Build a set of all years we need to collect
  const yearsToCollect = new Set();
  for (const y of requestedYears) {
    yearsToCollect.add(y - 1);  // Previous year for interval calculation
    yearsToCollect.add(y);      // The requested year itself
  }
  const sortedCollectYears = [...yearsToCollect].sort((a, b) => a - b);

  const startYear = Math.min(...requestedYears);
  const endYear = Math.max(...requestedYears);

  console.log('Year Analysis Report for years:', requestedYears.join(', '));

  /* A · freeze viewer */
  const oldRun = o.Run;
  const oldJD = o.julianDay;
  o.Run = false;

  const YIELD_EVERY = 5;

  /* B · Data structures for all measurements */
  const cardinalData = {
    VE: { ra: 0, name: 'Vernal Equinox', iauRef: ASTRO_REFERENCE.tropicalYearVEJ2000, events: [] },
    SS: { ra: 90, name: 'Summer Solstice', iauRef: ASTRO_REFERENCE.tropicalYearSSJ2000, events: [] },
    AE: { ra: 180, name: 'Autumnal Equinox', iauRef: ASTRO_REFERENCE.tropicalYearAEJ2000, events: [] },
    WS: { ra: 270, name: 'Winter Solstice', iauRef: ASTRO_REFERENCE.tropicalYearWSJ2000, events: [] }
  };

  const perihelions = [];
  const aphelions = [];
  const siderealCrossings = [];
  const yearlyOrbitalParams = []; // Store obliquity/eccentricity per year

  // State trackers for each measurement type (maintained across years)
  let prevJD_VE = null, prevJD_SS = null, prevJD_AE = null, prevJD_WS = null;
  let prevPeriJD = null;
  let prevAphelionJD = null;
  let firstSiderealJD = null;
  let targetSiderealAngle = null;

  // Helper for sidereal angle calculation
  const getSunWorldAngle = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    const sunPos = new THREE.Vector3();
    sun.planetObj.getWorldPosition(sunPos);
    let angle = Math.atan2(sunPos.z, sunPos.x) * 180 / Math.PI;
    return ((angle % 360) + 360) % 360;
  };

  /* C · SINGLE PASS: Collect ALL data for each year we need */
  // sortedCollectYears includes requested years + their year-1 for interval calculation
  const totalToCollect = sortedCollectYears.length;
  console.log(`Collecting all measurements for ${totalToCollect} years...`);

  // Track previous year for each measurement type to determine if years are consecutive
  let prevYear_VE = null, prevYear_SS = null, prevYear_AE = null, prevYear_WS = null;
  let prevYear_Peri = null, prevYear_Aph = null, prevYear_Sid = null;

  for (let idx = 0; idx < sortedCollectYears.length; idx++) {
    const year = sortedCollectYears[idx];
    const progress = ((idx + 1) / totalToCollect * 100).toFixed(0);
    if (idx % YIELD_EVERY === 0) {
      console.log(`Processing year ${year} (${progress}%)`);
      await new Promise(r => setTimeout(r, 10));
    }

    // 1. Collect all 4 cardinal points for this year
    // Only use prevJD if years are consecutive (for consistent results between Range and List mode)
    const useVEPrev = (prevYear_VE !== null && year - prevYear_VE === 1) ? prevJD_VE : null;
    const veResult = sunRACrossingForYear(year, 0, useVEPrev);
    if (veResult) {
      cardinalData.VE.events.push({ year, jd: veResult.jd });
      prevJD_VE = veResult.jd;
      prevYear_VE = year;
    }

    const useSSPrev = (prevYear_SS !== null && year - prevYear_SS === 1) ? prevJD_SS : null;
    const ssResult = sunRACrossingForYear(year, 90, useSSPrev);
    if (ssResult) {
      cardinalData.SS.events.push({ year, jd: ssResult.jd });
      prevJD_SS = ssResult.jd;
      prevYear_SS = year;
    }

    const useAEPrev = (prevYear_AE !== null && year - prevYear_AE === 1) ? prevJD_AE : null;
    const aeResult = sunRACrossingForYear(year, 180, useAEPrev);
    if (aeResult) {
      cardinalData.AE.events.push({ year, jd: aeResult.jd });
      prevJD_AE = aeResult.jd;
      prevYear_AE = year;
    }

    const useWSPrev = (prevYear_WS !== null && year - prevYear_WS === 1) ? prevJD_WS : null;
    const wsResult = sunRACrossingForYear(year, 270, useWSPrev);
    if (wsResult) {
      cardinalData.WS.events.push({ year, jd: wsResult.jd });
      prevJD_WS = wsResult.jd;
      prevYear_WS = year;
    }

    // 2. Collect perihelion for this year
    const usePeriPrev = (prevYear_Peri !== null && year - prevYear_Peri === 1) ? prevPeriJD : null;
    const periResult = perihelionForYearMethodB(year, false, usePeriPrev);
    if (periResult) {
      perihelions.push({ year, jd: periResult.jd, distance: periResult.distance });
      prevPeriJD = periResult.jd;
      prevYear_Peri = year;
    }

    // 3. Collect aphelion for this year
    const useAphPrev = (prevYear_Aph !== null && year - prevYear_Aph === 1) ? prevAphelionJD : null;
    const aphResult = aphelionForYearMethodB(year, false, useAphPrev);
    if (aphResult) {
      aphelions.push({ year, jd: aphResult.jd, distance: aphResult.distance });
      prevAphelionJD = aphResult.jd;
      prevYear_Aph = year;
    }

    // 4. Collect sidereal crossing for this year
    // Only use previous crossing optimization if years are consecutive (for consistent results)
    let approxJD, searchRange;
    const useSiderealPrev = (prevYear_Sid !== null && year - prevYear_Sid === 1);
    if (firstSiderealJD !== null && useSiderealPrev) {
      const prevCrossing = siderealCrossings[siderealCrossings.length - 1];
      approxJD = prevCrossing.jd + 365.256;
      searchRange = 288;
    } else {
      // For non-consecutive years or first crossing, use absolute calculation
      const yearFraction = 0.47;
      approxJD = startmodelJD + ((year + yearFraction) - startmodelYear) * meansolaryearlengthinDays;
      searchRange = 960;
    }

    const step = 0.5 / 24;
    const samples = [];
    for (let k = -searchRange; k <= searchRange; ++k) {
      const jd = approxJD + k * step;
      const angle = getSunWorldAngle(jd);
      samples.push({ k, jd, angle });
    }

    let crossingJD = null;
    if (firstSiderealJD === null) {
      const target = 90;
      for (let i = 1; i < samples.length; i++) {
        jumpToJulianDay(samples[i - 1].jd);
        forceSceneUpdate();
        const ra1 = (sun.ra * 180 / Math.PI + 360) % 360;
        jumpToJulianDay(samples[i].jd);
        forceSceneUpdate();
        const ra2 = (sun.ra * 180 / Math.PI + 360) % 360;
        if (ra1 < target && ra2 >= target) {
          const t = (target - ra1) / (ra2 - ra1);
          crossingJD = samples[i - 1].jd + t * step;
          firstSiderealJD = crossingJD;
          targetSiderealAngle = getSunWorldAngle(crossingJD);
          break;
        }
      }
    } else {
      for (let i = 1; i < samples.length; i++) {
        let a1 = samples[i - 1].angle;
        let a2 = samples[i].angle;
        if (Math.abs(a2 - a1) > 180) {
          if (a2 > a1) a1 += 360;
          else a2 += 360;
        }
        let adjustedTarget = targetSiderealAngle;
        if (a1 > 360 || a2 > 360) {
          if (targetSiderealAngle < 180) adjustedTarget = targetSiderealAngle + 360;
        }
        const crossingUp = a1 < adjustedTarget && a2 >= adjustedTarget;
        const crossingDown = a1 > adjustedTarget && a2 <= adjustedTarget;
        if (crossingUp || crossingDown) {
          const t = Math.abs(adjustedTarget - a1) / Math.abs(a2 - a1);
          crossingJD = samples[i - 1].jd + t * step;
          break;
        }
      }
    }
    if (crossingJD) {
      siderealCrossings.push({ year, jd: crossingJD });
      prevYear_Sid = year;
    }

    // 5. Collect orbital parameters (obliquity, eccentricity) at mid-year
    jumpToJulianDay(startmodelJD + (year + 0.5 - startmodelYear) * meansolaryearlengthinDays);
    forceSceneUpdate();
    yearlyOrbitalParams.push({
      year,
      obliquity: o.obliquityEarth || 0,
      eccentricity: o.eccentricityEarth || 0
    });
  }

  console.log('Data collection complete.');

  /* D · Calculate intervals - keyed by year for correct lookup in List mode */
  // For each data type, create a Map: year -> interval (from previous year to this year)
  for (const key of Object.keys(cardinalData)) {
    const point = cardinalData[key];
    point.intervalsByYear = new Map();
    for (let i = 1; i < point.events.length; i++) {
      const prevYear = point.events[i - 1].year;
      const currYear = point.events[i].year;
      // Only calculate interval if years are consecutive (currYear - prevYear === 1)
      if (currYear - prevYear === 1) {
        point.intervalsByYear.set(currYear, point.events[i].jd - point.events[i - 1].jd);
      }
    }
    // Calculate mean from requested years only
    const requestedIntervals = requestedYears
      .map(y => point.intervalsByYear.get(y))
      .filter(v => v !== undefined);
    point.mean = requestedIntervals.length > 0
      ? requestedIntervals.reduce((a, b) => a + b, 0) / requestedIntervals.length
      : 0;
  }

  const perihelionIntervalsByYear = new Map();
  for (let i = 1; i < perihelions.length; i++) {
    const prevYear = perihelions[i - 1].year;
    const currYear = perihelions[i].year;
    if (currYear - prevYear === 1) {
      perihelionIntervalsByYear.set(currYear, perihelions[i].jd - perihelions[i - 1].jd);
    }
  }
  const requestedPeriIntervals = requestedYears
    .map(y => perihelionIntervalsByYear.get(y))
    .filter(v => v !== undefined);
  const meanPerihelion = requestedPeriIntervals.length > 0
    ? requestedPeriIntervals.reduce((a, b) => a + b, 0) / requestedPeriIntervals.length
    : 0;

  const aphelionIntervalsByYear = new Map();
  for (let i = 1; i < aphelions.length; i++) {
    const prevYear = aphelions[i - 1].year;
    const currYear = aphelions[i].year;
    if (currYear - prevYear === 1) {
      aphelionIntervalsByYear.set(currYear, aphelions[i].jd - aphelions[i - 1].jd);
    }
  }
  const requestedAphIntervals = requestedYears
    .map(y => aphelionIntervalsByYear.get(y))
    .filter(v => v !== undefined);
  const meanAphelion = requestedAphIntervals.length > 0
    ? requestedAphIntervals.reduce((a, b) => a + b, 0) / requestedAphIntervals.length
    : 0;

  const siderealIntervalsByYear = new Map();
  for (let i = 1; i < siderealCrossings.length; i++) {
    const prevYear = siderealCrossings[i - 1].year;
    const currYear = siderealCrossings[i].year;
    if (currYear - prevYear === 1) {
      siderealIntervalsByYear.set(currYear, siderealCrossings[i].jd - siderealCrossings[i - 1].jd);
    }
  }
  const requestedSiderealIntervals = requestedYears
    .map(y => siderealIntervalsByYear.get(y))
    .filter(v => v !== undefined);
  const meanSiderealYear = requestedSiderealIntervals.length > 0
    ? requestedSiderealIntervals.reduce((a, b) => a + b, 0) / requestedSiderealIntervals.length
    : 0;

  const meanTropicalYear = (cardinalData.VE.mean + cardinalData.SS.mean +
    cardinalData.AE.mean + cardinalData.WS.mean) / 4;

  // Get orbital parameters at middle year from our collected data
  const midYearIndex = Math.floor(yearlyOrbitalParams.length / 2);
  const midYear = yearlyOrbitalParams[midYearIndex]?.year || Math.floor((startYear + endYear) / 2);
  const obliquity = yearlyOrbitalParams[midYearIndex]?.obliquity || 0;
  const eccentricity = yearlyOrbitalParams[midYearIndex]?.eccentricity || 0;

  /* E · Build Excel sheets */
  await ensureSheetJs();

  // Sheet 1: Summary
  const summaryRows = [
    ['YEAR ANALYSIS REPORT'],
    ['Generated', new Date().toISOString()],
    ['Analysis Period', `${startYear} to ${endYear} (${endYear - startYear} years)`],
    [],
    ['ORBITAL PARAMETERS (at mid-point year ' + midYear + ')'],
    ['Obliquity (°)', obliquity?.toFixed(6) || 'N/A'],
    ['Eccentricity', eccentricity?.toFixed(8) || 'N/A'],
    [],
    ['TROPICAL YEAR BY CARDINAL POINT', 'Measured (days)', 'IAU J2000 Ref (days)', 'Diff (seconds)'],
    ['Vernal Equinox (RA=0°)', cardinalData.VE.mean.toFixed(9), cardinalData.VE.iauRef.toFixed(9), ((cardinalData.VE.mean - cardinalData.VE.iauRef) * 86400).toFixed(2)],
    ['Summer Solstice (RA=90°)', cardinalData.SS.mean.toFixed(9), cardinalData.SS.iauRef.toFixed(9), ((cardinalData.SS.mean - cardinalData.SS.iauRef) * 86400).toFixed(2)],
    ['Autumnal Equinox (RA=180°)', cardinalData.AE.mean.toFixed(9), cardinalData.AE.iauRef.toFixed(9), ((cardinalData.AE.mean - cardinalData.AE.iauRef) * 86400).toFixed(2)],
    ['Winter Solstice (RA=270°)', cardinalData.WS.mean.toFixed(9), cardinalData.WS.iauRef.toFixed(9), ((cardinalData.WS.mean - cardinalData.WS.iauRef) * 86400).toFixed(2)],
    [],
    ['MEAN TROPICAL YEAR (average of 4 cardinal points)'],
    ['Measured Mean', meanTropicalYear.toFixed(9)],
    ['IAU Mean J2000', ASTRO_REFERENCE.tropicalYearMeanJ2000.toFixed(9)],
    ['Difference (seconds)', ((meanTropicalYear - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400).toFixed(2)],
    ['Model Configured', meansolaryearlengthinDays.toFixed(9)],
    [],
    ['ANOMALISTIC YEAR', 'Measured (days)', 'IAU J2000 Ref (days)', 'Diff (seconds)'],
    ['Perihelion to Perihelion', meanPerihelion.toFixed(9), ASTRO_REFERENCE.anomalisticYearJ2000.toFixed(9), ((meanPerihelion - ASTRO_REFERENCE.anomalisticYearJ2000) * 86400).toFixed(2)],
    ['Aphelion to Aphelion', meanAphelion.toFixed(9), ASTRO_REFERENCE.anomalisticYearJ2000.toFixed(9), ((meanAphelion - ASTRO_REFERENCE.anomalisticYearJ2000) * 86400).toFixed(2)],
    [],
    ['SIDEREAL YEAR', 'Measured (days)', 'IAU J2000 Ref (days)', 'Diff (seconds)'],
    ['Sidereal Year', meanSiderealYear.toFixed(9), ASTRO_REFERENCE.siderealYearJ2000.toFixed(9), ((meanSiderealYear - ASTRO_REFERENCE.siderealYearJ2000) * 86400).toFixed(2)],
    ['Sidereal - Tropical (model)', '', '', ((meanSiderealYear - meanTropicalYear) * 86400).toFixed(2)],
    ['Sidereal - Tropical (IAU)', '', '', ((ASTRO_REFERENCE.siderealYearJ2000 - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400).toFixed(2)]
  ];

  // Helper to get interval by year from a Map
  const getInterval = (map, year) => {
    const val = map.get(year);
    return val !== undefined ? val.toFixed(9) : '';
  };

  // Build lookup maps for events by year (for JD values)
  const veEventsByYear = new Map(cardinalData.VE.events.map(e => [e.year, e]));
  const ssEventsByYear = new Map(cardinalData.SS.events.map(e => [e.year, e]));
  const aeEventsByYear = new Map(cardinalData.AE.events.map(e => [e.year, e]));
  const wsEventsByYear = new Map(cardinalData.WS.events.map(e => [e.year, e]));
  const periByYear = new Map(perihelions.map(e => [e.year, e]));
  const aphByYear = new Map(aphelions.map(e => [e.year, e]));
  const siderealByYear = new Map(siderealCrossings.map(e => [e.year, e]));
  const orbParamsByYear = new Map(yearlyOrbitalParams.map(e => [e.year, e]));

  // Sheet 2: Cardinal Points Detail (filter to user-requested years only)
  const cardinalRows = [
    ['Year', 'VE JD', 'VE Interval (days)', 'SS JD', 'SS Interval (days)', 'AE JD', 'AE Interval (days)', 'WS JD', 'WS Interval (days)']
  ];
  for (const year of requestedYears) {
    const veEvent = veEventsByYear.get(year);
    const ssEvent = ssEventsByYear.get(year);
    const aeEvent = aeEventsByYear.get(year);
    const wsEvent = wsEventsByYear.get(year);
    const row = [
      year,
      veEvent?.jd?.toFixed(6) || '',
      getInterval(cardinalData.VE.intervalsByYear, year),
      ssEvent?.jd?.toFixed(6) || '',
      getInterval(cardinalData.SS.intervalsByYear, year),
      aeEvent?.jd?.toFixed(6) || '',
      getInterval(cardinalData.AE.intervalsByYear, year),
      wsEvent?.jd?.toFixed(6) || '',
      getInterval(cardinalData.WS.intervalsByYear, year)
    ];
    cardinalRows.push(row);
  }

  // Sheet 3: Anomalistic Data (filter to user-requested years only)
  const anomalisticRows = [
    ['Year', 'Perihelion JD', 'Perihelion Dist (AU)', 'Peri Interval (days)', 'Aphelion JD', 'Aphelion Dist (AU)', 'Aph Interval (days)']
  ];
  for (const year of requestedYears) {
    const peri = periByYear.get(year);
    const aph = aphByYear.get(year);
    const row = [
      year,
      peri?.jd?.toFixed(6) || '',
      peri?.distance?.toFixed(8) || '',
      getInterval(perihelionIntervalsByYear, year),
      aph?.jd?.toFixed(6) || '',
      aph?.distance?.toFixed(8) || '',
      getInterval(aphelionIntervalsByYear, year)
    ];
    anomalisticRows.push(row);
  }

  // Sheet 4: Sidereal Data (filter to user-requested years only)
  const siderealRows = [
    ['Year', 'Sidereal Crossing JD', 'Sidereal Interval (days)']
  ];
  for (const year of requestedYears) {
    const sid = siderealByYear.get(year);
    const row = [
      year,
      sid?.jd?.toFixed(6) || '',
      getInterval(siderealIntervalsByYear, year)
    ];
    siderealRows.push(row);
  }

  // Sheet 5: Detailed Combined Data (using already-collected orbital params)
  const detailedRows = [
    ['Year', 'Obliquity (°)', 'Eccentricity', 'Mean Tropical Year', 'VE Interval', 'SS Interval', 'AE Interval', 'WS Interval', 'Peri Interval', 'Aph Interval', 'Sidereal Interval']
  ];

  for (const year of requestedYears) {
    const orbParams = orbParamsByYear.get(year) || {};

    // Calculate mean tropical year for this specific year (average of 4 cardinal intervals)
    const veInt = cardinalData.VE.intervalsByYear.get(year);
    const ssInt = cardinalData.SS.intervalsByYear.get(year);
    const aeInt = cardinalData.AE.intervalsByYear.get(year);
    const wsInt = cardinalData.WS.intervalsByYear.get(year);
    const meanTropicalForYear = (veInt !== undefined && ssInt !== undefined && aeInt !== undefined && wsInt !== undefined)
      ? ((veInt + ssInt + aeInt + wsInt) / 4).toFixed(9)
      : '';

    detailedRows.push([
      year,
      (orbParams.obliquity || 0).toFixed(6),
      (orbParams.eccentricity || 0).toFixed(8),
      meanTropicalForYear,
      getInterval(cardinalData.VE.intervalsByYear, year),
      getInterval(cardinalData.SS.intervalsByYear, year),
      getInterval(cardinalData.AE.intervalsByYear, year),
      getInterval(cardinalData.WS.intervalsByYear, year),
      getInterval(perihelionIntervalsByYear, year),
      getInterval(aphelionIntervalsByYear, year),
      getInterval(siderealIntervalsByYear, year)
    ]);
  }

  /* E · Create workbook and download */
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(summaryRows), 'Summary');
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(cardinalRows), 'Cardinal Points');
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(anomalisticRows), 'Anomalistic');
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(siderealRows), 'Sidereal');
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(detailedRows), 'Detailed');

  const url = URL.createObjectURL(workbookToBlob(wb));
  // Filename: use range format for consecutive years, or list first/last for sparse lists
  const filename = requestedYears.length === (endYear - startYear + 1)
    ? `Holistic_year_analysis_${startYear}_${endYear}.xlsx`
    : `Holistic_year_analysis_${requestedYears.length}_years.xlsx`;
  Object.assign(document.createElement('a'), {
    href: url,
    download: filename
  }).click();
  URL.revokeObjectURL(url);

  /* F · restore viewer */
  jumpToJulianDay(oldJD);
  o.Run = oldRun;

  console.log(`Year Analysis Report finished – ${requestedYears.length} years analyzed`);
}

/* ----------------------------------------------------------------------
   fracDayToTimeStr() helper  (unchanged)
---------------------------------------------------------------------- */
function fracDayToTimeStr(frac) {
  const totalSec = Math.round(frac * 86400);
  const hh = Math.floor(totalSec / 3600);
  const mm = Math.floor((totalSec % 3600) / 60);
  const ss = totalSec % 60;
  return `${String(hh).padStart(2,'0')}:` +
         `${String(mm).padStart(2,'0')}:` +
         `${String(ss).padStart(2,'0')}`;
}

/* ----------------------------------------------------------------------
   Build array of integer years according to the current GUI mode.
---------------------------------------------------------------------- */
function buildYearArray() {

  if (o.solMode === 'List') {
    const raw = document.querySelector('input[data-property="solYearsText"]')
               ?.value || o.solYearsText;
    return (raw.match(/-?\d+/g) || [])          // ['1999','2000', …]
           .map(Number)
           .filter(Number.isFinite);
  }

  /* --- Range mode ---------------------------------------------------- */
  const s = Number(o.solRangeStart);
  const e = Number(o.solRangeEnd);

  if (!Number.isFinite(s) || !Number.isFinite(e)) {
    console.error('Solstice “Range” values must be numbers:', s, e);
    return [];
  }
  const step = s <= e ? 1 : -1;
  const yrs  = [];
  for (let y = s; step > 0 ? y <= e : y >= e; y += step) yrs.push(y);
  return yrs;
}

/* ----------------------------------------------------------------------
   Build array of integer years for Year Analysis Report.
---------------------------------------------------------------------- */
function buildYearAnalysisArray() {

  if (o.yearAnalysisMode === 'List') {
    const raw = document.querySelector('input[data-property="yearAnalysisYearsText"]')
               ?.value || o.yearAnalysisYearsText;
    return (raw.match(/-?\d+/g) || [])          // ['1999','2000', …]
           .map(Number)
           .filter(Number.isFinite);
  }

  /* --- Range mode ---------------------------------------------------- */
  const s = Number(o.yearAnalysisRangeStart);
  const e = Number(o.yearAnalysisRangeEnd);

  if (!Number.isFinite(s) || !Number.isFinite(e)) {
    console.error('Year Analysis "Range" values must be numbers:', s, e);
    return [];
  }
  const step = s <= e ? 1 : -1;
  const yrs  = [];
  for (let y = s; step > 0 ? y <= e : y >= e; y += step) yrs.push(y);
  return yrs;
}

/* ══════════════════════════════════════════════════════════════════════════
   OBLIQUITY CALIBRATION TEST FUNCTIONS
   These functions test the model's obliquity and solstice alignment against
   astronomical reference data (IAU 2006, Laskar 1986, USNO ephemeris).
   ══════════════════════════════════════════════════════════════════════════ */

// Reference June solstice Julian Dates (Source: astropixels.com, Jean Meeus algorithms)
// JD convention: JD X.5 = midnight UTC, JD X.0 = noon UTC
// Example: JD 2451716.5 = June 21, 2000 00:00 UTC
const JUNE_SOLSTICE_REFERENCE = {
  1990: { jd: 2448091.148148, time: '15:33' },   // June 21, 1990 15:33 UTC
  1995: { jd: 2449919.357639, time: '20:34' },   // June 21, 1995 20:34 UTC
  2000: { jd: 2451716.575000, time: '01:48' },   // June 21, 2000 01:48 UTC
  2005: { jd: 2453542.781944, time: '06:46' },   // June 21, 2005 06:46 UTC
  2010: { jd: 2455368.977778, time: '11:28' },   // June 21, 2010 11:28 UTC
  2015: { jd: 2457195.193056, time: '16:38' },   // June 21, 2015 16:38 UTC
  2020: { jd: 2459021.404861, time: '21:43' },   // June 20, 2020 21:43 UTC
  2025: { jd: 2460847.612500, time: '02:42' },   // June 21, 2025 02:42 UTC
};

/** Calculate mean obliquity using IAU 2006 formula (P03 model) */
function meanObliquityIAU2006(year) {
  const T = (year - 2000) / 100;
  // IAU 2006 polynomial: ε = ε₀ + rate*T + higher order terms
  const eps_arcsec = ASTRO_REFERENCE.obliquityJ2000_arcsec
    + ASTRO_REFERENCE.obliquityRate_arcsecPerCentury * T
    - 0.0001831 * T * T + 0.00200340 * T * T * T;
  return eps_arcsec / 3600;
}

/** Calculate mean obliquity using Laskar (1986) formula - valid ±10,000 years */
function meanObliquityLaskar1986(year) {
  const t = (year - 2000) / 10000;
  const eps_arcsec = 84381.448
    - 4680.93 * t - 1.55 * Math.pow(t, 2) + 1999.25 * Math.pow(t, 3)
    - 51.38 * Math.pow(t, 4) - 249.67 * Math.pow(t, 5) - 39.05 * Math.pow(t, 6)
    + 7.12 * Math.pow(t, 7) + 27.87 * Math.pow(t, 8) + 5.79 * Math.pow(t, 9)
    + 2.45 * Math.pow(t, 10);
  return eps_arcsec / 3600;
}

/** Main calibration test - runs comprehensive tests against reference data */
async function runObliquityCalibrationTest() {
  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           OBLIQUITY CALIBRATION VERIFICATION                             ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log('');

  const savedJD = o.julianDay;
  const savedTime = o.Time;
  const savedRun = o.Run;
  o.Run = false;

  // TEST 1: Current parameters
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('TEST 1: Current Model Parameters');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`earthtiltMean                    = ${earthtiltMean}°`);
  console.log(`earthInvPlaneInclinationAmplitude = ${earthInvPlaneInclinationAmplitude}°`);
  console.log(`earthRAAngle                     = ${earthRAAngle}°`);
  console.log(`temperatureGraphMostLikely       = ${temperatureGraphMostLikely}`);
  console.log(`balancedYear                     = ${balancedYear}`);
  console.log('');

  // TEST 2: Scene object tilts at model start
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('TEST 2: Tilt Values at Model Start (JD ' + startmodelJD + ')');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  jumpToJulianDay(startmodelJD);
  forceSceneUpdate();
  await new Promise(r => setTimeout(r, 100));

  const eclipticTiltX = earthEclipticPrecession.containerObj.rotation.x * 180 / Math.PI;
  const eclipticTiltZ = earthEclipticPrecession.containerObj.rotation.z * 180 / Math.PI;
  const obliquityTiltX = earthObliquityPrecession.containerObj.rotation.x * 180 / Math.PI;
  const obliquityTiltZ = earthObliquityPrecession.containerObj.rotation.z * 180 / Math.PI;
  const netTiltX = eclipticTiltX + obliquityTiltX;
  const netTiltZ = eclipticTiltZ + obliquityTiltZ;
  const netTilt = Math.sqrt(netTiltX * netTiltX + netTiltZ * netTiltZ);

  console.log(`earthEclipticPrecession:  x=${eclipticTiltX.toFixed(6)}°, z=${eclipticTiltZ.toFixed(6)}°`);
  console.log(`earthObliquityPrecession: x=${obliquityTiltX.toFixed(6)}°, z=${obliquityTiltZ.toFixed(6)}°`);
  console.log(`Net tilt (sum):           x=${netTiltX.toFixed(6)}°, z=${netTiltZ.toFixed(6)}°, mag=${netTilt.toFixed(6)}°`);
  console.log(`o.obliquityEarth:         ${o.obliquityEarth?.toFixed(8) || 'N/A'}°`);
  console.log('');

  // TEST 3: Solstice detection vs reference
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('TEST 3: June Solstice Detection vs Astronomical Reference');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('╔══════╤═══════════════════╤═══════════════════╤══════════════╤══════════╗');
  console.log('║ Year │ Reference JD      │ Model JD          │ Δ (hours)    │ Δ (min)  ║');
  console.log('╠══════╪═══════════════════╪═══════════════════╪══════════════╪══════════╣');

  const testYears = [2000, 2005, 2010, 2015, 2020];
  const solsticeResults = [];

  for (const year of testYears) {
    const ref = JUNE_SOLSTICE_REFERENCE[year];
    if (!ref) continue;
    const result = solsticeForYear(year);
    if (!result) {
      console.log(`║ ${year} │ ${ref.jd.toFixed(6)}      │ FAILED            │              │          ║`);
      continue;
    }
    const deltaJD = result.jd - ref.jd;
    const deltaHours = deltaJD * 24;
    const deltaMinutes = deltaJD * 24 * 60;
    solsticeResults.push({ year, ref: ref.jd, model: result.jd, deltaHours, deltaMinutes });
    console.log(`║ ${year} │ ${ref.jd.toFixed(6)}      │ ${result.jd.toFixed(6)}      │ ${deltaHours >= 0 ? '+' : ''}${deltaHours.toFixed(4)}      │ ${deltaMinutes >= 0 ? '+' : ''}${deltaMinutes.toFixed(1)}    ║`);
  }
  console.log('╚══════╧═══════════════════╧═══════════════════╧══════════════╧══════════╝');

  if (solsticeResults.length >= 2) {
    const first = solsticeResults[0];
    const last = solsticeResults[solsticeResults.length - 1];
    const yearSpan = last.year - first.year;
    const driftMinutes = last.deltaMinutes - first.deltaMinutes;
    const driftSecondsPerYear = (driftMinutes / yearSpan) * 60;
    console.log(`\nDrift over ${yearSpan} years: ${driftMinutes.toFixed(2)} min (${driftSecondsPerYear.toFixed(2)} sec/year)`);
  }
  console.log('');

  // TEST 4: Obliquity vs IAU/Laskar
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('TEST 4: Model Obliquity vs IAU 2006 / Laskar 1986');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('╔══════╤═══════════════╤═══════════════╤═══════════════╤═══════════╤═══════════╗');
  console.log('║ Year │ IAU 2006 (°)  │ Laskar (°)    │ Model (°)     │ Δ IAU (") │ Δ Lask(") ║');
  console.log('╠══════╪═══════════════╪═══════════════╪═══════════════╪═══════════╪═══════════╣');

  for (const year of [1900, 1950, 2000, 2050, 2100, 2500, 3000]) {
    const oblIAU = meanObliquityIAU2006(year);
    const oblLaskar = meanObliquityLaskar1986(year);
    const jd = startmodelJD + (year - 2000) * meansolaryearlengthinDays;
    jumpToJulianDay(jd);
    forceSceneUpdate();
    await new Promise(r => setTimeout(r, 50));
    const oblModel = o.obliquityEarth || earthtiltMean;
    const deltaIAU = (oblModel - oblIAU) * 3600;
    const deltaLaskar = (oblModel - oblLaskar) * 3600;
    console.log(`║ ${year} │ ${oblIAU.toFixed(5)}°     │ ${oblLaskar.toFixed(5)}°     │ ${oblModel.toFixed(5)}°     │ ${deltaIAU >= 0 ? '+' : ''}${deltaIAU.toFixed(1).padStart(6)}   │ ${deltaLaskar >= 0 ? '+' : ''}${deltaLaskar.toFixed(1).padStart(6)}   ║`);
  }
  console.log('╚══════╧═══════════════╧═══════════════╧═══════════════╧═══════════╧═══════════╝');
  console.log('');

  // TEST 5: earthRAAngle analysis
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('TEST 5: earthRAAngle Relationships');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`2 × amplitude = ${(2 * earthInvPlaneInclinationAmplitude).toFixed(6)}°`);
  console.log(`earthRAAngle  = ${earthRAAngle}°`);
  console.log(`Difference    = ${(2 * earthInvPlaneInclinationAmplitude - earthRAAngle).toFixed(6)}°`);
  console.log(`Net tilt      = ${netTilt.toFixed(6)}°`);
  console.log(`2×amp - (2/3)×net = ${(2 * earthInvPlaneInclinationAmplitude - 2/3 * netTilt).toFixed(6)}°`);
  console.log('');

  // TEST 6: Obliquity Rate Verification
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('TEST 6: Obliquity Rate Verification vs IAU 2006');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  const IAU_OBLIQUITY_J2000 = ASTRO_REFERENCE.obliquityJ2000_deg;
  const IAU_RATE = ASTRO_REFERENCE.obliquityRate_arcsecPerCentury;
  const IAU_RATE_DEG = ASTRO_REFERENCE.obliquityRate_degPerCentury;
  const JD_J2000 = 2451545.0;

  const rateYears = [1990, 1995, 2000, 2005, 2010, 2015, 2020, 2025];
  const rateResults = [];

  console.log('╔══════╤══════════════╤══════════════╤══════════╗');
  console.log('║ Year │ Model (°)    │ IAU 2006 (°) │ Diff (") ║');
  console.log('╠══════╪══════════════╪══════════════╪══════════╣');

  for (const year of rateYears) {
    const jd = dateToJulianDay(year, 1, 1) + 0.5;
    jumpToJulianDay(jd);
    forceSceneUpdate();
    await new Promise(r => setTimeout(r, 50));

    const modelObliquity = o.obliquityEarth;
    const centuriesFromJ2000 = (jd - JD_J2000) / 36525;
    const iauObliquity = IAU_OBLIQUITY_J2000 + IAU_RATE_DEG * centuriesFromJ2000;
    const diffArcsec = (modelObliquity - iauObliquity) * 3600;

    rateResults.push({ year, model: modelObliquity, iau: iauObliquity, diff: diffArcsec, jd });
    console.log(`║ ${year} │ ${modelObliquity.toFixed(6)}°  │ ${iauObliquity.toFixed(6)}° │ ${diffArcsec >= 0 ? '+' : ''}${diffArcsec.toFixed(2).padStart(5)}" ║`);
  }
  console.log('╚══════╧══════════════╧══════════════╧══════════╝');

  // Calculate rate from model
  const rateFirst = rateResults[0];
  const rateLast = rateResults[rateResults.length - 1];
  const modelChange = rateLast.model - rateFirst.model;
  const timeSpan = (rateLast.jd - rateFirst.jd) / 36525;
  const modelRate = (modelChange * 3600) / timeSpan;
  const avgDiff = rateResults.reduce((sum, r) => sum + Math.abs(r.diff), 0) / rateResults.length;

  console.log('');
  console.log(`Rate Analysis (${rateFirst.year}-${rateLast.year}):`);
  console.log(`  Model rate:      ${modelRate.toFixed(2)}"/century`);
  console.log(`  IAU 2006 rate:   ${IAU_RATE.toFixed(2)}"/century`);
  console.log(`  Rate error:      ${(modelRate - IAU_RATE).toFixed(2)}"/century`);
  console.log(`  Avg offset:      ${avgDiff.toFixed(2)}"`);
  console.log(`  Rate match:      ${Math.abs(modelRate - IAU_RATE) < 1 ? 'GOOD' : 'POOR'}`);
  console.log('');

  // Restore
  jumpToJulianDay(savedJD);
  o.Time = savedTime;
  forceSceneUpdate();
  o.Run = savedRun;

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('TEST COMPLETE - Model state restored');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  return { solsticeResults, netTilt, rateResults, modelRate, iauRate: IAU_RATE };
}

/** Find optimal parameter values for earthRAAngle, earthtiltMean, and earthInvPlaneInclinationAmplitude
 *
 * This function analyzes:
 * 1. Solstice timing errors across multiple years
 * 2. Obliquity accuracy vs IAU 2006
 * 3. Drift rate (change in error over time)
 *
 * And suggests optimal values for all three parameters.
 */
async function findOptimalEarthRAAngle() {
  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           FIND OPTIMAL PARAMETERS                                        ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log('');

  // ═══════════════════════════════════════════════════════════════════════════
  // TOLERANCE CONFIGURATION (High precision - research grade)
  // ═══════════════════════════════════════════════════════════════════════════
  const TOLERANCES = {
    geometry: 0.1,        // arcseconds - sun.dec must match obliquity at solstice
    timing: 5,            // minutes - solstice timing error
    sunRA: 75,            // arcseconds (= 5 seconds of time)
    obliquity: 0.05,      // arcseconds - obliquity vs IAU 2006
    obliquityRate: 0.1,   // arcseconds/century - obliquity rate vs IAU 2006
    inclination: 0.001,   // degrees - Earth inclination to invariable plane at J2000
  };

  // Derived values
  const sunRA_timeSec = TOLERANCES.sunRA / 15;  // 15" = 1 second of time

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // ═══════════════════════════════════════════════════════════════════════════
  // PART 1: Measure solstice errors across multiple years
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('PART 1: Solstice Timing Analysis');
  console.log('───────────────────────────────────────────────────────────────────────────');

  const testYears = [2000, 2005, 2010, 2015, 2020];
  const errors = {};
  let totalError = 0;

  for (const year of testYears) {
    if (JUNE_SOLSTICE_REFERENCE[year]) {
      const result = solsticeForYear(year);
      if (result) {
        const refJD = JUNE_SOLSTICE_REFERENCE[year].jd;
        const errorMin = (result.jd - refJD) * 24 * 60;
        errors[year] = errorMin;
        totalError += errorMin;
        console.log(`  ${year}: ${errorMin >= 0 ? '+' : ''}${errorMin.toFixed(1)} min`);
      }
    }
  }

  const avgError = totalError / testYears.length;
  const error2000 = errors[2000] || 0;
  const error2020 = errors[2020] || 0;
  const driftOver20Years = error2020 - error2000;
  const driftPerYear = driftOver20Years / 20;

  console.log('');
  console.log(`  Average error:     ${avgError >= 0 ? '+' : ''}${avgError.toFixed(1)} min`);
  console.log(`  Drift 2000→2020:   ${driftOver20Years >= 0 ? '+' : ''}${driftOver20Years.toFixed(1)} min (${driftPerYear.toFixed(2)} min/year)`);

  // ═══════════════════════════════════════════════════════════════════════════
  // PART 2: Obliquity analysis vs IAU 2006
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('');
  console.log('PART 2: Obliquity Analysis vs IAU 2006');
  console.log('───────────────────────────────────────────────────────────────────────────');

  // IAU 2006 reference values at MODEL EPOCH (June 21, 2000)
  // Adjusted from J2000 for the 171.5 day offset
  const IAU_obliquity_modelEpoch = ASTRO_REFERENCE.obliquityModelEpoch_deg;
  const IAU_rate_per_century = ASTRO_REFERENCE.obliquityRate_degPerCentury;

  // Get model obliquity at model epoch (June 21, 2000)
  jumpToJulianDay(startmodelJD);  // JD 2451716.5
  forceSceneUpdate();
  await new Promise(r => setTimeout(r, 50));
  const modelObliquityAtEpoch = o.obliquityEarth;

  // Get model obliquity at model epoch + 100 years to compute rate
  jumpToJulianDay(startmodelJD + 36525);  // June 21, 2100
  forceSceneUpdate();
  await new Promise(r => setTimeout(r, 50));
  const modelObliquityAtEpoch100 = o.obliquityEarth;

  const modelRatePerCentury = modelObliquityAtEpoch100 - modelObliquityAtEpoch;

  const obliquityErrorArcsec = (modelObliquityAtEpoch - IAU_obliquity_modelEpoch) * 3600;
  const rateErrorArcsec = (modelRatePerCentury - IAU_rate_per_century) * 3600;

  const obliquityNeedsFix = Math.abs(obliquityErrorArcsec) > TOLERANCES.obliquity;
  const obliquityRateNeedsFix = Math.abs(rateErrorArcsec) > TOLERANCES.obliquityRate;

  console.log(`  Reference epoch: Model start (June 21, 2000, JD ${startmodelJD})`);
  console.log(`  Model obliquity:   ${modelObliquityAtEpoch.toFixed(6)}° (IAU 2006: ${IAU_obliquity_modelEpoch.toFixed(6)}°)`);
  console.log(`  Obliquity error:   ${obliquityErrorArcsec >= 0 ? '+' : ''}${obliquityErrorArcsec.toFixed(2)}" ${obliquityNeedsFix ? '⚠️ NEEDS FIX' : '✓ OK'} (tolerance: ${TOLERANCES.obliquity}")`);
  console.log(`  Model rate:        ${(modelRatePerCentury * 3600).toFixed(2)}"/century (IAU: ${(IAU_rate_per_century * 3600).toFixed(2)}"/century)`);
  console.log(`  Rate error:        ${rateErrorArcsec >= 0 ? '+' : ''}${rateErrorArcsec.toFixed(2)}"/century ${obliquityRateNeedsFix ? '⚠️ NEEDS FIX' : '✓ OK'} (tolerance: ${TOLERANCES.obliquityRate}"/century)`);

  // ═══════════════════════════════════════════════════════════════════════════
  // PART 2.3: Earth's Inclination to Invariable Plane at Model Epoch
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('');
  console.log('PART 2.3: Earth Inclination to Invariable Plane');
  console.log('───────────────────────────────────────────────────────────────────────────');

  // Calculate model's inclination at model epoch (June 21, 2000) using the formula:
  // inclination = earthInvPlaneInclinationMean - earthInvPlaneInclinationAmplitude * cos(phase3)
  // Model epoch is at year 2000.469 (171.5 days after Jan 1)
  const modelEpochYear = 2000 + ASTRO_REFERENCE.modelEpochOffsetDays / 365.25;
  const inclT_modelEpoch = modelEpochYear - balancedYear;
  const inclCycle3 = holisticyearLength / 3;
  const inclPhase3_modelEpoch = (inclT_modelEpoch / inclCycle3) * 2 * Math.PI;
  const modelInclinationAtEpoch = earthInvPlaneInclinationMean - earthInvPlaneInclinationAmplitude * Math.cos(inclPhase3_modelEpoch);

  const IAU_inclination_modelEpoch = ASTRO_REFERENCE.earthInclinationModelEpoch_deg;
  const inclinationErrorDeg = modelInclinationAtEpoch - IAU_inclination_modelEpoch;
  const inclinationErrorArcsec = inclinationErrorDeg * 3600;
  const inclinationNeedsFix = Math.abs(inclinationErrorDeg) > TOLERANCES.inclination;

  console.log(`  Reference epoch: Model start (June 21, 2000, JD ${startmodelJD})`);
  console.log(`  Reference value: ${IAU_inclination_modelEpoch.toFixed(5)}° (adjusted from J2000: ${ASTRO_REFERENCE.earthInclinationJ2000_deg}°)`);
  console.log(`  Model value:     ${modelInclinationAtEpoch.toFixed(5)}°`);
  console.log(`  Error:           ${inclinationErrorDeg >= 0 ? '+' : ''}${inclinationErrorDeg.toFixed(5)}° (${inclinationErrorArcsec >= 0 ? '+' : ''}${inclinationErrorArcsec.toFixed(1)}") ${inclinationNeedsFix ? '⚠️ NEEDS FIX' : '✓ OK'}`);
  console.log('');
  console.log('  Current parameters:');
  console.log(`    earthInvPlaneInclinationMean      = ${earthInvPlaneInclinationMean}°`);
  console.log(`    earthInvPlaneInclinationAmplitude = ${earthInvPlaneInclinationAmplitude}° (fixed - from obliquity rate)`);
  console.log(`    cos(phase3 at model epoch)        = ${Math.cos(inclPhase3_modelEpoch).toFixed(6)}`);

  // Calculate what the mean should be to match reference at model epoch
  // Reference = Mean - Amplitude * cos(phase3)
  // Mean = Reference + Amplitude * cos(phase3)
  const optimalMeanInclination = IAU_inclination_modelEpoch + earthInvPlaneInclinationAmplitude * Math.cos(inclPhase3_modelEpoch);
  const meanAdjustment = optimalMeanInclination - earthInvPlaneInclinationMean;

  if (inclinationNeedsFix) {
    console.log('');
    console.log(`  ⚠️  To match reference at model epoch:`);
    console.log(`      Optimal earthInvPlaneInclinationMean = ${optimalMeanInclination.toFixed(6)}°`);
    console.log(`      Adjustment needed: ${meanAdjustment >= 0 ? '+' : ''}${meanAdjustment.toFixed(6)}°`);
  } else {
    console.log('');
    console.log('  ✓  Inclination matches reference within tolerance');
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // PART 2.5: Verify sun.dec matches obliquity at solstice (geometry check)
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('');
  console.log('PART 2.5: Geometry Verification (sun.dec vs obliquity at solstice)');
  console.log('───────────────────────────────────────────────────────────────────────────');

  // Find the year 2000 solstice and check sun.dec there
  const solstice2000Result = solsticeForYear(2000);
  let sunDecAtSolstice = null;
  let obliquityAtSolstice = null;
  let geometryError = null;
  let geometryErrorDeg = null;
  let geometryWarning = false;
  let earthRAAngle_geometrySensitivity = null;
  let earthRAAngle_geometryAdjustment = null;

  if (solstice2000Result) {
    jumpToJulianDay(solstice2000Result.jd);
    forceSceneUpdate();
    await new Promise(r => setTimeout(r, 50));

    // sun.dec is in radians, convert to degrees (90 - dec gives declination from equator)
    sunDecAtSolstice = sun.dec ? (90 - sun.dec * 180 / Math.PI) : null;
    obliquityAtSolstice = o.obliquityEarth;

    if (sunDecAtSolstice !== null && obliquityAtSolstice !== null) {
      geometryErrorDeg = sunDecAtSolstice - obliquityAtSolstice;
      geometryError = geometryErrorDeg * 3600;  // arcseconds

      console.log(`  At year 2000 solstice (JD ${solstice2000Result.jd.toFixed(4)}):`);
      console.log(`    sun.dec (max):       ${sunDecAtSolstice.toFixed(6)}°`);
      console.log(`    o.obliquityEarth:    ${obliquityAtSolstice.toFixed(6)}°`);
      console.log(`    Difference:          ${geometryError >= 0 ? '+' : ''}${geometryError.toFixed(2)}"`);

      // Measure earthRAAngle sensitivity by testing a small perturbation
      // We temporarily adjust the tilt and measure the effect on sun.dec
      const testDelta = 0.01;  // Test with 0.01° change
      const originalTilt = earthPerihelionPrecession1.orbitTilta;

      // Apply test perturbation
      earthPerihelionPrecession1.orbitTilta = originalTilt - testDelta;  // earthRAAngle is negated
      earthPerihelionPrecession1.containerObj.rotation.x = earthPerihelionPrecession1.orbitTilta * Math.PI / 180;
      forceSceneUpdate();
      await new Promise(r => setTimeout(r, 50));

      const sunDecPerturbed = sun.dec ? (90 - sun.dec * 180 / Math.PI) : null;

      // Restore original
      earthPerihelionPrecession1.orbitTilta = originalTilt;
      earthPerihelionPrecession1.containerObj.rotation.x = originalTilt * Math.PI / 180;
      forceSceneUpdate();
      await new Promise(r => setTimeout(r, 50));

      if (sunDecPerturbed !== null) {
        // Sensitivity: how much does sun.dec change per degree of earthRAAngle?
        const sunDecChange = sunDecPerturbed - sunDecAtSolstice;
        earthRAAngle_geometrySensitivity = sunDecChange / testDelta;  // degrees sun.dec per degree earthRAAngle

        console.log('');
        console.log('  Geometry sensitivity analysis:');
        console.log(`    earthRAAngle sensitivity: ${earthRAAngle_geometrySensitivity.toFixed(4)}° sun.dec per 1° earthRAAngle`);

        // If geometry error is significant, do an iterative search to find optimal earthRAAngle
        // The linear approximation can be very inaccurate due to non-linear sensitivity
        if (Math.abs(geometryError) > TOLERANCES.geometry) {
          console.log('');
          console.log('  Iterative search for optimal earthRAAngle:');

          // Search range: try values from current-0.2 to current+0.3 in steps of 0.01
          let bestRAAngle = earthRAAngle;
          let bestGeometryError = Math.abs(geometryError);
          const searchStart = earthRAAngle - 0.2;
          const searchEnd = earthRAAngle + 0.3;
          const searchStep = 0.02;

          for (let testRA = searchStart; testRA <= searchEnd; testRA += searchStep) {
            // Apply test value
            earthPerihelionPrecession1.orbitTilta = -testRA;
            earthPerihelionPrecession1.containerObj.rotation.x = earthPerihelionPrecession1.orbitTilta * Math.PI / 180;
            forceSceneUpdate();
            await new Promise(r => setTimeout(r, 30));

            // Find solstice with this value
            const testSolstice = solsticeForYear(2000);
            if (testSolstice) {
              jumpToJulianDay(testSolstice.jd);
              forceSceneUpdate();
              await new Promise(r => setTimeout(r, 30));

              const testSunDec = sun.dec ? (90 - sun.dec * 180 / Math.PI) : null;
              const testObliquity = o.obliquityEarth;

              if (testSunDec !== null && testObliquity !== null) {
                const testError = Math.abs(testSunDec - testObliquity) * 3600;
                if (testError < bestGeometryError) {
                  bestGeometryError = testError;
                  bestRAAngle = testRA;
                }
              }
            }
          }

          // Restore original
          earthPerihelionPrecession1.orbitTilta = -earthRAAngle;
          earthPerihelionPrecession1.containerObj.rotation.x = earthPerihelionPrecession1.orbitTilta * Math.PI / 180;
          forceSceneUpdate();
          await new Promise(r => setTimeout(r, 50));

          earthRAAngle_geometryAdjustment = bestRAAngle - earthRAAngle;
          console.log(`    Best earthRAAngle found: ${bestRAAngle.toFixed(6)}° (geometry error: ${bestGeometryError.toFixed(2)}")`);
          console.log(`    Adjustment needed: ${earthRAAngle_geometryAdjustment >= 0 ? '+' : ''}${earthRAAngle_geometryAdjustment.toFixed(6)}°`);
        } else {
          // Geometry is OK, use linear approximation for small adjustments
          if (Math.abs(earthRAAngle_geometrySensitivity) > 0.001) {
            earthRAAngle_geometryAdjustment = -geometryErrorDeg / earthRAAngle_geometrySensitivity;
          }
          if (earthRAAngle_geometryAdjustment !== null) {
            console.log(`    To fix geometry error: adjust earthRAAngle by ${earthRAAngle_geometryAdjustment >= 0 ? '+' : ''}${earthRAAngle_geometryAdjustment.toFixed(6)}°`);
            console.log(`    Suggested earthRAAngle for geometry: ${(earthRAAngle + earthRAAngle_geometryAdjustment).toFixed(6)}°`);
          }
        }
      }

      // Physical constraint: sun.dec should equal obliquity at solstice (within tolerance)
      if (Math.abs(geometryError) > TOLERANCES.geometry) {
        geometryWarning = true;
        console.log('');
        console.log(`  ⚠️  WARNING: sun.dec does not match obliquity at solstice (tolerance: ${TOLERANCES.geometry}")`);
        if (geometryError > 0) {
          console.log('      sun.dec EXCEEDS obliquity - this is physically impossible!');
        } else {
          console.log('      sun.dec is below obliquity at solstice moment.');
        }
        console.log('      This can be corrected by adjusting earthRAAngle (see above).');
      } else {
        console.log('');
        console.log(`  ✓  Geometry OK: sun.dec matches obliquity within ${TOLERANCES.geometry}"`);
      }
    }
  } else {
    console.log('  Could not detect year 2000 solstice for geometry check.');
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // PART 2.6: Verify Sun's RA at model start (21 June 2000 00:00 UTC)
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('');
  console.log('PART 2.6: Sun RA Verification at model start');
  console.log('───────────────────────────────────────────────────────────────────────────');

  // At June solstice, Sun's RA = exactly 6h 00m 00s (90°)
  // The 2000 solstice was at 01:47 UTC on June 21
  // At 00:00 UTC (1h 47m = 1.783h earlier), Sun's RA should be slightly less than 6h
  // Sun moves ~360° in 365.25 days = 0.9856°/day = 0.04107°/hour in ecliptic longitude
  // But RA near solstice moves faster due to obliquity - approximately 1°/day in RA = 4min RA / hour

  // Jump to model start: 21 June 2000 00:00 UTC
  // Julian Day convention: JD X.0 = noon UTC, JD X.5 = midnight UTC of previous day
  // So June 21, 2000 00:00 UTC = JD 2451716.5 - 0.5 = JD 2451716.0
  // But actually: JD 2451545.0 = Jan 1, 2000 12:00 TT
  // JD 2451716.5 is used as model start in the code (see line 28)
  // Let's use the actual model start JD from the constant
  const modelStartJD = startmodelJD;  // Use the actual model start JD (2451716.5)
  jumpToJulianDay(modelStartJD);
  forceSceneUpdate();
  await new Promise(r => setTimeout(r, 50));

  // Get Sun's RA at model start
  const sunRAatStart = sun.ra !== undefined ? (sun.ra * 180 / Math.PI + 360) % 360 : null;

  // Calculate expected RA based on astronomical reference solstice time
  // Reference solstice is 2000-06-21 01:47:51 UTC = JD 2451716.575
  // At solstice, Sun RA = exactly 90° (6h 00m 00s)
  const refSolsticeJD = JUNE_SOLSTICE_REFERENCE[2000]?.jd || 2451716.575;
  const hoursFromRefSolstice = (modelStartJD - refSolsticeJD) * 24;  // Negative = before solstice

  // Sun's RA motion: The Sun moves through 360° of RA in one tropical year
  // Near solstice, RA motion is approximately equal to ecliptic longitude motion
  // because the ecliptic is nearly parallel to the equator at this point
  // Average rate: 360° / 365.25 days = 0.9856°/day = 0.04107°/hour
  // But we should measure from the MODEL's solstice, not the reference
  // Since timing error is small, use reference + timing error as effective model solstice
  const modelSolsticeJD = refSolsticeJD + (error2000 / (24 * 60));  // Adjust by timing error
  const hoursFromModelSolstice = (modelStartJD - modelSolsticeJD) * 24;

  // RA motion rate: approximately 0.04107°/hour (average) but faster near solstice
  // Let's use the more accurate value based on tropical year
  const raMotionPerHour = 360 / (365.2422 * 24);  // ~0.04107°/hour
  const expectedRAoffset = hoursFromModelSolstice * raMotionPerHour;
  const expectedRA = 90 + expectedRAoffset;  // 90° at solstice, adjust by time offset

  // Convert to hours:minutes:seconds format
  const sunRAhours = sunRAatStart / 15;  // 15° per hour
  const sunRAh = Math.floor(sunRAhours);
  const sunRAm = Math.floor((sunRAhours - sunRAh) * 60);
  const sunRAs = ((sunRAhours - sunRAh) * 60 - sunRAm) * 60;

  const expectedRAhours = expectedRA / 15;
  const expectedRAh = Math.floor(expectedRAhours);
  const expectedRAm = Math.floor((expectedRAhours - expectedRAh) * 60);
  const expectedRAs = ((expectedRAhours - expectedRAh) * 60 - expectedRAm) * 60;

  // Calculate error in arcseconds of RA
  const raErrorDeg = sunRAatStart - expectedRA;
  const raErrorArcsec = raErrorDeg * 3600;
  const raErrorTimeSec = raErrorDeg * 240;  // 1° = 4 min = 240 sec of time

  // Convert JD to approximate time for display
  // JD 2451716.5 = June 21, 2000 12:00 UTC; JD 2451716.0 = June 21, 2000 00:00 UTC
  const jdFraction = modelStartJD - Math.floor(modelStartJD);
  const utcHour = ((jdFraction + 0.5) % 1) * 24;  // JD .5 = 00:00 UTC, JD .0 = 12:00 UTC
  const displayHour = Math.floor(utcHour);
  const displayMin = Math.floor((utcHour - displayHour) * 60);
  console.log(`  At model start (JD ${modelStartJD.toFixed(4)}, ~${displayHour.toString().padStart(2,'0')}:${displayMin.toString().padStart(2,'0')} UTC):`);
  console.log(`    Hours from model solstice: ${hoursFromModelSolstice >= 0 ? '+' : ''}${hoursFromModelSolstice.toFixed(2)}h (negative = before)`);
  console.log(`    Sun RA (model):    ${sunRAh}h ${sunRAm.toString().padStart(2,'0')}m ${sunRAs.toFixed(1).padStart(4,'0')}s (${sunRAatStart.toFixed(4)}°)`);
  console.log(`    Sun RA (expected): ${expectedRAh}h ${expectedRAm.toString().padStart(2,'0')}m ${expectedRAs.toFixed(1).padStart(4,'0')}s (${expectedRA.toFixed(4)}°)`);
  console.log(`    RA error:          ${raErrorArcsec >= 0 ? '+' : ''}${raErrorArcsec.toFixed(1)}" (${raErrorTimeSec >= 0 ? '+' : ''}${raErrorTimeSec.toFixed(1)}s of time)`);

  // Check if RA error is acceptable
  const raWarning = Math.abs(raErrorArcsec) > TOLERANCES.sunRA;
  // Calculate correctionSun adjustment needed to fix RA error
  // correctionSun directly shifts sun's position in degrees
  const correctionSunForRA = -raErrorDeg;

  if (raWarning) {
    console.log('');
    console.log(`  ⚠️  WARNING: Sun RA error exceeds ${TOLERANCES.sunRA}" (${sunRA_timeSec.toFixed(0)}s of time)`);
    console.log('      This indicates correctionSun may need adjustment.');
    console.log(`      Suggested correctionSun adjustment for RA: ${correctionSunForRA >= 0 ? '+' : ''}${correctionSunForRA.toFixed(6)}°`);
  } else {
    console.log('');
    console.log(`  ✓  Sun RA OK: within ${TOLERANCES.sunRA}" (${sunRA_timeSec.toFixed(0)}s) of expected value`);
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // PART 3: Calculate optimal parameter adjustments
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('');
  console.log('PART 3: Optimal Parameter Calculations');
  console.log('───────────────────────────────────────────────────────────────────────────');

  // Sensitivity constants (empirically derived)
  // earthRAAngle affects BOTH geometry (sun.dec) AND timing
  // correctionSun affects ONLY timing (Sun's orbital starting position)
  const earthRAAngle_minPerDeg = 3708;  // 1° earthRAAngle ≈ 3708 min shift in solstice
  const correctionSun_minPerDeg = 365.25 * 24 * 60 / 360;  // ~1461 min/degree (Sun moves 360° in one year)

  // For obliquity parameters, we use analytical relationships from the model formula:
  // obliquity = earthtiltMean - A*cos(phase3) + A*cos(phase8)
  //
  // At J2000:
  // - Changing earthtiltMean by Δ changes obliquity by Δ (direct 1:1)
  // - Changing amplitude affects both obliquity value AND rate

  // Phase values at J2000 (from balanced year)
  const t_J2000 = 2000 - balancedYear;
  const cycle3 = holisticyearLength / 3;
  const cycle8 = holisticyearLength / 8;
  const phase3 = (t_J2000 / cycle3) * 2 * Math.PI;
  const phase8 = (t_J2000 / cycle8) * 2 * Math.PI;

  const cos3 = Math.cos(phase3);
  const cos8 = Math.cos(phase8);
  const sin3 = Math.sin(phase3);
  const sin8 = Math.sin(phase8);

  // Obliquity sensitivity to amplitude: d(obliquity)/d(A) = -cos(phase3) + cos(phase8)
  const obliq_sens_to_amp = -cos3 + cos8;

  // Rate sensitivity to amplitude (per century):
  // rate = A*sin(phase3)*(2π/cycle3) - A*sin(phase8)*(2π/cycle8)  [per year]
  // rate per century = rate * 100
  // d(rate_century)/d(A) = [sin(phase3)*(2π/cycle3) - sin(phase8)*(2π/cycle8)] * 100
  const rate_sens_to_amp_per_century = (sin3 * (2 * Math.PI / cycle3) - sin8 * (2 * Math.PI / cycle8)) * 100;

  // Rate error in degrees per century
  const rateErrorDegPerCentury = modelRatePerCentury - IAU_rate_per_century;

  // Solve for optimal amplitude from rate constraint
  // Need: Δamp * rate_sens_to_amp_per_century = -rateError (to cancel error)
  let optimalAmpAdjustment = -rateErrorDegPerCentury / rate_sens_to_amp_per_century;

  // Sanity check: limit amplitude adjustment to reasonable range (±0.01°)
  // Current obliquity is already excellent, so we shouldn't need large changes
  const maxAmpAdjustment = 0.01;
  if (Math.abs(optimalAmpAdjustment) > maxAmpAdjustment) {
    console.log(`  WARNING: Amplitude adjustment ${optimalAmpAdjustment.toFixed(6)}° exceeds limit, clamping to ±${maxAmpAdjustment}°`);
    optimalAmpAdjustment = Math.sign(optimalAmpAdjustment) * maxAmpAdjustment;
  }

  // After amplitude adjustment, calculate remaining obliquity error
  const obliqAfterAmpAdj = modelObliquityAtEpoch + optimalAmpAdjustment * obliq_sens_to_amp;
  const remainingObliqError = obliqAfterAmpAdj - IAU_obliquity_modelEpoch;

  // Adjust earthtiltMean to fix remaining obliquity error
  let optimalMeanAdjustment = -remainingObliqError;

  // Sanity check: limit mean adjustment to reasonable range (±0.001°)
  const maxMeanAdjustment = 0.001;
  if (Math.abs(optimalMeanAdjustment) > maxMeanAdjustment) {
    console.log(`  WARNING: Mean adjustment ${optimalMeanAdjustment.toFixed(6)}° exceeds limit, clamping to ±${maxMeanAdjustment}°`);
    optimalMeanAdjustment = Math.sign(optimalMeanAdjustment) * maxMeanAdjustment;
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // Parameter roles:
  // - earthRAAngle: affects BOTH geometry (sun.dec) AND timing
  // - correctionSun: affects ONLY timing (Sun's orbital starting position)
  //
  // Strategy: First fix geometry with earthRAAngle, then fix timing with correctionSun
  // ═══════════════════════════════════════════════════════════════════════════

  const geometryAdjustment = earthRAAngle_geometryAdjustment || 0;

  // Calculate suggested earthRAAngle for geometry (this is the primary constraint)
  const suggestedRAAngle_forGeometry = earthRAAngle + geometryAdjustment;

  // Geometry tolerance in degrees
  const geometryTolerance = TOLERANCES.geometry / 3600;  // convert arcsec to degrees
  let geometryRangeMin = null;
  let geometryRangeMax = null;
  if (earthRAAngle_geometrySensitivity && Math.abs(earthRAAngle_geometrySensitivity) > 0.001) {
    geometryRangeMin = earthRAAngle + (geometryErrorDeg - geometryTolerance) / (-earthRAAngle_geometrySensitivity);
    geometryRangeMax = earthRAAngle + (geometryErrorDeg + geometryTolerance) / (-earthRAAngle_geometrySensitivity);
    if (geometryRangeMin > geometryRangeMax) {
      [geometryRangeMin, geometryRangeMax] = [geometryRangeMax, geometryRangeMin];
    }
  }

  // Check if geometry needs fixing (used in calculations below)
  const geometryNeedsFix = Math.abs(geometryError) > TOLERANCES.geometry;

  // Calculate suggested earthRAAngle considering BOTH geometry AND timing
  // Strategy:
  // - earthRAAngle must fix geometry (sun.dec = obliquity)
  // - But we also want timing to be reasonable so correctionSun doesn't need huge adjustment
  // - correctionSun has sensitivity ~1461 min/degree, max reasonable adjustment is ~0.5°
  // - So timing error after earthRAAngle fix should be within ±730 min (correctable by correctionSun ±0.5°)

  let suggestedRAAngle = suggestedRAAngle_forGeometry;
  let optimalRAAngleAdj = geometryAdjustment;

  // If geometry is already OK, keep current earthRAAngle
  if (!geometryNeedsFix) {
    suggestedRAAngle = earthRAAngle;
    optimalRAAngleAdj = 0;
  }

  // Calculate timing error AFTER applying suggested earthRAAngle
  let timingAfterGeometryFix = error2000 - (optimalRAAngleAdj * earthRAAngle_minPerDeg);

  // If timing after geometry fix is way off, we need to find a better balance
  // The geometry-based suggestion might not be accurate due to sensitivity measurement at wrong point
  // Try to find earthRAAngle that gives both good geometry AND reasonable timing
  const maxCorrectionSunAdjustment = 0.5;  // degrees
  const maxTimingCorrectable = maxCorrectionSunAdjustment * correctionSun_minPerDeg;  // ~730 min

  if (Math.abs(timingAfterGeometryFix) > maxTimingCorrectable && geometryNeedsFix) {
    // The geometry-only fix leads to timing that can't be corrected by correctionSun
    // This suggests the sensitivity measurement is inaccurate at this earthRAAngle value
    // Fall back to calculating earthRAAngle from timing, then verify geometry
    const timingBasedAdjustment = -error2000 / earthRAAngle_minPerDeg;
    const timingBasedRAAngle = earthRAAngle + timingBasedAdjustment;

    // Check if timing-based earthRAAngle is within geometry valid range
    if (geometryRangeMin !== null && geometryRangeMax !== null) {
      if (timingBasedRAAngle >= geometryRangeMin && timingBasedRAAngle <= geometryRangeMax) {
        // Timing-based value is within geometry tolerance - use it
        suggestedRAAngle = timingBasedRAAngle;
        optimalRAAngleAdj = timingBasedAdjustment;
        timingAfterGeometryFix = 0;
      } else {
        // Need a compromise - use edge of geometry range closest to timing-based value
        if (timingBasedRAAngle < geometryRangeMin) {
          suggestedRAAngle = geometryRangeMin;
        } else {
          suggestedRAAngle = geometryRangeMax;
        }
        optimalRAAngleAdj = suggestedRAAngle - earthRAAngle;
        timingAfterGeometryFix = error2000 - (optimalRAAngleAdj * earthRAAngle_minPerDeg);
      }
    }
  }

  // Determine what else needs to be fixed
  const timingNeedsFix = Math.abs(timingAfterGeometryFix) > TOLERANCES.timing;
  const raNeedsFix = Math.abs(raErrorArcsec) > TOLERANCES.sunRA;

  // Calculate correctionSun adjustment
  // Strategy:
  // - If earthRAAngle is being changed significantly, use TIMING-based correction
  //   (because RA error measured with wrong earthRAAngle is meaningless)
  // - Only use RA-based correction when geometry is already correct
  let correctionSunAdjustment;
  let correctionSunBasis;  // Track which method was used

  // If we're making a significant earthRAAngle adjustment, RA measurement is unreliable
  // Use timing-based correction instead
  const significantGeometryAdjustment = Math.abs(optimalRAAngleAdj) > 0.01;  // More than 0.01° change

  if (significantGeometryAdjustment) {
    // earthRAAngle is being adjusted significantly - use timing-based correctionSun
    // RA error is unreliable when orbital geometry is wrong
    if (Math.abs(timingAfterGeometryFix) > TOLERANCES.timing) {
      correctionSunAdjustment = -timingAfterGeometryFix / correctionSun_minPerDeg;
      correctionSunBasis = 'timing (geometry adjustment)';
    } else {
      correctionSunAdjustment = 0;
      correctionSunBasis = 'none (timing OK after geometry fix)';
    }
  } else if (timingNeedsFix) {
    // Geometry is OK, but timing needs fixing
    correctionSunAdjustment = -timingAfterGeometryFix / correctionSun_minPerDeg;
    correctionSunBasis = 'timing';
  } else if (raNeedsFix) {
    // Both geometry and timing are OK, but RA is off
    // Check if RA fix would break timing
    const timingImpactOfRAfix = Math.abs(correctionSunForRA * correctionSun_minPerDeg);
    if (timingImpactOfRAfix <= TOLERANCES.timing) {
      correctionSunAdjustment = correctionSunForRA;
      correctionSunBasis = 'RA';
    } else {
      // RA fix would break timing - skip it
      correctionSunAdjustment = 0;
      correctionSunBasis = 'none (RA fix would break timing)';
    }
  } else {
    // All are acceptable - no change needed
    correctionSunAdjustment = 0;
    correctionSunBasis = 'none';
  }
  const suggestedCorrectionSun = correctionSun + correctionSunAdjustment;

  // Calculate suggested values for obliquity parameters
  const suggestedAmplitude = earthInvPlaneInclinationAmplitude + optimalAmpAdjustment;
  const suggestedMean = earthtiltMean + optimalMeanAdjustment;

  console.log('');
  console.log('  Parameter sensitivities:');
  console.log(`    earthRAAngle: ${earthRAAngle_minPerDeg.toFixed(0)} min/degree (affects timing AND geometry)`);
  console.log(`    correctionSun: ${correctionSun_minPerDeg.toFixed(0)} min/degree (affects timing ONLY)`);
  if (earthRAAngle_geometrySensitivity) {
    console.log(`    earthRAAngle geometry: ${(earthRAAngle_geometrySensitivity * 3600).toFixed(2)}"/degree sun.dec`);
  }

  console.log('');
  console.log('  Current status:');
  console.log(`    Geometry error:     ${geometryError >= 0 ? '+' : ''}${geometryError.toFixed(2)}" ${geometryNeedsFix ? '⚠️ NEEDS FIX' : '✓ OK'} (tolerance: ${TOLERANCES.geometry}")`);
  console.log(`    Timing error:       ${error2000 >= 0 ? '+' : ''}${error2000.toFixed(1)} min ${Math.abs(error2000) > TOLERANCES.timing ? '⚠️ NEEDS FIX' : '✓ OK'} (tolerance: ${TOLERANCES.timing} min)`);
  console.log(`    Sun RA error:       ${raErrorArcsec >= 0 ? '+' : ''}${raErrorArcsec.toFixed(1)}" (${raErrorTimeSec >= 0 ? '+' : ''}${raErrorTimeSec.toFixed(1)}s) ${raNeedsFix ? '⚠️ NEEDS FIX' : '✓ OK'} (tolerance: ${TOLERANCES.sunRA}" = ${sunRA_timeSec.toFixed(0)}s)`);
  console.log(`    Obliquity error:    ${obliquityErrorArcsec >= 0 ? '+' : ''}${obliquityErrorArcsec.toFixed(2)}" ${obliquityNeedsFix ? '⚠️ NEEDS FIX' : '✓ OK'} (tolerance: ${TOLERANCES.obliquity}")`);
  console.log(`    Obliquity rate:     ${rateErrorArcsec >= 0 ? '+' : ''}${rateErrorArcsec.toFixed(2)}"/century ${obliquityRateNeedsFix ? '⚠️ NEEDS FIX' : '✓ OK'} (tolerance: ${TOLERANCES.obliquityRate}"/century)`);
  console.log(`    Inclination error:  ${inclinationErrorDeg >= 0 ? '+' : ''}${inclinationErrorDeg.toFixed(5)}° ${inclinationNeedsFix ? '⚠️ NEEDS FIX' : '✓ OK'} (tolerance: ${TOLERANCES.inclination}°)`);

  if (geometryRangeMin !== null) {
    console.log('');
    console.log(`  Valid earthRAAngle range for geometry (±${TOLERANCES.geometry}"):`);
    console.log(`    ${geometryRangeMin.toFixed(6)}° to ${geometryRangeMax.toFixed(6)}°`);
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // PART 4: Suggested values
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('SUGGESTED PARAMETER VALUES');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  // Show what needs to be fixed
  // Note: timingNeedsFix refers to timing AFTER geometry fix, not current timing
  const currentTimingNeedsFix = Math.abs(error2000) > TOLERANCES.timing;
  const allOK = !geometryNeedsFix && !currentTimingNeedsFix && !raNeedsFix && !obliquityNeedsFix && !obliquityRateNeedsFix && !inclinationNeedsFix;

  if (allOK) {
    console.log('');
    console.log('✓ All parameters are within acceptable tolerances. No changes needed.');
  } else {
    console.log('');
    if (geometryNeedsFix) {
      console.log(`⚠️  GEOMETRY needs correction (error > ${TOLERANCES.geometry}")`);
      if (timingNeedsFix) {
        console.log('    → This will also require TIMING correction via correctionSun');
      }
    }
    if (currentTimingNeedsFix && !geometryNeedsFix) {
      console.log(`⚠️  TIMING needs correction (error > ${TOLERANCES.timing} min)`);
    }
    if (raNeedsFix && !geometryNeedsFix) {
      console.log(`⚠️  SUN RA needs correction (error > ${TOLERANCES.sunRA}" = ${sunRA_timeSec.toFixed(0)}s)`);
    }
    if (obliquityNeedsFix) {
      console.log(`⚠️  OBLIQUITY needs correction (error > ${TOLERANCES.obliquity}")`);
      console.log('    → Adjust earthtiltMean parameter');
    }
    if (obliquityRateNeedsFix) {
      console.log(`⚠️  OBLIQUITY RATE needs correction (error > ${TOLERANCES.obliquityRate}"/century)`);
      console.log('    → Adjust earthInvPlaneInclinationAmplitude parameter');
    }
    if (inclinationNeedsFix) {
      console.log(`⚠️  INCLINATION needs correction (error > ${TOLERANCES.inclination}°)`);
      console.log('    → Adjust earthInvPlaneInclinationMean parameter');
      console.log(`    → Suggested: ${optimalMeanInclination.toFixed(6)}°`);
    }
  }

  // Calculate suggested inclination mean (always show optimal, even if within tolerance)
  const suggestedInclinationMean = optimalMeanInclination;

  console.log('');
  console.log('┌─────────────────────────────────────┬─────────────┬─────────────┬───────────┐');
  console.log('│ Parameter                           │ Current     │ Suggested   │ Change    │');
  console.log('├─────────────────────────────────────┼─────────────┼─────────────┼───────────┤');
  console.log(`│ earthRAAngle (geometry+timing)      │ ${earthRAAngle.toFixed(6)}°   │ ${suggestedRAAngle.toFixed(6)}°   │ ${optimalRAAngleAdj >= 0 ? '+' : ''}${optimalRAAngleAdj.toFixed(6)}° │`);
  console.log(`│ correctionSun (RA+timing)           │ ${correctionSun >= 0 ? '+' : ''}${correctionSun.toFixed(6)}° │ ${suggestedCorrectionSun >= 0 ? '+' : ''}${suggestedCorrectionSun.toFixed(6)}° │ ${correctionSunAdjustment >= 0 ? '+' : ''}${correctionSunAdjustment.toFixed(6)}° │`);
  console.log('├─────────────────────────────────────┼─────────────┼─────────────┼───────────┤');
  console.log(`│ earthInvPlaneInclinationAmplitude   │ ${earthInvPlaneInclinationAmplitude.toFixed(6)}°   │ ${suggestedAmplitude.toFixed(6)}°   │ ${optimalAmpAdjustment >= 0 ? '+' : ''}${optimalAmpAdjustment.toFixed(6)}° │`);
  console.log(`│ earthInvPlaneInclinationMean        │ ${earthInvPlaneInclinationMean.toFixed(6)}°   │ ${suggestedInclinationMean.toFixed(6)}°   │ ${meanAdjustment >= 0 ? '+' : ''}${meanAdjustment.toFixed(6)}° │`);
  console.log(`│ earthtiltMean                       │ ${earthtiltMean.toFixed(5)}°  │ ${suggestedMean.toFixed(5)}°  │ ${optimalMeanAdjustment >= 0 ? '+' : ''}${optimalMeanAdjustment.toFixed(6)}° │`);
  console.log('└─────────────────────────────────────┴─────────────┴─────────────┴───────────┘');

  console.log('');
  if (allOK) {
    console.log('Current values are optimal - no changes needed.');
  } else {
    console.log('Expected results after applying suggested values:');
    console.log(`  Correction basis: ${correctionSunBasis}`);
    console.log(`  • Geometry error: ${geometryError >= 0 ? '+' : ''}${geometryError.toFixed(2)}" → ~0" (sun.dec = obliquity)`);
    if (correctionSunBasis === 'RA') {
      console.log(`  • Sun RA error:   ${raErrorArcsec >= 0 ? '+' : ''}${raErrorArcsec.toFixed(1)}" → ~0"`);
    } else {
      console.log(`  • Sun RA error:   ${raErrorArcsec >= 0 ? '+' : ''}${raErrorArcsec.toFixed(1)}" (will improve with correct geometry)`);
    }
    // Expected timing after BOTH earthRAAngle change and correctionSun adjustment:
    // - earthRAAngle change: shifts timing by (optimalRAAngleAdj * earthRAAngle_minPerDeg)
    // - correctionSun change: shifts timing by (correctionSunAdjustment * correctionSun_minPerDeg)
    const timingShiftFromRAAngle = optimalRAAngleAdj * earthRAAngle_minPerDeg;
    const timingShiftFromCorrectionSun = correctionSunAdjustment * correctionSun_minPerDeg;
    const expectedTiming = error2000 - timingShiftFromRAAngle + timingShiftFromCorrectionSun;
    console.log(`  • Timing error:   ${error2000 >= 0 ? '+' : ''}${error2000.toFixed(1)} min → ~${expectedTiming.toFixed(1)} min`);
    console.log(`      (earthRAAngle: ${timingShiftFromRAAngle >= 0 ? '+' : ''}${timingShiftFromRAAngle.toFixed(1)} min, correctionSun: ${timingShiftFromCorrectionSun >= 0 ? '+' : ''}${timingShiftFromCorrectionSun.toFixed(1)} min)`);
    console.log(`  • Obliquity:      ${obliquityErrorArcsec >= 0 ? '+' : ''}${obliquityErrorArcsec.toFixed(2)}" → ~0"`);
    console.log(`  • Obliquity rate: ${rateErrorArcsec >= 0 ? '+' : ''}${rateErrorArcsec.toFixed(2)}"/century → ~0"/century`);
  }

  console.log('');
  console.log('HOW THE PARAMETERS WORK:');
  console.log('  • earthRAAngle: Controls geometry (sun.dec at solstice). Also affects timing.');
  console.log('  • correctionSun: Controls Sun RA position. Also affects timing.');
  console.log('  • Strategy: First set earthRAAngle for correct geometry,');
  console.log('              then adjust correctionSun to fix Sun RA (and timing).');

  console.log('');
  console.log('NOTE: Drift of ~' + driftPerYear.toFixed(1) + ' min/year is inherent to model year length');
  console.log('      (mean solar year vs tropical year difference of ~17 sec/year)');

  console.log('');
  console.log('To apply, edit these values in script.js and reload the page.');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return {
    current: {
      earthInvPlaneInclinationAmplitude,
      earthInvPlaneInclinationMean,
      earthtiltMean,
      earthRAAngle,
      correctionSun
    },
    suggested: {
      earthInvPlaneInclinationAmplitude: suggestedAmplitude,
      earthInvPlaneInclinationMean: suggestedInclinationMean,
      earthtiltMean: suggestedMean,
      earthRAAngle: suggestedRAAngle,
      correctionSun: suggestedCorrectionSun
    },
    errors: {
      solstice2000: error2000,
      avgSolstice: avgError,
      drift20Years: driftOver20Years,
      obliquityArcsec: obliquityErrorArcsec,
      rateArcsec: rateErrorArcsec,
      geometryArcsec: geometryError,
      geometryWarning: geometryWarning,
      raArcsec: raErrorArcsec,
      raWarning: raWarning,
      inclinationDeg: inclinationErrorDeg,
      inclinationNeedsFix: inclinationNeedsFix
    },
    sensitivities: {
      earthRAAngle_timing: earthRAAngle_minPerDeg,
      earthRAAngle_geometry: earthRAAngle_geometrySensitivity,
      correctionSun_timing: correctionSun_minPerDeg
    },
    ranges: {
      geometryRange: { min: geometryRangeMin, max: geometryRangeMax }
    },
    reference: {
      earthInclinationJ2000: ASTRO_REFERENCE.earthInclinationJ2000_deg
    }
  };
}

/**
 * Investigate how each parameter affects solstice drift independently.
 * Tests small variations of each parameter while keeping others constant.
 */
async function investigateParameterEffects() {
  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           PARAMETER SENSITIVITY INVESTIGATION                            ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log('');
  console.log('Testing how each parameter affects solstice timing and drift...');
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // Store original values
  const originalAmplitude = earthInvPlaneInclinationAmplitude;
  const originalMean = earthtiltMean;
  const originalRAAngle = earthRAAngle;

  // Helper function to measure solstice errors
  async function measureErrors() {
    const testYears = [2000, 2010, 2020];
    const errors = {};

    for (const year of testYears) {
      if (JUNE_SOLSTICE_REFERENCE[year]) {
        const result = solsticeForYear(year);
        if (result) {
          errors[year] = (result.jd - JUNE_SOLSTICE_REFERENCE[year].jd) * 24 * 60;
        }
      }
    }

    const drift = (errors[2020] || 0) - (errors[2000] || 0);
    return { errors, drift, error2000: errors[2000] || 0, error2010: errors[2010] || 0 };
  }

  // Get baseline
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('BASELINE (current values):');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`  earthInvPlaneInclinationAmplitude = ${originalAmplitude}°`);
  console.log(`  earthtiltMean = ${originalMean}°`);
  console.log(`  earthRAAngle = ${originalRAAngle}°`);

  const baseline = await measureErrors();
  console.log(`  Year 2000 error: ${baseline.error2000.toFixed(1)} min`);
  console.log(`  Year 2010 error: ${baseline.error2010.toFixed(1)} min`);
  console.log(`  Drift (2000→2020): ${baseline.drift.toFixed(1)} min`);
  console.log('');

  // Note: We can't actually change the const values at runtime, but we can
  // calculate what the theoretical effect would be based on the sensitivities
  // we've already measured.

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('THEORETICAL SENSITIVITY ANALYSIS:');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('');

  // earthRAAngle sensitivity (already known: 3708 min per degree)
  console.log('1. earthRAAngle:');
  console.log('   - Effect: Shifts ALL solstice times uniformly');
  console.log('   - Sensitivity: 1° ≈ 3708 min shift (61.8 hours)');
  console.log('   - Effect on drift: NONE (affects all years equally)');
  console.log('   - Use: Fine-tune epoch (year 2000) alignment');
  console.log('');

  // earthtiltMean sensitivity
  console.log('2. earthtiltMean:');
  console.log('   - Effect: Changes mean obliquity');
  console.log('   - Effect on solstice timing: Minimal direct effect');
  console.log('   - Effect on drift: Minimal');
  console.log('   - Use: Match IAU 2006 obliquity at J2000');
  console.log('');

  // earthInvPlaneInclinationAmplitude sensitivity
  console.log('3. earthInvPlaneInclinationAmplitude:');
  console.log('   - Effect: Changes obliquity oscillation range');
  console.log('   - Effect on obliquity rate: -82.70"/century per degree');
  console.log('   - Effect on solstice timing: Complex (affects when max dec occurs)');
  console.log('   - Effect on drift: POTENTIALLY affects drift rate');
  console.log('   - Use: Match IAU 2006 obliquity rate');
  console.log('');

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('DRIFT ANALYSIS:');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('');
  const modelYearLength = meansolaryearlengthinDays;
  const juneSolsticeTropicalYear = ASTRO_REFERENCE.tropicalYearSSJ2000;
  const yearLengthDiff = (modelYearLength - juneSolsticeTropicalYear) * 86400; // seconds
  const drift20yr = baseline.drift;
  console.log(`Current drift: ${(drift20yr).toFixed(1)} min over 20 years = ${(drift20yr/20).toFixed(3)} min/year = ${(drift20yr/20*60).toFixed(1)} sec/year`);
  console.log('');
  console.log('Possible causes:');
  console.log(`  1. Model uses mean solar year (${modelYearLength.toFixed(6)} days)`);
  console.log(`  2. June solstice tropical year is ~${juneSolsticeTropicalYear} days (shorter!)`);
  console.log(`  3. Difference: ~${yearLengthDiff.toFixed(0)} sec/year → explains most of the drift`);
  console.log('');
  console.log('The drift is primarily a year-length issue, not a parameter tuning issue.');
  console.log('');

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('OPTIMIZATION STRATEGIES (relative to test range 2000-2020):');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('');
  const driftPerYearSec = (drift20yr / 20) * 60; // convert min/year to sec/year
  console.log('NOTE: These strategies only shift WHERE the error is zero within the test');
  console.log(`      range. They do NOT eliminate the inherent drift (~${driftPerYearSec.toFixed(0)} sec/year).`);
  console.log('');
  console.log('Strategy A: Optimize for Year 2000 (current) ← RECOMMENDED');
  console.log('  - earthRAAngle tuned for J2000 epoch (astronomical standard reference)');
  console.log('  - Result: 2000 ≈ 0 min, 2010 ≈ +7 min, 2020 ≈ +15 min');
  console.log('  - Best accuracy at the reference epoch where obliquity is calibrated');
  console.log('');
  console.log('Strategy B: Optimize for middle of test range (2010)');
  const shift2010 = baseline.error2010 / 3708;  // degrees needed to zero out 2010
  console.log(`  - Increase earthRAAngle by ${shift2010.toFixed(6)}° to center on 2010`);
  console.log(`  - Suggested earthRAAngle: ${(originalRAAngle + shift2010).toFixed(6)}°`);
  console.log('  - Result: 2000 ≈ -7 min, 2010 ≈ 0 min, 2020 ≈ +7 min');
  console.log('  - Minimizes max error within test range, but 2010 is not special astronomically');
  console.log('');
  console.log('Strategy C: Optimize for minimum RMS error over test range');
  const avgError = (baseline.error2000 + baseline.error2010 + (baseline.errors[2020] || 0)) / 3;
  const shiftRMS = avgError / 3708;
  console.log(`  - Increase earthRAAngle by ${shiftRMS.toFixed(6)}° to minimize average error`);
  console.log(`  - Suggested earthRAAngle: ${(originalRAAngle + shiftRMS).toFixed(6)}°`);
  console.log('');

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('RECOMMENDATION:');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('');
  console.log(`The ~${driftPerYearSec.toFixed(0)} sec/year drift cannot be eliminated by parameter tuning alone.`);
  console.log('It stems from the model\'s year length vs June solstice tropical year.');
  console.log('');
  console.log('Keep Strategy A (optimize for J2000) because:');
  console.log('  - J2000 is the standard astronomical epoch');
  console.log('  - Obliquity is calibrated to IAU 2006 at J2000');
  console.log('  - Scientifically meaningful to have best accuracy at reference epoch');
  console.log(`  - Current earthRAAngle = ${originalRAAngle.toFixed(6)}°`);
  console.log('');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return {
    baseline,
    strategies: {
      A: { earthRAAngle: originalRAAngle, description: 'Optimize for 2000' },
      B: { earthRAAngle: originalRAAngle + shift2010, description: 'Optimize for 2010 (centered)' },
      C: { earthRAAngle: originalRAAngle + shiftRMS, description: 'Minimize RMS error' }
    }
  };
}

/** Verify obliquity rate against IAU 2006 */
async function verifyObliquityRate() {
  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           OBLIQUITY RATE VERIFICATION                                    ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log('');
  console.log('Comparing model obliquity to IAU 2006 reference...');
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // IAU 2006 reference (from ASTRO_REFERENCE)
  const IAU_OBLIQUITY_J2000 = ASTRO_REFERENCE.obliquityJ2000_deg;
  const IAU_RATE = ASTRO_REFERENCE.obliquityRate_arcsecPerCentury;
  const IAU_RATE_DEG = ASTRO_REFERENCE.obliquityRate_degPerCentury;

  // J2000.0 = JD 2451545.0 (2000-01-01 12:00 TT)
  const JD_J2000 = 2451545.0;

  const years = [1990, 1995, 2000, 2005, 2010, 2015, 2020, 2025];
  const results = [];

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('Year      Model (°)      IAU 2006 (°)    Diff (")    Rate Error ("/cen)');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  for (const year of years) {
    // Jump to Jan 1 of each year at noon
    const jd = dateToJulianDay(year, 1, 1) + 0.5;
    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Get model obliquity
    const modelObliquity = o.obliquityEarth;

    // Calculate IAU 2006 expected obliquity
    const centuriesFromJ2000 = (jd - JD_J2000) / 36525;
    const iauObliquity = IAU_OBLIQUITY_J2000 + IAU_RATE_DEG * centuriesFromJ2000;

    // Difference in arcseconds
    const diffArcsec = (modelObliquity - iauObliquity) * 3600;

    results.push({
      year,
      jd,
      model: modelObliquity,
      iau: iauObliquity,
      diff: diffArcsec,
      centuries: centuriesFromJ2000
    });

    console.log(`${year}      ${modelObliquity.toFixed(6)}°      ${iauObliquity.toFixed(6)}°     ${diffArcsec >= 0 ? '+' : ''}${diffArcsec.toFixed(2)}"      -`);
  }

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('');

  // Calculate rate from model
  const first = results[0];
  const last = results[results.length - 1];
  const modelChange = last.model - first.model;  // degrees
  const timeSpan = (last.jd - first.jd) / 36525;  // centuries
  const modelRate = (modelChange * 3600) / timeSpan;  // arcsec/century

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('RATE ANALYSIS (1990-2025):');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`  Model change:    ${(modelChange * 3600).toFixed(2)}" over ${(timeSpan * 100).toFixed(1)} years`);
  console.log(`  Model rate:      ${modelRate.toFixed(2)}"/century`);
  console.log(`  IAU 2006 rate:   ${IAU_RATE.toFixed(2)}"/century`);
  console.log(`  Rate error:      ${(modelRate - IAU_RATE).toFixed(2)}"/century`);
  console.log('');

  // Summary
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('SUMMARY:');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  const avgDiff = results.reduce((sum, r) => sum + Math.abs(r.diff), 0) / results.length;
  const maxDiff = Math.max(...results.map(r => Math.abs(r.diff)));
  console.log(`  Average offset:  ${avgDiff.toFixed(2)}"`);
  console.log(`  Max offset:      ${maxDiff.toFixed(2)}"`);
  console.log(`  Rate match:      ${Math.abs(modelRate - IAU_RATE) < 1 ? 'GOOD' : 'POOR'} (${Math.abs(modelRate - IAU_RATE).toFixed(2)}"/cen error)`);
  console.log('');

  console.log('Current parameters:');
  console.log(`  earthtiltMean = ${earthtiltMean}°`);
  console.log(`  earthInvPlaneInclinationAmplitude = ${earthInvPlaneInclinationAmplitude}°`);
  console.log('');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return { results, modelRate, iauRate: IAU_RATE, rateError: modelRate - IAU_RATE };
}

/**
 * Verify perihelion longitude and eccentricity against J2000.0 reference values.
 *
 * CALIBRATION NOTES:
 * Both eccentricityMean and eccentricityAmplitude affect both RA and Eccentricity,
 * but with different sensitivities:
 *
 * - eccentricityMean: Primarily affects Eccentricity. Increasing it increases Eccentricity.
 * - eccentricityAmplitude: Primarily affects RA, with secondary effect on Eccentricity.
 *   The relationship is NON-LINEAR and very sensitive:
 *   - Amplitude 0.003020 → RA ≈ -0.003° (too low)
 *   - Amplitude 0.003015 → RA ≈ +0.0007° (close)
 *   - Amplitude 0.0030159 → RA ≈ +0.00004° (within tolerance)
 *   - Amplitude 0.003010 → RA ≈ +0.004° (too high)
 *
 * CALIBRATION STRATEGY:
 * 1. First adjust eccentricityAmplitude to get RA within tolerance (use bisection)
 * 2. Then fine-tune eccentricityMean to get Eccentricity within tolerance
 * 3. Iterate if needed since both parameters have cross-effects
 */
async function verifyPerihelionRate() {
  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           PERIHELION RATE VERIFICATION                                   ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log('');
  console.log('Comparing model perihelion values to J2000.0 reference...');
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // Reference values from ASTRO_REFERENCE
  const REF_PERIHELION_LONG = ASTRO_REFERENCE.perihelionLongitudeJ2000_deg;
  const REF_ECCENTRICITY = ASTRO_REFERENCE.eccentricityJ2000;

  // J2000.0 = JD 2451545.0 (2000-01-01 12:00 TT)
  const JD_J2000 = 2451545.0;

  // Jump to J2000.0
  jumpToJulianDay(JD_J2000);
  forceSceneUpdate();
  await new Promise(r => setTimeout(r, 200));

  // Force another update to ensure positions are fully calculated
  updatePositions();
  await new Promise(r => setTimeout(r, 100));

  // Get model values for perihelion-of-earth (same source as celestial positions panel)
  const modelPerihelionRA = (earthPerihelionFromEarth.ra * 180 / Math.PI + 360) % 360;
  const modelEccentricity = earthPerihelionFromEarth.distAU;

  const raError = modelPerihelionRA - REF_PERIHELION_LONG;
  const eccError = modelEccentricity - REF_ECCENTRICITY;

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('J2000.0 COMPARISON (Jan 1, 2000 12:00 TT):');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('');
  console.log('  PERIHELION LONGITUDE (RA):');
  console.log(`    Model value:     ${modelPerihelionRA.toFixed(6)}°`);
  console.log(`    Reference:       ${REF_PERIHELION_LONG.toFixed(6)}°`);
  console.log(`    Difference:      ${raError >= 0 ? '+' : ''}${raError.toFixed(6)}°`);
  console.log('');
  console.log('  ECCENTRICITY (Distance to Earth):');
  console.log(`    Model value:     ${modelEccentricity.toFixed(8)} AU`);
  console.log(`    Reference:       ${REF_ECCENTRICITY.toFixed(8)} AU`);
  console.log(`    Difference:      ${eccError >= 0 ? '+' : ''}${eccError.toFixed(8)} AU`);
  console.log('');

  // Check match status
  const raMatch = Math.abs(raError) < 0.001;        // ±0.001° = ±3.6 arcsec
  const eccMatch = Math.abs(eccError) < 0.000001;   // ±0.000001 AU = ±150 meters

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('VERIFICATION RESULT:');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`  Perihelion RA:     ${raMatch ? '✓ PASS' : '✗ FAIL'} (tolerance: ±0.001°)`);
  console.log(`  Eccentricity:      ${eccMatch ? '✓ PASS' : '✗ FAIL'} (tolerance: ±0.000001 AU)`);
  console.log('');

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('CURRENT INPUT PARAMETERS:');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`  eccentricityMean      = ${eccentricityMean}`);
  console.log(`  eccentricityAmplitude = ${eccentricityAmplitude}`);
  console.log('');

  // Calculate recommended values for exact eccentricity match
  const recommendedEccMean = eccentricityMean - eccError;
  const recommendedEccAmplitude = eccentricityAmplitude - eccError;

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('CALIBRATION GUIDANCE:');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('');
  console.log('  CALIBRATION STRATEGY:');
  console.log('    1. First fix RA by adjusting eccentricityMean (use very small steps)');
  console.log('    2. Then fix eccentricity by adjusting eccentricityAmplitude');
  console.log('    3. If RA drifts out of tolerance, go back to step 1');
  console.log('');
  console.log('  To fix RA (adjust eccentricityMean):');
  if (raError > 0) {
    console.log(`    RA is too HIGH by ${raError.toFixed(6)}° → DECREASE mean`);
  } else if (raError < 0) {
    console.log(`    RA is too LOW by ${Math.abs(raError).toFixed(6)}° → INCREASE mean`);
  } else {
    console.log('    RA is exactly on target!');
  }
  console.log(`    Current: eccentricityMean = ${eccentricityMean}`);
  console.log('');
  console.log('  To fix ECCENTRICITY (adjust eccentricityAmplitude):');
  console.log(`    Eccentricity error: ${eccError >= 0 ? '+' : ''}${eccError.toFixed(8)} AU`);
  console.log(`    Current: eccentricityAmplitude = ${eccentricityAmplitude}`);
  console.log('');
  console.log('  NOTE: Both parameters affect both outputs. Use very small incremental');
  console.log('  adjustments and iterate until both are within tolerance.');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return {
    modelRA: modelPerihelionRA,
    refRA: REF_PERIHELION_LONG,
    raError: raError,
    modelEcc: modelEccentricity,
    refEcc: REF_ECCENTRICITY,
    eccError: eccError,
    raPass: raMatch,
    eccPass: eccMatch
  };
}

/** Analyze tropical year length from solstice intervals */
async function analyzeTropicalYearLength(startYear, endYear) {
  startYear = startYear || o.calibrationYearStart;
  endYear = endYear || o.calibrationYearEnd;

  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║         JUNE SOLSTICE YEAR LENGTH ANALYSIS (Sun RA = 90°)              ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing years ${startYear} to ${endYear}...`);
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  const solstices = [];
  let prevSolsticeJD = null;
  for (let year = startYear; year <= endYear; year++) {
    const result = solsticeForYear(year, prevSolsticeJD);  // Chain from previous
    if (result) {
      solstices.push({ year, jd: result.jd });
      prevSolsticeJD = result.jd;
    }
    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  const intervals = [];
  for (let i = 1; i < solstices.length; i++) {
    intervals.push({
      year: solstices[i].year,
      interval: solstices[i].jd - solstices[i - 1].jd
    });
  }

  const mean = intervals.reduce((sum, i) => sum + i.interval, 0) / intervals.length;
  const iauSummerSolstice = ASTRO_REFERENCE.tropicalYearSSJ2000;

  console.log('╔═══════════════════════════════════╤═══════════════════╗');
  console.log('║ Metric                            │ Value (days)      ║');
  console.log('╠═══════════════════════════════════╪═══════════════════╣');
  console.log(`║ Model configured                  │ ${meansolaryearlengthinDays.toFixed(9)}    ║`);
  console.log(`║ Mean measured interval            │ ${mean.toFixed(9)}    ║`);
  console.log(`║ IAU Summer Solstice year          │ ${iauSummerSolstice.toFixed(9)}    ║`);
  console.log(`║ Diff (measured - configured)      │ ${((mean - meansolaryearlengthinDays) * 86400).toFixed(2)} seconds   ║`);
  console.log(`║ Diff (measured - IAU)             │ ${((mean - iauSummerSolstice) * 86400).toFixed(2)} seconds   ║`);
  console.log('╚═══════════════════════════════════╧═══════════════════╝');

  if (intervals.length > 10) {
    const firstFive = intervals.slice(0, 5);
    const lastFive = intervals.slice(-5);
    const firstMean = firstFive.reduce((s, i) => s + i.interval, 0) / 5;
    const lastMean = lastFive.reduce((s, i) => s + i.interval, 0) / 5;
    const yearSpan = lastFive[4].year - firstFive[0].year;
    const drift = (lastMean - firstMean) / yearSpan * 86400;
    console.log(`\nTrend over ${yearSpan} years: ${drift.toFixed(3)} sec/year change in tropical year`);
  }

  jumpToJulianDay(savedJD);
  o.Run = savedRun;
  return { solstices, intervals, mean };
}

/** Analyze tropical year length from December solstice intervals (sun.ra = 270°) */
async function analyzeDecemberSolsticeYearLength(startYear, endYear) {
  startYear = startYear || o.calibrationYearStart;
  endYear = endYear || o.calibrationYearEnd;

  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║       DECEMBER SOLSTICE YEAR LENGTH ANALYSIS (Sun RA = 270°)            ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing years ${startYear} to ${endYear}...`);
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  const solstices = [];
  let prevJD = null;

  for (let year = startYear; year <= endYear; year++) {
    const result = sunRACrossingForYear(year, 270, prevJD);
    if (result) {
      solstices.push({ year, jd: result.jd });
      prevJD = result.jd;
    }
    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  const intervals = [];
  for (let i = 1; i < solstices.length; i++) {
    intervals.push({
      year: solstices[i].year,
      interval: solstices[i].jd - solstices[i - 1].jd
    });
  }

  const mean = intervals.reduce((sum, i) => sum + i.interval, 0) / intervals.length;
  const iauWinterSolstice = ASTRO_REFERENCE.tropicalYearWSJ2000;

  console.log('╔═══════════════════════════════════╤═══════════════════╗');
  console.log('║ Metric                            │ Value (days)      ║');
  console.log('╠═══════════════════════════════════╪═══════════════════╣');
  console.log(`║ Model configured                  │ ${meansolaryearlengthinDays.toFixed(9)}    ║`);
  console.log(`║ Mean measured interval            │ ${mean.toFixed(9)}    ║`);
  console.log(`║ IAU Winter Solstice year          │ ${iauWinterSolstice.toFixed(9)}    ║`);
  console.log(`║ Diff (measured - configured)      │ ${((mean - meansolaryearlengthinDays) * 86400).toFixed(2)} seconds   ║`);
  console.log(`║ Diff (measured - IAU)             │ ${((mean - iauWinterSolstice) * 86400).toFixed(2)} seconds   ║`);
  console.log('╚═══════════════════════════════════╧═══════════════════╝');

  if (intervals.length > 10) {
    const firstFive = intervals.slice(0, 5);
    const lastFive = intervals.slice(-5);
    const firstMean = firstFive.reduce((s, i) => s + i.interval, 0) / 5;
    const lastMean = lastFive.reduce((s, i) => s + i.interval, 0) / 5;
    const yearSpan = lastFive[4].year - firstFive[0].year;
    const drift = (lastMean - firstMean) / yearSpan * 86400;
    console.log(`\nTrend over ${yearSpan} years: ${drift.toFixed(3)} sec/year change in tropical year`);
  }

  jumpToJulianDay(savedJD);
  o.Run = savedRun;
  return { solstices, intervals, mean };
}

/**
 * Analyze tropical year length from all 4 cardinal points (sun.ra = 0°, 90°, 180°, 270°)
 * Uses both Method A (Earth-based RA) and Method B (Wobble-center RA) for comparison.
 *
 * KNOWN LIMITATION: This model uses a circular orbit with an offset center to simulate
 * eccentricity. The Sun moves at constant angular velocity around Earth. In reality
 * (and in IAU calculations), the orbit is elliptical and Kepler's 2nd Law causes
 * variable orbital velocity - faster at perihelion, slower at aphelion.
 *
 * This results in ~±26s deviation at solstices compared to IAU reference values:
 * - Summer Solstice (near aphelion): Model shows ~+26s longer than IAU
 * - Winter Solstice (near perihelion): Model shows ~-25s shorter than IAU
 *
 * The model correctly simulates mean tropical year, distance variations, and all
 * precession cycles, but cannot replicate the ~96s spread in tropical year lengths
 * at different cardinal points caused by Kepler's 2nd Law velocity variations.
 */
async function analyzeEquinoxIntervals(startYear, endYear) {
  startYear = startYear || o.calibrationYearStart;
  endYear = endYear || o.calibrationYearEnd;

  console.log('╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗');
  console.log('║                              CARDINAL POINTS ANALYSIS (Sun RA = 0°, 90°, 180°, 270°)                                                  ║');
  console.log('╠══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ Method A: Earth-based RA (sun.ra) - includes wobble parallax                                                                            ║');
  console.log('║ Method B: Wobble-center RA (calculateRAFromWobbleCenter) - stable reference frame                                                       ║');
  console.log('║ Method C: Perihelion-point RA (calculateRAFromEarthPerihelion) - perihelion as origin                                                   ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing years ${startYear} to ${endYear}...`);
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  const cardinalPoints = [
    { ra: 0, name: 'RA=0° (Vernal Equinox)', shortName: 'VE', iauRef: ASTRO_REFERENCE.tropicalYearVEJ2000 },
    { ra: 90, name: 'RA=90° (Summer Solstice)', shortName: 'SS', iauRef: ASTRO_REFERENCE.tropicalYearSSJ2000 },
    { ra: 180, name: 'RA=180° (Autumnal Equinox)', shortName: 'AE', iauRef: ASTRO_REFERENCE.tropicalYearAEJ2000 },
    { ra: 270, name: 'RA=270° (Winter Solstice)', shortName: 'WS', iauRef: ASTRO_REFERENCE.tropicalYearWSJ2000 }
  ];

  const resultsA = {};  // Method A: Earth-based
  const resultsB = {};  // Method B: Wobble-center
  const resultsC = {};  // Method C: Perihelion-point

  for (const point of cardinalPoints) {
    // Method A: Earth-based RA
    const eventsA = [];
    let prevJDA = null;

    for (let year = startYear; year <= endYear; year++) {
      const result = sunRACrossingForYear(year, point.ra, prevJDA, false);
      if (result) {
        eventsA.push({ year, jd: result.jd, raDeg: result.raDeg });
        prevJDA = result.jd;
      }
      if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
    }

    const intervalsA = [];
    for (let i = 1; i < eventsA.length; i++) {
      intervalsA.push(eventsA[i].jd - eventsA[i - 1].jd);
    }
    const meanA = intervalsA.length > 0 ? intervalsA.reduce((sum, i) => sum + i, 0) / intervalsA.length : 0;
    resultsA[point.ra] = { events: eventsA, intervals: intervalsA, mean: meanA, name: point.name, shortName: point.shortName, iauRef: point.iauRef };

    // Method B: Wobble-center RA
    const eventsB = [];
    let prevJDB = null;

    for (let year = startYear; year <= endYear; year++) {
      const result = sunRACrossingForYearMethodB(year, point.ra, prevJDB, false);
      if (result) {
        eventsB.push({ year, jd: result.jd, raDeg: result.raDeg });
        prevJDB = result.jd;
      }
      if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
    }

    const intervalsB = [];
    for (let i = 1; i < eventsB.length; i++) {
      intervalsB.push(eventsB[i].jd - eventsB[i - 1].jd);
    }
    const meanB = intervalsB.length > 0 ? intervalsB.reduce((sum, i) => sum + i, 0) / intervalsB.length : 0;
    resultsB[point.ra] = { events: eventsB, intervals: intervalsB, mean: meanB, name: point.name, shortName: point.shortName, iauRef: point.iauRef };

    // Method C: Perihelion-point RA
    const eventsC = [];
    let prevJDC = null;

    for (let year = startYear; year <= endYear; year++) {
      const result = sunRACrossingForYearMethodC(year, point.ra, prevJDC, false);
      if (result) {
        eventsC.push({ year, jd: result.jd, raDeg: result.raDeg });
        prevJDC = result.jd;
      }
      if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
    }

    const intervalsC = [];
    for (let i = 1; i < eventsC.length; i++) {
      intervalsC.push(eventsC[i].jd - eventsC[i - 1].jd);
    }
    const meanC = intervalsC.length > 0 ? intervalsC.reduce((sum, i) => sum + i, 0) / intervalsC.length : 0;
    resultsC[point.ra] = { events: eventsC, intervals: intervalsC, mean: meanC, name: point.name, shortName: point.shortName, iauRef: point.iauRef };
  }

  // Display results
  console.log('');
  console.log('╔═════════════════════════════════════╤═══════════════════╤═══════════════════╤═══════════════════╤═══════════════════╤═══════════════════╗');
  console.log('║ Cardinal Point                      │ Method A (days)   │ Method B (days)   │ Method C (days)   │ IAU Reference     │ A - IAU (s)       ║');
  console.log('╠═════════════════════════════════════╪═══════════════════╪═══════════════════╪═══════════════════╪═══════════════════╪═══════════════════╣');

  for (const point of cardinalPoints) {
    const rA = resultsA[point.ra];
    const rB = resultsB[point.ra];
    const rC = resultsC[point.ra];
    const diffSecA = (rA.mean - point.iauRef) * 86400;
    const meanAStr = rA.mean > 0 ? rA.mean.toFixed(9) : 'N/A';
    const meanBStr = rB.mean > 0 ? rB.mean.toFixed(9) : 'N/A';
    const meanCStr = rC.mean > 0 ? rC.mean.toFixed(9) : 'N/A';
    const iauStr = point.iauRef.toFixed(9);
    const diffAStr = rA.mean > 0 ? diffSecA.toFixed(2).padStart(8) : 'N/A';
    console.log(`║ ${point.name.padEnd(35)} │ ${meanAStr.padStart(17)} │ ${meanBStr.padStart(17)} │ ${meanCStr.padStart(17)} │ ${iauStr.padStart(17)} │ ${diffAStr.padStart(17)} ║`);
  }

  // Calculate mean of Method A (average of 4 cardinal points)
  const meanA = (resultsA[0].mean + resultsA[90].mean + resultsA[180].mean + resultsA[270].mean) / 4;
  const meanADiff = (meanA - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400;

  console.log('╠═════════════════════════════════════╪═══════════════════╪═══════════════════╪═══════════════════╪═══════════════════╪═══════════════════╣');
  console.log(`║ IAU mean tropical year              │                   │                   │                   │ ${ASTRO_REFERENCE.tropicalYearMeanJ2000.toFixed(9).padStart(17)} │                   ║`);
  console.log(`║ Model configured                    │                   │ ${meansolaryearlengthinDays.toFixed(9).padStart(17)} │                   │                   │                   ║`);
  console.log(`║ Method A mean (4 cardinals)         │ ${meanA.toFixed(9).padStart(17)} │                   │                   │                   │ ${meanADiff.toFixed(2).padStart(8)}          ║`);
  console.log('╚═════════════════════════════════════╧═══════════════════╧═══════════════════╧═══════════════════╧═══════════════════╧═══════════════════╝');

  // Show difference between methods
  console.log('');
  console.log('════════════════════════════════════════════════════════════════════════════════════════════════');
  console.log('METHOD COMPARISON (difference in seconds):');
  console.log('────────────────────────────────────────────────────────────────────────────────────────────────');
  console.log('         A - B (wobble)       B - C (perihelion)     A - C (total)');
  console.log('────────────────────────────────────────────────────────────────────────────────────────────────');
  for (const point of cardinalPoints) {
    const rA = resultsA[point.ra];
    const rB = resultsB[point.ra];
    const rC = resultsC[point.ra];
    const diffAB = (rA.mean - rB.mean) * 86400;
    const diffBC = (rB.mean - rC.mean) * 86400;
    const diffAC = (rA.mean - rC.mean) * 86400;
    console.log(`  ${point.shortName}:    ${diffAB >= 0 ? '+' : ''}${diffAB.toFixed(3).padStart(8)}s          ${diffBC >= 0 ? '+' : ''}${diffBC.toFixed(3).padStart(8)}s          ${diffAC >= 0 ? '+' : ''}${diffAC.toFixed(3).padStart(8)}s`);
  }
  console.log('────────────────────────────────────────────────────────────────────────────────────────────────');
  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════════════════════════');
  console.log('METHOD COMPARISON EXPLANATION:');
  console.log('───────────────────────────────────────────────────────────────────────────────────────────────');
  console.log('');
  console.log('A - B (wobble parallax): ~0s difference');
  console.log('  The wobble parallax from Earth\'s axial precession is negligible for tropical year');
  console.log('  measurements. Methods A and B produce essentially identical results.');
  console.log('');
  console.log('B - C (perihelion offset): ~±22.5s at solstices, ~±5.2s at equinoxes');
  console.log('  This is the geometric parallax between the wobble-center and perihelion point.');
  console.log('  At solstices, Earth is perpendicular to the perihelion-aphelion axis, maximizing');
  console.log('  the parallax angle. At equinoxes, Earth is closer to that axis, reducing parallax.');
  console.log('  Method C "washes out" the eccentricity effect, converging all cardinal points to');
  console.log('  nearly the same value (~365.2421887 days) - very close to IAU mean tropical year.');
  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════════════════════════');
  console.log('WHY THE MODEL DIFFERS FROM IAU AT SOLSTICES (~±26s):');
  console.log('───────────────────────────────────────────────────────────────────────────────────────────────');
  console.log('This model uses a CIRCULAR orbit with an offset center (perihelion point)');
  console.log('to simulate eccentricity. The Sun moves at constant angular velocity.');
  console.log('');
  console.log('IAU calculations use an ELLIPTICAL orbit where Earth (and thus the Sun');
  console.log('from our geocentric view) moves faster at perihelion and slower at aphelion');
  console.log('(Kepler\'s 2nd Law: equal areas in equal times).');
  console.log('');
  console.log('This velocity variation causes the IAU tropical year to vary by ~96s:');
  console.log('  - SS (near aphelion):  365.241626 days (shortest - slow motion)');
  console.log('  - WS (near perihelion): 365.242740 days (longest - fast motion)');
  console.log('');
  console.log('The circular orbit model correctly simulates:');
  console.log('  ✓ Mean tropical year length');
  console.log('  ✓ Distance variations (perihelion/aphelion)');
  console.log('  ✓ All precession cycles');
  console.log('');
  console.log('But cannot replicate variable orbital velocity (Kepler\'s 2nd Law),');
  console.log('hence the ~26s deviation at solstices vs IAU reference values.');
  console.log('═══════════════════════════════════════════════════════════════════════════════════════════════');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;
  return { methodA: resultsA, methodB: resultsB, methodC: resultsC };
}

/** Analyze anomalistic year length from perihelion and aphelion intervals */
async function analyzeAnoministicYear(startYear, endYear) {
  startYear = startYear || o.calibrationYearStart;
  endYear = endYear || o.calibrationYearEnd;

  console.log('╔═══════════════════════════════════════════════════════════════════════════════════════╗');
  console.log('║              PERIHELION INTERVAL ANALYSIS (Two Reference Frames)                    ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ Earth-Frame Perihelion Interval: Minimum Earth→Sun distance (Earth wobbles)        ║');
  console.log('║ Anomalistic Year (True):         Minimum WobbleCenter→Sun distance (fixed origin)  ║');
  console.log('╚═══════════════════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing years ${startYear} to ${endYear}...`);
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // === EARTH-FRAME: PERIHELION INTERVAL (Earth-Sun distance) ===
  const perihelions = [];
  let prevPeriJD = null;
  for (let year = startYear; year <= endYear; year++) {
    const shouldDebug = false;
    const result = perihelionForYear(year, shouldDebug, prevPeriJD);
    if (result) {
      perihelions.push({ year, jd: result.jd, distance: result.distance });
      prevPeriJD = result.jd;
    }
    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  const periIntervals = [];
  for (let i = 1; i < perihelions.length; i++) {
    periIntervals.push({
      year: perihelions[i].year,
      interval: perihelions[i].jd - perihelions[i - 1].jd
    });
  }
  const periMean = periIntervals.reduce((sum, i) => sum + i.interval, 0) / periIntervals.length;

  // === TRUE ANOMALISTIC YEAR (WobbleCenter-Sun distance - fixed reference) ===
  // Debug output suppressed - set shouldDebug = true to re-enable per-year logging
  const perihelionsB = [];
  let prevPeriJD_B = null;
  for (let year = startYear; year <= endYear; year++) {
    const shouldDebug = false;  // Was: (year - startYear) < 3
    const result = perihelionForYearMethodB(year, shouldDebug, prevPeriJD_B);
    if (result) {
      perihelionsB.push({ year, jd: result.jd, distance: result.distance });
      prevPeriJD_B = result.jd;
    }
    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  const periIntervalsB = [];
  for (let i = 1; i < perihelionsB.length; i++) {
    periIntervalsB.push({
      year: perihelionsB[i].year,
      interval: perihelionsB[i].jd - perihelionsB[i - 1].jd
    });
  }
  const periMeanB = periIntervalsB.reduce((sum, i) => sum + i.interval, 0) / periIntervalsB.length;

  // === EARTH-FRAME: APHELION INTERVAL ===
  // Debug output suppressed - set shouldDebug = true to re-enable per-year logging
  const aphelions = [];
  let prevApheJD = null;
  for (let year = startYear; year <= endYear; year++) {
    const shouldDebug = false;  // Was: (year - startYear) < 3
    const result = aphelionForYear(year, shouldDebug, prevApheJD);
    if (result) {
      aphelions.push({ year, jd: result.jd, distance: result.distance, alignmentDiff: result.alignmentDiff });
      prevApheJD = result.jd;
    }
    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  const apheIntervals = [];
  for (let i = 1; i < aphelions.length; i++) {
    apheIntervals.push({
      year: aphelions[i].year,
      interval: aphelions[i].jd - aphelions[i - 1].jd
    });
  }
  const apheMean = apheIntervals.reduce((sum, i) => sum + i.interval, 0) / apheIntervals.length;

  // === TRUE ANOMALISTIC YEAR - APHELION (WobbleCenter-Sun distance - fixed reference) ===
  const aphelionsB = [];
  let prevApheJD_B = null;
  for (let year = startYear; year <= endYear; year++) {
    const shouldDebug = false;
    const result = aphelionForYearMethodB(year, shouldDebug, prevApheJD_B);
    if (result) {
      aphelionsB.push({ year, jd: result.jd, distance: result.distance });
      prevApheJD_B = result.jd;
    }
    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  const apheIntervalsB = [];
  for (let i = 1; i < aphelionsB.length; i++) {
    apheIntervalsB.push({
      year: aphelionsB[i].year,
      interval: aphelionsB[i].jd - aphelionsB[i - 1].jd
    });
  }
  const apheMeanB = apheIntervalsB.reduce((sum, i) => sum + i.interval, 0) / apheIntervalsB.length;

  const iauAnomalistic = ASTRO_REFERENCE.anomalisticYearJ2000;

  // Calculate theoretical anomalistic year from perihelion precession rate
  const perihelionPrecessionYears = holisticyearLength / 16;  // 20,868 years
  const theoreticalAnomalistic = meansolaryearlengthinDays * perihelionPrecessionYears / (perihelionPrecessionYears - 1);

  console.log('');
  console.log('╔═══════════════════════════════════════════════════════════════════════════════════════════════════════╗');
  console.log('║                                 ANOMALISTIC YEAR RESULTS                                              ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ Measurement                                     │ Value (days)      │ Diff from IAU                  ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ EARTH-FRAME (Earth→Sun distance)                                                                      ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  const periADiff = (periMean - iauAnomalistic) * 86400;
  const apheDiff = (apheMean - iauAnomalistic) * 86400;
  console.log(`║   Perihelion Interval                           │ ${periMean.toFixed(9)}    │ ${periADiff >= 0 ? '+' : ''}${periADiff.toFixed(2)} seconds              ║`);
  console.log(`║   Aphelion Interval                             │ ${apheMean.toFixed(9)}    │ ${apheDiff >= 0 ? '+' : ''}${apheDiff.toFixed(2)} seconds              ║`);
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ WOBBLE-CENTER FRAME (WobbleCenter→Sun distance)                                                       ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  const periBDiff = (periMeanB - iauAnomalistic) * 86400;
  const apheBDiff = (apheMeanB - iauAnomalistic) * 86400;
  console.log(`║   Perihelion Interval                           │ ${periMeanB.toFixed(9)}    │ ${periBDiff >= 0 ? '+' : ''}${periBDiff.toFixed(2)} seconds               ║`);
  console.log(`║   Aphelion Interval                             │ ${apheMeanB.toFixed(9)}    │ ${apheBDiff >= 0 ? '+' : ''}${apheBDiff.toFixed(2)} seconds               ║`);
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  console.log(`║ IAU anomalistic year (J2000)                    │ ${iauAnomalistic.toFixed(9)}    │ (reference)                    ║`);
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ THEORETICAL (HY/16 Formula)                                                                           ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  const theorDiff = (theoreticalAnomalistic - iauAnomalistic) * 86400;
  console.log(`║ Formula (HY/16 = ${perihelionPrecessionYears} yrs)                   │ ${theoreticalAnomalistic.toFixed(9)}    │ ${theorDiff >= 0 ? '+' : ''}${theorDiff.toFixed(2)} seconds               ║`);
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ FRAME COMPARISON                                                                                      ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  const periMethodDiff = (periMean - periMeanB) * 86400;
  const apheMethodDiff = (apheMean - apheMeanB) * 86400;
  console.log(`║ Perihelion: Earth-Frame - WobbleCenter          │ ${periMethodDiff >= 0 ? '+' : ''}${periMethodDiff.toFixed(2)} seconds                                          ║`);
  console.log(`║ Aphelion:   Earth-Frame - WobbleCenter          │ ${apheMethodDiff >= 0 ? '+' : ''}${apheMethodDiff.toFixed(2)} seconds                                          ║`);
  console.log(`║ (Negative = Earth wobble shifts detection EARLIER than inertial frame)                               ║`);
  console.log(`║ This offset oscillates over the 25,684 year axial precession cycle.                                  ║`);
  console.log('╚═══════════════════════════════════════════════════════════════════════════════════════════════════════╝');

  // Debug output suppressed - first 3 JD values available in returned object
  // To re-enable: uncomment the following lines
  // console.log('');
  // console.log('First 3 Earth-Frame Perihelion Intervals (JD):');
  // perihelions.slice(0, 3).forEach((p, i) => {
  //   console.log(`  ${p.year}: JD ${p.jd.toFixed(6)} | Earth→Sun dist=${p.distance.toFixed(8)} AU`);
  // });
  // console.log('First 3 True Anomalistic Year (JD):');
  // perihelionsB.slice(0, 3).forEach((p, i) => {
  //   console.log(`  ${p.year}: JD ${p.jd.toFixed(6)} | WobbleCenter→Sun dist=${p.distance.toFixed(8)} AU`);
  // });
  // console.log('First 3 aphelions (JD):');
  // aphelions.slice(0, 3).forEach((a, i) => {
  //   console.log(`  ${a.year}: JD ${a.jd.toFixed(6)} | dist=${a.distance.toFixed(8)} AU | alignDiff=${a.alignmentDiff?.toFixed(10) ?? 'N/A'} AU`);
  // });

  jumpToJulianDay(savedJD);
  o.Run = savedRun;
  return { perihelions, perihelionsB, aphelions, aphelionsB, periIntervals, periIntervalsB, apheIntervals, apheIntervalsB, periMean, periMeanB, apheMean, apheMeanB };
}

/**
 * Analyze sidereal year length using four independent position-based methods:
 * - Method A: Origin→Sun world angle (Sun's absolute position from scene origin)
 * - Method B: WobbleCenter→Sun angle (Sun's position from Earth's wobble center)
 * - Method C: Heliocentric Sun→Earth angle (Earth's position as seen from Sun - includes wobble)
 * - Method D: Heliocentric Sun→WobbleCenter angle (WobbleCenter as seen from Sun - wobble-free)
 *
 * The sidereal year is the time for the Sun to return to the same position
 * relative to fixed stars (ICRF reference frame), approximately 365.256363 days.
 *
 * Methods A, B, and D should all agree (wobble-free measurements).
 * Method C includes Earth's wobble motion, showing the ~1.76s wobble contribution.
 */
async function analyzeSiderealYear(startYear, endYear) {
  startYear = startYear || o.calibrationYearStart;
  endYear = endYear || o.calibrationYearEnd;

  console.log('╔═══════════════════════════════════════════════════════════════════════════════════════════════════════╗');
  console.log('║                              SIDEREAL YEAR LENGTH ANALYSIS                                            ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ Method A: Origin→Sun world angle (Sun\'s absolute position from scene origin)                         ║');
  console.log('║ Method B: WobbleCenter→Sun angle (Sun\'s position from Earth\'s wobble center)                         ║');
  console.log('║ Method C: Heliocentric Sun→Earth angle (Earth\'s position as seen from Sun - includes wobble)         ║');
  console.log('║ Method D: Heliocentric Sun→WobbleCenter angle (WobbleCenter as seen from Sun - wobble-free)           ║');
  console.log('╚═══════════════════════════════════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing years ${startYear} to ${endYear}...`);
  console.log('');
  console.log('The sidereal year is the time for the Sun to return to the same position');
  console.log('relative to fixed stars (ICRF reference frame).');
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // Reusable vectors to avoid allocation in loops
  const _sunPos = new THREE.Vector3();
  const _wobblePos = new THREE.Vector3();
  const _earthPos = new THREE.Vector3();
  const _direction = new THREE.Vector3();

  // ═══════════════════════════════════════════════════════════════════════════
  // HELPER FUNCTIONS FOR EACH METHOD
  // ═══════════════════════════════════════════════════════════════════════════

  // Method A: Origin→Sun world angle (absolute world position)
  const getAngleMethodA = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    sun.planetObj.getWorldPosition(_sunPos);
    let angle = Math.atan2(_sunPos.z, _sunPos.x) * 180 / Math.PI;
    return ((angle % 360) + 360) % 360;
  };

  // Method B: WobbleCenter→Sun angle (from Earth's wobble center)
  const getAngleMethodB = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    earthWobbleCenter.planetObj.getWorldPosition(_wobblePos);
    sun.planetObj.getWorldPosition(_sunPos);
    _direction.copy(_sunPos).sub(_wobblePos);
    let angle = Math.atan2(_direction.z, _direction.x) * 180 / Math.PI;
    return ((angle % 360) + 360) % 360;
  };

  // Method C: Heliocentric Sun→Earth angle (Earth as seen from Sun)
  // Note: This includes Earth's wobble motion, causing ~1.76s difference from A/B
  const getAngleMethodC = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    sun.planetObj.getWorldPosition(_sunPos);
    earth.planetObj.getWorldPosition(_earthPos);
    _direction.copy(_earthPos).sub(_sunPos);
    let angle = Math.atan2(_direction.z, _direction.x) * 180 / Math.PI;
    return ((angle % 360) + 360) % 360;
  };

  // Method D: Heliocentric Sun→WobbleCenter angle (WobbleCenter as seen from Sun)
  // This removes Earth's wobble and should match Methods A/B exactly
  const getAngleMethodD = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    sun.planetObj.getWorldPosition(_sunPos);
    earthWobbleCenter.planetObj.getWorldPosition(_wobblePos);
    _direction.copy(_wobblePos).sub(_sunPos);
    let angle = Math.atan2(_direction.z, _direction.x) * 180 / Math.PI;
    return ((angle % 360) + 360) % 360;
  };

  // ═══════════════════════════════════════════════════════════════════════════
  // GENERIC CROSSING DETECTION FUNCTION
  // ═══════════════════════════════════════════════════════════════════════════

  const findCrossingsForMethod = async (getAngleFunc, methodName) => {
    const crossings = [];
    let firstCrossingJD = null;
    let targetAngle = null;

    for (let year = startYear; year <= endYear; year++) {
      let approxJD;
      let searchRange;

      if (firstCrossingJD !== null) {
        const prevCrossing = crossings[crossings.length - 1];
        approxJD = prevCrossing.jd + 365.256;
        searchRange = 288;  // ±6 days
      } else {
        const yearFraction = 0.47;  // June
        approxJD = startmodelJD + ((year + yearFraction) - startmodelYear) * meansolaryearlengthinDays;
        searchRange = 960;  // ±20 days
      }

      const step = 0.5 / 24;  // 0.5 hours
      const samples = [];

      for (let k = -searchRange; k <= searchRange; ++k) {
        const jd = approxJD + k * step;
        const angle = getAngleFunc(jd);
        samples.push({ k, jd, angle });
      }

      let crossingJD = null;

      if (firstCrossingJD === null) {
        // First year: use sun.ra = 90° as reference, then record the method's angle
        const target = 90;
        for (let i = 1; i < samples.length; i++) {
          jumpToJulianDay(samples[i-1].jd);
          forceSceneUpdate();
          const ra1 = (sun.ra * 180 / Math.PI + 360) % 360;

          jumpToJulianDay(samples[i].jd);
          forceSceneUpdate();
          const ra2 = (sun.ra * 180 / Math.PI + 360) % 360;

          if (ra1 < target && ra2 >= target) {
            const t = (target - ra1) / (ra2 - ra1);
            crossingJD = samples[i-1].jd + t * step;
            firstCrossingJD = crossingJD;
            targetAngle = getAngleFunc(crossingJD);
            break;
          }
        }
      } else {
        // Subsequent years: find when angle returns to target
        for (let i = 1; i < samples.length; i++) {
          let a1 = samples[i-1].angle;
          let a2 = samples[i].angle;

          // Handle wraparound
          if (Math.abs(a2 - a1) > 180) {
            if (a2 > a1) a1 += 360;
            else a2 += 360;
          }

          let adjustedTarget = targetAngle;
          if (a1 > 360 || a2 > 360) {
            if (targetAngle < 180) adjustedTarget = targetAngle + 360;
          }

          const crossingUp = a1 < adjustedTarget && a2 >= adjustedTarget;
          const crossingDown = a1 > adjustedTarget && a2 <= adjustedTarget;

          if (crossingUp || crossingDown) {
            const t = Math.abs(adjustedTarget - a1) / Math.abs(a2 - a1);
            crossingJD = samples[i-1].jd + t * step;
            break;
          }
        }
      }

      if (crossingJD) {
        const currentAngle = getAngleFunc(crossingJD);
        crossings.push({ year, jd: crossingJD, angle: currentAngle });
      }

      if (year % 5 === 0) await new Promise(r => setTimeout(r, 10));
    }

    // Calculate intervals
    const intervals = [];
    for (let i = 1; i < crossings.length; i++) {
      intervals.push({
        year: crossings[i].year,
        interval: crossings[i].jd - crossings[i - 1].jd
      });
    }

    const mean = intervals.length > 0
      ? intervals.reduce((sum, i) => sum + i.interval, 0) / intervals.length
      : 0;

    return { crossings, intervals, mean, targetAngle };
  };

  // ═══════════════════════════════════════════════════════════════════════════
  // RUN ALL FOUR METHODS
  // ═══════════════════════════════════════════════════════════════════════════

  console.log('Running Method A: Origin→Sun world angle...');
  const resultA = await findCrossingsForMethod(getAngleMethodA, 'A');

  console.log('Running Method B: WobbleCenter→Sun angle...');
  const resultB = await findCrossingsForMethod(getAngleMethodB, 'B');

  console.log('Running Method C: Heliocentric Sun→Earth angle...');
  const resultC = await findCrossingsForMethod(getAngleMethodC, 'C');

  console.log('Running Method D: Heliocentric Sun→WobbleCenter angle...');
  const resultD = await findCrossingsForMethod(getAngleMethodD, 'D');

  // ═══════════════════════════════════════════════════════════════════════════
  // COMPARISON WITH IAU REFERENCE
  // ═══════════════════════════════════════════════════════════════════════════

  const iauSiderealYear = ASTRO_REFERENCE.siderealYearJ2000;
  const iauTropicalYear = ASTRO_REFERENCE.tropicalYearMeanJ2000;
  const iauPrecessionContrib = iauSiderealYear - iauTropicalYear;

  const diffA = (resultA.mean - iauSiderealYear) * 86400;
  const diffB = (resultB.mean - iauSiderealYear) * 86400;
  const diffC = (resultC.mean - iauSiderealYear) * 86400;
  const diffD = (resultD.mean - iauSiderealYear) * 86400;

  // Method agreement
  const diffAB = (resultA.mean - resultB.mean) * 86400;
  const diffAD = (resultA.mean - resultD.mean) * 86400;
  const diffCD = (resultC.mean - resultD.mean) * 86400;

  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════════════════════════════════');
  console.log('RESULTS');
  console.log('═══════════════════════════════════════════════════════════════════════════════════════════════════════');
  console.log('');
  console.log('╔═════════════════════════════════════════════════════════╤═══════════════════╤═══════════════════════╗');
  console.log('║ Method                                                  │ Value (days)      │ Diff from IAU         ║');
  console.log('╠═════════════════════════════════════════════════════════╪═══════════════════╪═══════════════════════╣');
  console.log(`║ A: Origin→Sun world angle                               │ ${resultA.mean.toFixed(9)}    │ ${diffA >= 0 ? '+' : ''}${diffA.toFixed(2).padStart(6)} seconds     ║`);
  console.log(`║ B: WobbleCenter→Sun angle                               │ ${resultB.mean.toFixed(9)}    │ ${diffB >= 0 ? '+' : ''}${diffB.toFixed(2).padStart(6)} seconds     ║`);
  console.log(`║ D: Heliocentric Sun→WobbleCenter angle                  │ ${resultD.mean.toFixed(9)}    │ ${diffD >= 0 ? '+' : ''}${diffD.toFixed(2).padStart(6)} seconds     ║`);
  console.log('╠═════════════════════════════════════════════════════════╪═══════════════════╪═══════════════════════╣');
  console.log(`║ C: Heliocentric Sun→Earth angle (includes wobble)       │ ${resultC.mean.toFixed(9)}    │ ${diffC >= 0 ? '+' : ''}${diffC.toFixed(2).padStart(6)} seconds     ║`);
  console.log('╠═════════════════════════════════════════════════════════╪═══════════════════╪═══════════════════════╣');
  console.log(`║ IAU sidereal year (J2000)                               │ ${iauSiderealYear.toFixed(9)}    │ (reference)           ║`);
  console.log('╚═════════════════════════════════════════════════════════╧═══════════════════╧═══════════════════════╝');

  console.log('');
  console.log('╔═════════════════════════════════════════════════════════╤═══════════════════════╗');
  console.log('║ Method Agreement (wobble-free methods)                  │ Difference            ║');
  console.log('╠═════════════════════════════════════════════════════════╪═══════════════════════╣');
  console.log(`║ Method A - Method B                                     │ ${diffAB >= 0 ? '+' : ''}${diffAB.toFixed(3).padStart(7)} seconds     ║`);
  console.log(`║ Method A - Method D                                     │ ${diffAD >= 0 ? '+' : ''}${diffAD.toFixed(3).padStart(7)} seconds     ║`);
  console.log('╠═════════════════════════════════════════════════════════╪═══════════════════════╣');
  console.log('║ Earth Wobble Effect (C vs D)                            │                       ║');
  console.log('╠═════════════════════════════════════════════════════════╪═══════════════════════╣');
  console.log(`║ Method C - Method D (wobble contribution)               │ ${diffCD >= 0 ? '+' : ''}${diffCD.toFixed(3).padStart(7)} seconds     ║`);
  console.log('╚═════════════════════════════════════════════════════════╧═══════════════════════╝');

  console.log('');
  console.log('╔═════════════════════════════════════════════════════════╤═══════════════════════╗');
  console.log('║ Precession Validation                                   │ Value                 ║');
  console.log('╠═════════════════════════════════════════════════════════╪═══════════════════════╣');
  const siderealMinusTropicalA = (resultA.mean - iauTropicalYear) * 86400;
  console.log(`║ Sidereal - Tropical (Method A)                          │ ${siderealMinusTropicalA.toFixed(2).padStart(7)} seconds     ║`);
  console.log(`║ Sidereal - Tropical (IAU)                               │ ${(iauPrecessionContrib * 86400).toFixed(2).padStart(7)} seconds     ║`);
  console.log('╚═════════════════════════════════════════════════════════╧═══════════════════════╝');

  // Show trend if enough data (using Method A as primary)
  if (resultA.intervals.length > 10) {
    const firstFive = resultA.intervals.slice(0, 5);
    const lastFive = resultA.intervals.slice(-5);
    const firstMean = firstFive.reduce((s, i) => s + i.interval, 0) / 5;
    const lastMean = lastFive.reduce((s, i) => s + i.interval, 0) / 5;
    const yearSpan = lastFive[4].year - firstFive[0].year;
    const drift = (lastMean - firstMean) / yearSpan * 86400;
    console.log('');
    console.log(`Trend over ${yearSpan} years: ${drift.toFixed(3)} sec/year change in sidereal year (Method A)`);
  }

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return {
    methodA: { crossings: resultA.crossings, intervals: resultA.intervals, mean: resultA.mean },
    methodB: { crossings: resultB.crossings, intervals: resultB.intervals, mean: resultB.mean },
    methodC: { crossings: resultC.crossings, intervals: resultC.intervals, mean: resultC.mean },
    methodD: { crossings: resultD.crossings, intervals: resultD.intervals, mean: resultD.mean },
    iauReference: iauSiderealYear
  };
}

/** Comprehensive analysis of all alignment intervals */
async function analyzeAllAlignments(startYear, endYear) {
  startYear = startYear || o.calibrationYearStart;
  endYear = endYear || o.calibrationYearEnd;

  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           COMPREHENSIVE ALIGNMENT ANALYSIS                               ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing years ${startYear} to ${endYear}...`);
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // Collect all cardinal point data using sunRACrossingForYear
  const cardinalData = {
    VE:  { ra: 0,   name: 'Vernal Equinox (RA=0°)',     iauRef: ASTRO_REFERENCE.tropicalYearVEJ2000, events: [] },
    SS:  { ra: 90,  name: 'Summer Solstice (RA=90°)',   iauRef: ASTRO_REFERENCE.tropicalYearSSJ2000, events: [] },
    AE:  { ra: 180, name: 'Autumnal Equinox (RA=180°)', iauRef: ASTRO_REFERENCE.tropicalYearAEJ2000, events: [] },
    WS:  { ra: 270, name: 'Winter Solstice (RA=270°)',  iauRef: ASTRO_REFERENCE.tropicalYearWSJ2000, events: [] }
  };

  // Collect perihelion and aphelion
  const perihelions = [];
  const aphelions = [];

  // Collect all 4 cardinal points
  for (const key of ['VE', 'SS', 'AE', 'WS']) {
    const point = cardinalData[key];
    console.log(`Collecting ${point.name}...`);
    let prevJD = null;
    for (let year = startYear; year <= endYear; year++) {
      const result = sunRACrossingForYear(year, point.ra, prevJD);
      if (result) {
        point.events.push({ year, jd: result.jd });
        prevJD = result.jd;
      }
      if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
    }
  }

  console.log('Collecting perihelions (True Anomalistic Year - WobbleCenter→Sun)...');
  let prevPeriJD = null;
  for (let year = startYear; year <= endYear; year++) {
    const result = perihelionForYearMethodB(year, false, prevPeriJD);
    if (result) {
      perihelions.push({ year, jd: result.jd, distance: result.distance });
      prevPeriJD = result.jd;
    }
    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  console.log('Collecting aphelions (True Anomalistic Year - WobbleCenter→Sun)...');
  let prevAphelionJD = null;
  for (let year = startYear; year <= endYear; year++) {
    const result = aphelionForYearMethodB(year, false, prevAphelionJD);
    if (result) {
      aphelions.push({ year, jd: result.jd, distance: result.distance });
      prevAphelionJD = result.jd;
    }
    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  // Collect sidereal year data (Sun world position method)
  console.log('Collecting sidereal year crossings (Sun world position)...');
  const siderealCrossings = [];
  let firstSiderealJD = null;
  let targetSiderealAngle = null;

  // Helper to get Sun's absolute world angle
  const getSunWorldAngle = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    const sunPos = new THREE.Vector3();
    sun.planetObj.getWorldPosition(sunPos);
    let angle = Math.atan2(sunPos.z, sunPos.x) * 180 / Math.PI;
    return ((angle % 360) + 360) % 360;
  };

  for (let year = startYear; year <= endYear; year++) {
    let approxJD;
    let searchRange;

    if (firstSiderealJD !== null) {
      const prevCrossing = siderealCrossings[siderealCrossings.length - 1];
      approxJD = prevCrossing.jd + 365.256;
      searchRange = 288;  // ±6 days
    } else {
      const yearFraction = 0.47;  // June
      approxJD = startmodelJD + ((year + yearFraction) - startmodelYear) * meansolaryearlengthinDays;
      searchRange = 960;  // ±20 days
    }

    const step = 0.5 / 24;  // 0.5 hours
    const samples = [];

    for (let k = -searchRange; k <= searchRange; ++k) {
      const jd = approxJD + k * step;
      const angle = getSunWorldAngle(jd);
      samples.push({ k, jd, angle });
    }

    let crossingJD = null;

    if (firstSiderealJD === null) {
      // First year: use sun.ra = 90° as reference, then record world angle
      const target = 90;
      for (let i = 1; i < samples.length; i++) {
        jumpToJulianDay(samples[i-1].jd);
        forceSceneUpdate();
        const ra1 = (sun.ra * 180 / Math.PI + 360) % 360;

        jumpToJulianDay(samples[i].jd);
        forceSceneUpdate();
        const ra2 = (sun.ra * 180 / Math.PI + 360) % 360;

        if (ra1 < target && ra2 >= target) {
          const t = (target - ra1) / (ra2 - ra1);
          crossingJD = samples[i-1].jd + t * step;
          firstSiderealJD = crossingJD;
          targetSiderealAngle = getSunWorldAngle(crossingJD);
          break;
        }
      }
    } else {
      // Subsequent years: find when world angle returns to target
      for (let i = 1; i < samples.length; i++) {
        let a1 = samples[i-1].angle;
        let a2 = samples[i].angle;

        // Handle wraparound
        if (Math.abs(a2 - a1) > 180) {
          if (a2 > a1) a1 += 360;
          else a2 += 360;
        }

        let adjustedTarget = targetSiderealAngle;
        if (a1 > 360 || a2 > 360) {
          if (targetSiderealAngle < 180) adjustedTarget = targetSiderealAngle + 360;
        }

        const crossingUp = a1 < adjustedTarget && a2 >= adjustedTarget;
        const crossingDown = a1 > adjustedTarget && a2 <= adjustedTarget;

        if (crossingUp || crossingDown) {
          const t = Math.abs(adjustedTarget - a1) / Math.abs(a2 - a1);
          crossingJD = samples[i-1].jd + t * step;
          break;
        }
      }
    }

    if (crossingJD) {
      siderealCrossings.push({ year, jd: crossingJD });
    }

    if (year % 10 === 0) await new Promise(r => setTimeout(r, 10));
  }

  // Calculate sidereal year intervals
  const siderealIntervals = [];
  for (let i = 1; i < siderealCrossings.length; i++) {
    siderealIntervals.push(siderealCrossings[i].jd - siderealCrossings[i - 1].jd);
  }
  const meanSiderealYear = siderealIntervals.length > 0
    ? siderealIntervals.reduce((a, b) => a + b, 0) / siderealIntervals.length
    : 0;

  // Calculate intervals for each cardinal point
  for (const key of Object.keys(cardinalData)) {
    const point = cardinalData[key];
    point.intervals = [];
    for (let i = 1; i < point.events.length; i++) {
      point.intervals.push(point.events[i].jd - point.events[i - 1].jd);
    }
    point.mean = point.intervals.length > 0
      ? point.intervals.reduce((a, b) => a + b, 0) / point.intervals.length
      : 0;
  }

  const perihelionIntervals = [];
  for (let i = 1; i < perihelions.length; i++) {
    perihelionIntervals.push(perihelions[i].jd - perihelions[i - 1].jd);
  }
  const meanPerihelion = perihelionIntervals.length > 0
    ? perihelionIntervals.reduce((a, b) => a + b, 0) / perihelionIntervals.length
    : 0;

  const aphelionIntervals = [];
  for (let i = 1; i < aphelions.length; i++) {
    aphelionIntervals.push(aphelions[i].jd - aphelions[i - 1].jd);
  }
  const meanAphelion = aphelionIntervals.length > 0
    ? aphelionIntervals.reduce((a, b) => a + b, 0) / aphelionIntervals.length
    : 0;

  // Calculate MEAN TROPICAL YEAR (average of all 4 cardinal points)
  const meanTropicalYear = (cardinalData.VE.mean + cardinalData.SS.mean +
                            cardinalData.AE.mean + cardinalData.WS.mean) / 4;

  // Get orbital parameters at middle year
  const midYear = Math.floor((startYear + endYear) / 2);
  jumpToJulianDay(startmodelJD + (midYear - startmodelYear) * meansolaryearlengthinDays);
  forceSceneUpdate();
  const obliquity = o.obliquityEarth;
  const eccentricity = o.eccentricityEarth;

  console.log('');
  console.log('╔═══════════════════════════════════════════════════════════════════════════════════════╗');
  console.log('║                              RESULTS SUMMARY                                          ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  console.log(`║ Analysis period: ${startYear} to ${endYear} (${endYear - startYear} years)                                                   ║`);
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ ORBITAL PARAMETERS (at mid-point)                                                     ║');
  console.log(`║   Obliquity:     ${obliquity?.toFixed(6) || 'N/A'}°                                                                ║`);
  console.log(`║   Eccentricity:  ${eccentricity?.toFixed(8) || 'N/A'}                                                              ║`);
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ TROPICAL YEAR BY CARDINAL POINT                     Measured          IAU Ref         ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  for (const key of ['VE', 'SS', 'AE', 'WS']) {
    const p = cardinalData[key];
    const diffSec = (p.mean - p.iauRef) * 86400;
    console.log(`║   ${p.name.padEnd(30)} ${p.mean.toFixed(9)}    ${p.iauRef.toFixed(9)}   ${diffSec >= 0 ? '+' : ''}${diffSec.toFixed(2)}s ║`);
  }
  console.log('║───────────────────────────────────────────────────────────────────────────────────────║');
  console.log('║   Note: Model uses circular orbit (constant angular velocity). IAU uses elliptical   ║');
  console.log('║   orbit (Kepler\'s 2nd Law). This causes ~±26s deviation at solstices where orbital   ║');
  console.log('║   velocity difference is maximum. Mean tropical year cancels this effect.            ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ MEAN TROPICAL YEAR (average of 4 cardinal points)                                     ║');
  const meanDiffSec = (meanTropicalYear - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400;
  console.log(`║   Measured mean:     ${meanTropicalYear.toFixed(9)} days                                          ║`);
  console.log(`║   IAU mean:          ${ASTRO_REFERENCE.tropicalYearMeanJ2000.toFixed(9)} days                                          ║`);
  console.log(`║   Difference:        ${meanDiffSec >= 0 ? '+' : ''}${meanDiffSec.toFixed(2)} seconds                                                        ║`);
  console.log(`║   Model configured:  ${meansolaryearlengthinDays.toFixed(9)} days                                          ║`);
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ ANOMALISTIC YEAR                                    Measured          IAU Ref         ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  const periDiffSec = (meanPerihelion - ASTRO_REFERENCE.anomalisticYearJ2000) * 86400;
  const apheDiffSec = (meanAphelion - ASTRO_REFERENCE.anomalisticYearJ2000) * 86400;
  console.log(`║   Perihelion to perihelion:      ${meanPerihelion.toFixed(9)}    ${ASTRO_REFERENCE.anomalisticYearJ2000.toFixed(9)}   ${periDiffSec >= 0 ? '+' : ''}${periDiffSec.toFixed(2)}s ║`);
  console.log(`║   Aphelion to aphelion:          ${meanAphelion.toFixed(9)}    ${ASTRO_REFERENCE.anomalisticYearJ2000.toFixed(9)}   ${apheDiffSec >= 0 ? '+' : ''}${apheDiffSec.toFixed(2)}s ║`);
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  console.log('║ SIDEREAL YEAR (Sun world position)                  Measured          IAU Ref         ║');
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣');
  const siderealDiffSec = (meanSiderealYear - ASTRO_REFERENCE.siderealYearJ2000) * 86400;
  const siderealTropicalDiff = (meanSiderealYear - meanTropicalYear) * 86400;
  const iauSiderealTropicalDiff = (ASTRO_REFERENCE.siderealYearJ2000 - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400;
  console.log(`║   Sidereal year:                 ${meanSiderealYear.toFixed(9)}    ${ASTRO_REFERENCE.siderealYearJ2000.toFixed(9)}   ${siderealDiffSec >= 0 ? '+' : ''}${siderealDiffSec.toFixed(2)}s ║`);
  console.log(`║   Sidereal - Tropical (model):   ${siderealTropicalDiff.toFixed(2)} seconds                                        ║`);
  console.log(`║   Sidereal - Tropical (IAU):     ${iauSiderealTropicalDiff.toFixed(2)} seconds                                        ║`);
  console.log('╚═══════════════════════════════════════════════════════════════════════════════════════╝');

  // ═══════════════════════════════════════════════════════════════════════════
  // PHASE ALIGNMENT DIAGNOSTICS (debug output suppressed)
  // ═══════════════════════════════════════════════════════════════════════════
  // These diagnostics were used to debug the anomalistic year measurement.
  // The helper functions are retained but console output is suppressed.

  // Helper to get physical positions and angles with full detail
  const getPhysicalState = (jd, label = '') => {
    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Convert JD to date string
    const jdToDateStr = (jd) => {
      const J2000 = 2451545.0;
      const msPerDay = 86400000;
      const unixMs = (jd - 2440587.5) * msPerDay;
      const d = new Date(unixMs);
      return d.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
    };

    // Get earthWobbleCenter world position (should be at origin 0,0,0)
    const wobbleWorldPos = new THREE.Vector3();
    earthWobbleCenter.planetObj.getWorldPosition(wobbleWorldPos);

    // Get Sun's world position
    const sunWorldPos = new THREE.Vector3();
    sun.planetObj.getWorldPosition(sunWorldPos);
    const sunAngle = Math.atan2(sunWorldPos.z, sunWorldPos.x) * 180 / Math.PI;
    const sunAngleNorm = ((sunAngle % 360) + 360) % 360;

    // Get Earth's world position (NOT at origin due to axial precession wobble)
    const earthWorldPos = new THREE.Vector3();
    earth.planetObj.getWorldPosition(earthWorldPos);
    const earthAngle = Math.atan2(earthWorldPos.z, earthWorldPos.x) * 180 / Math.PI;
    const earthAngleNorm = ((earthAngle % 360) + 360) % 360;

    // Get barycenterEarthAndSun world position (perihelion point location)
    const baryWorldPos = new THREE.Vector3();
    barycenterEarthAndSun.planetObj.getWorldPosition(baryWorldPos);
    const baryAngle = Math.atan2(baryWorldPos.z, baryWorldPos.x) * 180 / Math.PI;
    const baryAngleNorm = ((baryAngle % 360) + 360) % 360;

    // Direction from Earth to Sun (this is what we observe as Sun's position)
    const earthToSunAngle = Math.atan2(sunWorldPos.z - earthWorldPos.z, sunWorldPos.x - earthWorldPos.x) * 180 / Math.PI;
    const earthToSunAngleNorm = ((earthToSunAngle % 360) + 360) % 360;

    // Direction from Earth to barycenter/perihelion point
    const earthToBaryAngle = Math.atan2(baryWorldPos.z - earthWorldPos.z, baryWorldPos.x - earthWorldPos.x) * 180 / Math.PI;
    const earthToBaryAngleNorm = ((earthToBaryAngle % 360) + 360) % 360;

    // Distance from Earth to Sun
    const earthSunDist = Math.sqrt(
      Math.pow(sunWorldPos.x - earthWorldPos.x, 2) +
      Math.pow(sunWorldPos.y - earthWorldPos.y, 2) +
      Math.pow(sunWorldPos.z - earthWorldPos.z, 2)
    ) / 100; // Convert to AU

    // Sun RA from model (in Earth's equatorial frame)
    const sunRA = (sun.ra * 180 / Math.PI + 360) % 360;
    const sunRAHours = sunRA / 15; // Convert to hours

    return {
      jd: jd,
      dateStr: jdToDateStr(jd),
      label: label,
      // World positions (X, Y, Z in scene units, Y is up)
      wobblePos: { x: wobbleWorldPos.x, y: wobbleWorldPos.y, z: wobbleWorldPos.z },
      earthPos: { x: earthWorldPos.x, y: earthWorldPos.y, z: earthWorldPos.z },
      baryPos: { x: baryWorldPos.x, y: baryWorldPos.y, z: baryWorldPos.z },
      sunPos: { x: sunWorldPos.x, y: sunWorldPos.y, z: sunWorldPos.z },
      // Angles in XZ plane (world coordinates)
      sunWorldAngle: sunAngleNorm,
      earthWorldAngle: earthAngleNorm,
      baryWorldAngle: baryAngleNorm,
      // Directions FROM Earth
      earthToSunAngle: earthToSunAngleNorm,
      earthToBaryAngle: earthToBaryAngleNorm,
      // Distances
      earthSunDistAU: earthSunDist,
      sunDistAU: sun.distAU,
      // Sun RA (equatorial frame)
      sunRA: sunRA,
      sunRAHours: sunRAHours,
      // Model values
      longitudePerihelion: o.longitudePerihelion
    };
  };

  // Print detailed state for a single moment (debug output suppressed)
  const printDetailedState = (state) => {
    // Debug output suppressed - function retained for potential future use
  };

  // ═══════════════════════════════════════════════════════════════════════════════
  // DETAILED STATE ANALYSIS AT KEY REFERENCE DATES (debug output suppressed)
  // ═══════════════════════════════════════════════════════════════════════════════

  // 1. Model start date: June 21, 2000 00:00 UTC (should be near Summer Solstice)
  const modelStartJD = 2451716.5; // June 21, 2000 00:00 UTC
  const stateModelStart = getPhysicalState(modelStartJD, 'MODEL START: June 21, 2000 00:00 UTC (Summer Solstice)');
  printDetailedState(stateModelStart);

  // 2. First perihelion in the data (minimum distance)
  if (perihelions.length > 0) {
    const firstPeri = perihelions[0];
    const statePerihelion = getPhysicalState(firstPeri.jd, `PERIHELION ${firstPeri.year}: Minimum distance (${firstPeri.distance.toFixed(6)} AU)`);
    printDetailedState(statePerihelion);
  }

  // 3. First aphelion in the data (maximum distance)
  if (aphelions.length > 0) {
    const firstAph = aphelions[0];
    const stateAphelion = getPhysicalState(firstAph.jd, `APHELION ${firstAph.year}: Maximum distance (${firstAph.distance.toFixed(6)} AU)`);
    printDetailedState(stateAphelion);
  }

  // 4. First Summer Solstice (SS at 90°)
  if (cardinalData.SS.events.length > 0) {
    const firstSS = cardinalData.SS.events[0];
    const stateSS = getPhysicalState(firstSS.jd, `SUMMER SOLSTICE ${firstSS.year}: Sun RA should be 90° (6h)`);
    printDetailedState(stateSS);
  }

  // 5. First Winter Solstice (WS at 270°)
  if (cardinalData.WS.events.length > 0) {
    const firstWS = cardinalData.WS.events[0];
    const stateWS = getPhysicalState(firstWS.jd, `WINTER SOLSTICE ${firstWS.year}: Sun RA should be 270° (18h)`);
    printDetailedState(stateWS);
  }

  // ═══════════════════════════════════════════════════════════════════════════════
  // ANALYSIS SUMMARY (debug output suppressed)
  // ═══════════════════════════════════════════════════════════════════════════════
  // Key expectations box suppressed - retained for reference:
  // 1. At Summer Solstice (June): Sun RA ≈ 90°, distance ≈ 1.016 AU (near max)
  // 2. At Winter Solstice (Dec):  Sun RA ≈ 270°, distance ≈ 0.984 AU (near min)
  // 3. At Perihelion (Jan 3):     Distance = minimum (~0.983 AU)
  // 4. At Aphelion (Jul 4):       Distance = maximum (~1.017 AU)
  // 5. Earth→Bary direction should equal Longitude of Perihelion (~103°)
  // 6. At Perihelion: Sun should be OPPOSITE to perihelion direction (~283°)
  // 7. At Aphelion: Sun should be IN the perihelion direction (~103°)

  // Analyze at each cardinal point (to see orbital speed variation pattern)
  console.log('');
  console.log('┌─────────────────────────────────────────────────────────────────────────────────────────┐');
  console.log('│ CARDINAL POINT ORBITAL SPEED ANALYSIS                                                  │');
  console.log('├─────────────────────────────────────────────────────────────────────────────────────────┤');
  console.log('│ Sun-Earth distance at each cardinal point reveals orbital speed variation.            │');
  console.log('│ Closer = faster orbit → shorter year interval. Farther = slower → longer interval.    │');
  console.log('├─────────────────────────────────────────────────────────────────────────────────────────┤');
  console.log('│ Year │ Point │ Sun-Earth AU │ Year Length │ IAU Ref     │ Diff (sec) │ Speed Pattern │');
  console.log('├──────┼───────┼──────────────┼─────────────┼─────────────┼────────────┼───────────────┤');

  // Take first few years for each cardinal point
  for (let i = 0; i < Math.min(3, cardinalData.VE.events.length - 1); i++) {
    for (const key of ['VE', 'SS', 'AE', 'WS']) {
      const event = cardinalData[key].events[i];
      if (!event) continue;

      jumpToJulianDay(event.jd);
      forceSceneUpdate();
      const distAU = sun.distAU;

      const interval = cardinalData[key].intervals[i];
      const iauRef = cardinalData[key].iauRef;
      const diffSec = interval ? (interval - iauRef) * 86400 : 0;

      // Determine if closer (faster) or farther (slower) than mean
      const meanDist = 1.0;  // ~1 AU average
      const speedPattern = distAU < meanDist ? 'FASTER (close)' : 'SLOWER (far)';

      console.log(`│ ${event.year} │ ${key.padEnd(5)} │ ${distAU.toFixed(8).padStart(12)} │ ${(interval || 0).toFixed(6).padStart(11)} │ ${iauRef.toFixed(6).padStart(11)} │ ${(diffSec >= 0 ? '+' : '') + diffSec.toFixed(2).padStart(9)}s │ ${speedPattern.padEnd(13)} │`);
    }
    if (i < 2) console.log('├──────┼───────┼──────────────┼─────────────┼─────────────┼────────────┼───────────────┤');
  }
  console.log('└──────┴───────┴──────────────┴─────────────┴─────────────┴────────────┴───────────────┘');

  // Expected vs actual pattern analysis
  console.log('');
  console.log('┌─────────────────────────────────────────────────────────────────────────────────────────┐');
  console.log('│ EXPECTED VS ACTUAL PATTERN (IAU Reference)                                             │');
  console.log('├─────────────────────────────────────────────────────────────────────────────────────────┤');
  console.log('│ IAU J2000 tropical year lengths by cardinal point:                                     │');
  console.log(`│   SS (June) = ${ASTRO_REFERENCE.tropicalYearSSJ2000} days - SHORTEST (aphelion in middle, fast start/end)        │`);
  console.log(`│   AE (Sept) = ${ASTRO_REFERENCE.tropicalYearAEJ2000} days - medium                                                │`);
  console.log(`│   VE (Mar)  = ${ASTRO_REFERENCE.tropicalYearVEJ2000} days - medium                                                │`);
  console.log(`│   WS (Dec)  = ${ASTRO_REFERENCE.tropicalYearWSJ2000} days - LONGEST (perihelion in middle, slow start/end)       │`);
  console.log('├─────────────────────────────────────────────────────────────────────────────────────────┤');
  const vePattern = (cardinalData.VE.mean - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400;
  const ssPattern = (cardinalData.SS.mean - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400;
  const aePattern = (cardinalData.AE.mean - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400;
  const wsPattern = (cardinalData.WS.mean - ASTRO_REFERENCE.tropicalYearMeanJ2000) * 86400;

  // IAU pattern: SS < AE < VE < WS (shortest to longest)
  console.log(`│ VE (Mar): ${vePattern >= 0 ? '+' : ''}${vePattern.toFixed(2)}s vs mean  → ${vePattern > 0 ? 'LONGER ✓' : 'SHORTER ✗'} (Expected: slightly LONGER)  │`);
  console.log(`│ SS (Jun): ${ssPattern >= 0 ? '+' : ''}${ssPattern.toFixed(2)}s vs mean  → ${ssPattern < 0 ? 'SHORTER ✓' : 'LONGER ✗'} (Expected: SHORTER)          │`);
  console.log(`│ AE (Sep): ${aePattern >= 0 ? '+' : ''}${aePattern.toFixed(2)}s vs mean  → ${aePattern < 0 ? 'SHORTER ✓' : 'LONGER ✗'} (Expected: slightly SHORTER) │`);
  console.log(`│ WS (Dec): ${wsPattern >= 0 ? '+' : ''}${wsPattern.toFixed(2)}s vs mean  → ${wsPattern > 0 ? 'LONGER ✓' : 'SHORTER ✗'} (Expected: LONGER)           │`);
  console.log('├─────────────────────────────────────────────────────────────────────────────────────────┤');

  // Check if pattern matches IAU: SS shortest, WS longest
  // Correct pattern: ssPattern < 0, wsPattern > 0, and SS < WS
  const correctCount = (ssPattern < 0 ? 1 : 0) + (wsPattern > 0 ? 1 : 0) + (vePattern > aePattern ? 1 : 0) + (ssPattern < aePattern ? 1 : 0);
  const invertedCount = (ssPattern > 0 ? 1 : 0) + (wsPattern < 0 ? 1 : 0);

  if (invertedCount >= 3) {
    console.log('│ ⚠️  PATTERN INVERTED: Suggests 180° phase error in eccentricity/perihelion alignment │');
    console.log('│     The midEccentricityOrbit may be rotating opposite to physical perihelion         │');
  } else if (correctCount >= 3) {
    console.log('│ ✓ Pattern matches expected IAU cardinal point variations                             │');
  } else {
    console.log('│ ⚠️  Mixed pattern - phase alignment may be partially correct                         │');
  }
  console.log('└─────────────────────────────────────────────────────────────────────────────────────────┘');
  console.log('');

  // Output data table for each year
  console.log('\n--- DETAILED DATA TABLE ---');
  console.log('Year\tObliquity\tEccentricity\tVE\t\tSS\t\tAE\t\tWS\t\tPerihelion\tAphelion');

  const numYears = Math.min(
    cardinalData.VE.intervals.length,
    cardinalData.SS.intervals.length,
    cardinalData.AE.intervals.length,
    cardinalData.WS.intervals.length,
    perihelionIntervals.length,
    aphelionIntervals.length
  );

  for (let i = 0; i < numYears; i++) {
    const year = cardinalData.VE.events[i + 1]?.year || startYear + i + 1;
    // Get parameters for this year
    jumpToJulianDay(startmodelJD + (year - startmodelYear) * meansolaryearlengthinDays);
    forceSceneUpdate();

    console.log(
      `${year}\t` +
      `${(o.obliquityEarth || 0).toFixed(6)}\t` +
      `${(o.eccentricityEarth || 0).toFixed(8)}\t` +
      `${cardinalData.VE.intervals[i]?.toFixed(6) || 'N/A'}\t` +
      `${cardinalData.SS.intervals[i]?.toFixed(6) || 'N/A'}\t` +
      `${cardinalData.AE.intervals[i]?.toFixed(6) || 'N/A'}\t` +
      `${cardinalData.WS.intervals[i]?.toFixed(6) || 'N/A'}\t` +
      `${perihelionIntervals[i]?.toFixed(6) || 'N/A'}\t` +
      `${aphelionIntervals[i]?.toFixed(6) || 'N/A'}`
    );
  }

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return {
    cardinalData,
    perihelions,
    aphelions,
    siderealCrossings,
    means: {
      VE: cardinalData.VE.mean,
      SS: cardinalData.SS.mean,
      AE: cardinalData.AE.mean,
      WS: cardinalData.WS.mean,
      meanTropical: meanTropicalYear,
      perihelion: meanPerihelion,
      aphelion: meanAphelion,
      sidereal: meanSiderealYear
    },
    parameters: {
      obliquity,
      eccentricity
    }
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// DAY LENGTH DETECTION FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Detect the next sidereal noon after a given JD
 * Sidereal noon = when Earth completes one full 360° rotation.
 *
 * In this model, Earth rotates (tropicalYear + 1) times per tropical year.
 * This defines the sidereal day as: tropicalYear / (tropicalYear + 1) solar days.
 *
 * The relationship: solarDay = siderealDay × (tropicalYear + 1) / tropicalYear
 *
 * @param {number} startJD - Julian Day to start searching from
 * @param {boolean} debug - Enable debug output
 * @returns {object} - { jd, earthRotationAngle } at sidereal noon
 */
function siderealNoonForJD(startJD, debug = false) {
  // Earth's rotation angle at any time: θ = rotationSpeed × pos
  // rotationSpeed = 2π × (meansolaryearlengthinDays + 1) radians per year
  // One sidereal day = 2π radians of Earth rotation

  // Expected sidereal day in JD units:
  // siderealDay = 1 tropical year / (meansolaryearlengthinDays + 1) rotations
  //             = meansolaryearlengthinDays / (meansolaryearlengthinDays + 1) days
  const expectedSiderealDayJD = meansolaryearlengthinDays / (meansolaryearlengthinDays + 1);

  // Get Earth rotation angle at start
  jumpToJulianDay(startJD);
  forceSceneUpdate();

  // Earth's rotation angle relative to inertial frame
  // We use the planetObj rotation.y which tracks daily spin
  const startRotation = earth.planetObj.rotation.y;

  // Target: find when rotation increases by exactly 2π
  const targetRotation = startRotation + 2 * Math.PI;

  // Estimate when this occurs (approximately one stellar day later)
  const approxJD = startJD + expectedSiderealDayJD;

  // Search with fine resolution (1-minute steps)
  const step = 1 / (24 * 60);  // 1 minute in days
  const searchRange = 60;       // ±60 minutes around estimate

  let bestJD = approxJD;
  let bestDiff = Infinity;

  for (let k = -searchRange; k <= searchRange; k++) {
    const jd = approxJD + k * step;
    jumpToJulianDay(jd);
    forceSceneUpdate();

    const rotation = earth.planetObj.rotation.y;
    const diff = Math.abs(rotation - targetRotation);

    // Handle wrap-around (rotation might wrap at 2π)
    const diffWrapped = Math.min(diff, Math.abs(diff - 2 * Math.PI), Math.abs(diff + 2 * Math.PI));

    if (diffWrapped < bestDiff) {
      bestDiff = diffWrapped;
      bestJD = jd;
    }
  }

  // Refine with linear interpolation
  // Sample around best and interpolate zero-crossing
  const jd1 = bestJD - step;
  const jd2 = bestJD + step;

  jumpToJulianDay(jd1);
  forceSceneUpdate();
  const rot1 = earth.planetObj.rotation.y;

  jumpToJulianDay(jd2);
  forceSceneUpdate();
  const rot2 = earth.planetObj.rotation.y;

  // Interpolate to find when rotation = targetRotation
  // Handle wraparound
  let r1 = rot1, r2 = rot2;
  if (r2 < r1) r2 += 2 * Math.PI;  // Handle wrap

  // Linear interpolation
  const t = (targetRotation - r1) / (r2 - r1);
  const refinedJD = jd1 + t * (jd2 - jd1);

  if (debug) {
    console.log(`siderealNoonForJD: start=${startJD.toFixed(6)}, refined=${refinedJD.toFixed(6)}`);
    console.log(`  Interval: ${((refinedJD - startJD) * 86400).toFixed(3)} seconds`);
    console.log(`  Expected: ${(expectedSiderealDayJD * 86400).toFixed(3)} seconds`);
  }

  return {
    jd: refinedJD,
    earthRotationAngle: targetRotation % (2 * Math.PI)
  };
}

/**
 * Diagnostic function to log key rotation/position values over time
 * Helps understand what's happening with Earth rotation, Sun RA, and derived angles
 *
 * @param {number} startJD - Starting Julian Day
 * @param {number} hours - Number of hours to sample (default 25 for just over one day)
 */
function diagnoseDayRotation(startJD, hours = 25) {
  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           DAY ROTATION DIAGNOSTICS                                       ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log(`Starting from JD ${startJD.toFixed(6)}`);
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  const sunPos = new THREE.Vector3();
  const samples = [];

  // Vectors for comparing old vs new RA calculation
  const LOCAL = new THREE.Vector3();
  const DIRECTION = new THREE.Vector3();
  const ROT_MATRIX = new THREE.Matrix4();
  const SPHERICAL = new THREE.Spherical();
  const WOBBLE_POS = new THREE.Vector3();

  // Sample every hour
  console.log('Hour | Earth rot.y (°) | sun.ra (°) | sun.ra OLD (°) | sun World (°) | RA diff (°)');
  console.log('-----|-----------------|------------|----------------|---------------|------------');

  for (let h = 0; h <= hours; h++) {
    const jd = startJD + h / 24;
    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Get Earth's rotation angle (this is what we use for sidereal day)
    const earthRotY = earth.planetObj.rotation.y;

    // Get Sun's RA (computed from updatePositions - should be NEW method now)
    const sunRA = sun.ra;

    // Compute OLD method RA for comparison (worldToLocal)
    sun.planetObj.getWorldPosition(sunPos);
    LOCAL.copy(sunPos);
    earth.rotationAxis.worldToLocal(LOCAL);
    SPHERICAL.setFromVector3(LOCAL);
    const sunRA_OLD = SPHERICAL.theta;

    // Compute Sun's world angle (for Method C comparison)
    const sunWorldAngle = Math.atan2(sunPos.z, sunPos.x);

    // Compute hour angle (Earth rotation - Sun RA)
    let hourAngle = earthRotY - sunRA;
    // Normalize to [-π, π] for display
    let hourAngleNorm = hourAngle % (2 * Math.PI);
    while (hourAngleNorm > Math.PI) hourAngleNorm -= 2 * Math.PI;
    while (hourAngleNorm < -Math.PI) hourAngleNorm += 2 * Math.PI;

    // RA difference (new - old)
    const raDiff = sunRA - sunRA_OLD;

    samples.push({
      h,
      jd,
      earthRotY,
      sunRA,
      sunRA_OLD,
      sunWorldAngle,
      hourAngle,
      hourAngleNorm,
      raDiff
    });

    console.log(
      `${String(h).padStart(4)} | ` +
      `${(earthRotY * 180 / Math.PI).toFixed(4).padStart(15)} | ` +
      `${(sunRA * 180 / Math.PI).toFixed(4).padStart(10)} | ` +
      `${(sunRA_OLD * 180 / Math.PI).toFixed(4).padStart(14)} | ` +
      `${(sunWorldAngle * 180 / Math.PI).toFixed(4).padStart(13)} | ` +
      `${(raDiff * 180 / Math.PI).toFixed(6).padStart(11)}`
    );
  }

  // Calculate rates of change
  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('RATES OF CHANGE (per 24 hours):');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  const first = samples[0];
  const last24h = samples[24] || samples[samples.length - 1];

  const earthRotChange = last24h.earthRotY - first.earthRotY;
  const sunRAChange = last24h.sunRA - first.sunRA;
  const sunRA_OLD_Change = last24h.sunRA_OLD - first.sunRA_OLD;
  const sunWorldChange = last24h.sunWorldAngle - first.sunWorldAngle;
  const hourAngleChange = last24h.hourAngle - first.hourAngle;

  console.log(`  Earth rotation.y change: ${(earthRotChange * 180 / Math.PI).toFixed(6)}° = ${(earthRotChange / (2 * Math.PI)).toFixed(6)} rotations`);
  console.log(`  Sun RA change (NEW):     ${(sunRAChange * 180 / Math.PI).toFixed(6)}° = ${(sunRAChange / (2 * Math.PI)).toFixed(6)} rotations`);
  console.log(`  Sun RA change (OLD):     ${(sunRA_OLD_Change * 180 / Math.PI).toFixed(6)}° = ${(sunRA_OLD_Change / (2 * Math.PI)).toFixed(6)} rotations`);
  console.log(`  Sun World angle change:  ${(sunWorldChange * 180 / Math.PI).toFixed(6)}° = ${(sunWorldChange / (2 * Math.PI)).toFixed(6)} rotations`);
  console.log(`  Hour angle change:       ${(hourAngleChange * 180 / Math.PI).toFixed(6)}° = ${(hourAngleChange / (2 * Math.PI)).toFixed(6)} rotations`);
  console.log('');
  console.log(`  Expected Sun RA change:    ~0.9856°/day (360°/365.24)`);
  console.log(`  Expected for sidereal day: 360° per ~86164.1s = ${(360 * 86400 / 86164.1).toFixed(6)}° per 24h`);
  console.log(`  Expected for solar day:    360° per 86400s exactly`);
  console.log('');
  console.log(`  RA difference (NEW - OLD): ${((sunRAChange - sunRA_OLD_Change) * 180 / Math.PI).toFixed(6)}° per day`);
  console.log(`  If NEW = OLD, my fix is NOT being applied!`);
  console.log('');

  // Find when hour angle increases by 360° (one solar day)
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('SOLAR DAY DETECTION:');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  const targetHourAngle = first.hourAngle + 2 * Math.PI;
  console.log(`  Starting hour angle: ${(first.hourAngle * 180 / Math.PI).toFixed(6)}°`);
  console.log(`  Target hour angle:   ${(targetHourAngle * 180 / Math.PI).toFixed(6)}° (start + 360°)`);

  for (let i = 1; i < samples.length; i++) {
    if (samples[i].hourAngle >= targetHourAngle && samples[i - 1].hourAngle < targetHourAngle) {
      // Linear interpolation
      const t = (targetHourAngle - samples[i - 1].hourAngle) / (samples[i].hourAngle - samples[i - 1].hourAngle);
      const solarNoonJD = samples[i - 1].jd + t * (samples[i].jd - samples[i - 1].jd);
      const solarDaySeconds = (solarNoonJD - startJD) * 86400;
      console.log(`  Solar noon found between hour ${samples[i - 1].h} and ${samples[i].h}`);
      console.log(`  Interpolated JD: ${solarNoonJD.toFixed(6)}`);
      console.log(`  Solar day length: ${solarDaySeconds.toFixed(3)} seconds`);
      break;
    }
  }

  console.log('═══════════════════════════════════════════════════════════════════════════');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return samples;
}

/**
 * Diagnose the Sun's RA rate at different seasonal points throughout the year.
 * This helps identify whether the 44ms solar day bias is consistent or varies seasonally.
 *
 * The expected RA rate varies due to the equation of time:
 * - Faster around perihelion (January) and solstices
 * - Slower around aphelion (July) and equinoxes
 * - Annual average should match 360°/365.2422 days ≈ 0.9856°/day
 *
 * Call from console: diagnoseRARate()
 */
function diagnoseRARate() {
  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('                    SUN RA RATE SEASONAL DIAGNOSTIC                         ');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  // Expected mean RA rate
  const expectedMeanRARate = 360 / meansolaryearlengthinDays;  // ~0.9856°/day
  console.log(`Expected mean RA rate: ${expectedMeanRARate.toFixed(6)}°/day`);
  console.log(`Expected mean solar day: ${meanlengthofday.toFixed(6)} seconds`);
  console.log('');

  // Seasonal test points - 2000 dates (same year for consistency)
  const testPoints = [
    { name: 'March Equinox',     jd: 2451623.5 },   // March 20, 2000
    { name: 'June Solstice',     jd: 2451716.5 },   // June 21, 2000 (model start)
    { name: 'September Equinox', jd: 2451809.5 },   // September 22, 2000
    { name: 'December Solstice', jd: 2451899.5 },   // December 21, 2000
    { name: 'January Perihelion', jd: 2451550.5 },  // January 4, 2000 (near perihelion)
    { name: 'July Aphelion',     jd: 2451733.5 },   // July 4, 2000 (near aphelion)
  ];

  // Vectors for RA calculation
  const sunPos = new THREE.Vector3();
  const LOCAL = new THREE.Vector3();
  const SPHERICAL = new THREE.Spherical();

  // Store results for summary
  const results = [];

  console.log('Measuring RA rate at each seasonal point over 24 hours...');
  console.log('────────────────────────────────────────────────────────────────────────────');

  for (const point of testPoints) {
    // Measure at start of day
    jumpToJulianDay(point.jd);
    forceSceneUpdate();

    sun.planetObj.getWorldPosition(sunPos);
    LOCAL.copy(sunPos);
    earth.rotationAxis.worldToLocal(LOCAL);
    SPHERICAL.setFromVector3(LOCAL);
    const raStart = SPHERICAL.theta;
    const sunWorldStart = Math.atan2(sunPos.z, sunPos.x);
    const earthRotStart = earth.planetObj.rotation.y;

    // Measure at end of day (24 hours later)
    jumpToJulianDay(point.jd + 1.0);
    forceSceneUpdate();

    sun.planetObj.getWorldPosition(sunPos);
    LOCAL.copy(sunPos);
    earth.rotationAxis.worldToLocal(LOCAL);
    SPHERICAL.setFromVector3(LOCAL);
    const raEnd = SPHERICAL.theta;
    const sunWorldEnd = Math.atan2(sunPos.z, sunPos.x);
    const earthRotEnd = earth.planetObj.rotation.y;

    // Calculate rates (handle wrap-around)
    let raChange = raEnd - raStart;
    if (raChange < -Math.PI) raChange += 2 * Math.PI;
    if (raChange > Math.PI) raChange -= 2 * Math.PI;

    let worldChange = sunWorldEnd - sunWorldStart;
    if (worldChange < -Math.PI) worldChange += 2 * Math.PI;
    if (worldChange > Math.PI) worldChange -= 2 * Math.PI;

    const earthRotChange = earthRotEnd - earthRotStart;

    // Convert to degrees
    const raRateDeg = raChange * 180 / Math.PI;
    const worldRateDeg = worldChange * 180 / Math.PI;
    const earthRotDeg = earthRotChange * 180 / Math.PI;

    // Hour angle change (this determines solar day length)
    const haChange = earthRotChange - raChange;
    const solarDaySeconds = (2 * Math.PI / haChange) * 86400;

    // Deviation from expected
    const raDeviation = raRateDeg - expectedMeanRARate;
    const solarDayDeviation = solarDaySeconds - meanlengthofday;

    results.push({
      name: point.name,
      raRate: raRateDeg,
      worldRate: worldRateDeg,
      earthRot: earthRotDeg,
      solarDay: solarDaySeconds,
      raDeviation,
      solarDayDeviation
    });

    console.log(`\n${point.name}:`);
    console.log(`  Sun RA rate:         ${raRateDeg.toFixed(6)}°/day (deviation: ${raDeviation >= 0 ? '+' : ''}${raDeviation.toFixed(6)}°)`);
    console.log(`  Sun World rate:      ${worldRateDeg.toFixed(6)}°/day`);
    console.log(`  Earth rotation:      ${earthRotDeg.toFixed(4)}° (should be ~360.986°)`);
    console.log(`  Implied solar day:   ${solarDaySeconds.toFixed(3)}s (deviation: ${solarDayDeviation >= 0 ? '+' : ''}${solarDayDeviation.toFixed(3)}s)`);
  }

  console.log('\n════════════════════════════════════════════════════════════════════════════');
  console.log('                              SUMMARY                                        ');
  console.log('════════════════════════════════════════════════════════════════════════════');

  // Calculate averages
  const avgRARate = results.reduce((sum, r) => sum + r.raRate, 0) / results.length;
  const avgWorldRate = results.reduce((sum, r) => sum + r.worldRate, 0) / results.length;
  const avgSolarDay = results.reduce((sum, r) => sum + r.solarDay, 0) / results.length;

  console.log(`\nAverage RA rate:       ${avgRARate.toFixed(6)}°/day`);
  console.log(`Expected RA rate:      ${expectedMeanRARate.toFixed(6)}°/day`);
  console.log(`RA rate bias:          ${(avgRARate - expectedMeanRARate).toFixed(6)}°/day`);
  console.log(`\nAverage solar day:     ${avgSolarDay.toFixed(3)}s`);
  console.log(`Expected solar day:    ${meanlengthofday.toFixed(3)}s`);
  console.log(`Solar day bias:        ${(avgSolarDay - meanlengthofday).toFixed(3)}s`);

  // The key insight
  console.log('\n────────────────────────────────────────────────────────────────────────────');
  console.log('KEY COMPARISON:');
  console.log('  RA rate (from worldToLocal): measures in Earth\'s equatorial frame');
  console.log('  World rate (atan2 in XZ):    measures in fixed world frame');
  console.log(`  Difference:                  ${(avgRARate - avgWorldRate).toFixed(6)}°/day`);
  console.log('');
  console.log('  If RA rate > World rate, RA is picking up extra motion from Earth\'s wobble');
  console.log('────────────────────────────────────────────────────────────────────────────');

  // Also test over a full year to get true mean
  console.log('\n════════════════════════════════════════════════════════════════════════════');
  console.log('                    FULL YEAR RA ACCUMULATION TEST                          ');
  console.log('════════════════════════════════════════════════════════════════════════════');

  const yearStartJD = 2451545.0;  // J2000 epoch
  const yearDays = ASTRO_REFERENCE.tropicalYearMeanJ2000;

  // Test OLD method (worldToLocal)
  jumpToJulianDay(yearStartJD);
  forceSceneUpdate();
  sun.planetObj.getWorldPosition(sunPos);
  LOCAL.copy(sunPos);
  earth.rotationAxis.worldToLocal(LOCAL);
  SPHERICAL.setFromVector3(LOCAL);
  const yearRAStart_OLD = SPHERICAL.theta;
  const yearWorldStart = Math.atan2(sunPos.z, sunPos.x);
  const yearSunRA_Start = sun.ra;  // The actual value used by solarNoonForJD

  jumpToJulianDay(yearStartJD + yearDays);
  forceSceneUpdate();
  sun.planetObj.getWorldPosition(sunPos);
  LOCAL.copy(sunPos);
  earth.rotationAxis.worldToLocal(LOCAL);
  SPHERICAL.setFromVector3(LOCAL);
  const yearRAEnd_OLD = SPHERICAL.theta;
  const yearWorldEnd = Math.atan2(sunPos.z, sunPos.x);
  const yearSunRA_End = sun.ra;  // The actual value used by solarNoonForJD

  // Calculate changes for OLD method (worldToLocal)
  let yearRAChange_OLD = yearRAEnd_OLD - yearRAStart_OLD;
  if (yearRAChange_OLD < -Math.PI) yearRAChange_OLD += 2 * Math.PI;
  if (yearRAChange_OLD > Math.PI) yearRAChange_OLD -= 2 * Math.PI;

  // Calculate changes for sun.ra (the actual value used)
  let yearSunRAChange = yearSunRA_End - yearSunRA_Start;
  if (yearSunRAChange < -Math.PI) yearSunRAChange += 2 * Math.PI;
  if (yearSunRAChange > Math.PI) yearSunRAChange -= 2 * Math.PI;

  let yearWorldChange = yearWorldEnd - yearWorldStart;
  if (yearWorldChange < -Math.PI) yearWorldChange += 2 * Math.PI;
  if (yearWorldChange > Math.PI) yearWorldChange -= 2 * Math.PI;

  console.log(`\nAfter exactly 1 tropical year (${yearDays} days):`);
  console.log(`  OLD method (worldToLocal) net change: ${(yearRAChange_OLD * 180 / Math.PI).toFixed(6)}°`);
  console.log(`  sun.ra (actual used) net change:      ${(yearSunRAChange * 180 / Math.PI).toFixed(6)}°`);
  console.log(`  World angle net change:               ${(yearWorldChange * 180 / Math.PI).toFixed(6)}°`);
  console.log(`  (All should be ~0° for a perfect tropical year)`);

  // Daily excess for each method
  const dailyExcess_OLD = (yearRAChange_OLD * 180 / Math.PI) / yearDays;
  const dailyExcess_sunRA = (yearSunRAChange * 180 / Math.PI) / yearDays;

  console.log(`\nDaily excess:`);
  console.log(`  OLD method:  ${dailyExcess_OLD.toFixed(8)}°/day → ${(dailyExcess_OLD * 86400 / 360).toFixed(3)}s per solar day`);
  console.log(`  sun.ra:      ${dailyExcess_sunRA.toFixed(8)}°/day → ${(dailyExcess_sunRA * 86400 / 360).toFixed(3)}s per solar day`);
  console.log(`  Observed bias:                          ~0.044s per solar day`);

  // Test hour angle accumulation over 365 days
  console.log('\n════════════════════════════════════════════════════════════════════════════');
  console.log('                    HOUR ANGLE ACCUMULATION TEST                             ');
  console.log('════════════════════════════════════════════════════════════════════════════');
  console.log('Testing if hour angle accumulates 365×360° = 131400° over 365 solar days...');

  const haTestStart = yearStartJD;
  jumpToJulianDay(haTestStart);
  forceSceneUpdate();
  const haStart = earth.planetObj.rotation.y - sun.ra;
  const earthRotStart = earth.planetObj.rotation.y;
  const sunRAStart = sun.ra;

  // After 365 mean solar days (using the MODEL's mean solar day length)
  const testDays = 365;
  const expectedHAChange = testDays * 2 * Math.PI;  // 365 × 360° in radians
  // NOTE: meanlengthofday is the MODEL's expected mean solar day (~86400s at mean phase)
  // One JD = 86400 seconds exactly
  const testEndJD = haTestStart + testDays * (meanlengthofday / 86400);

  console.log(`  meanlengthofday = ${meanlengthofday.toFixed(6)}s`);
  console.log(`  Test duration = ${testDays} × ${meanlengthofday.toFixed(6)}s = ${(testDays * meanlengthofday).toFixed(3)}s`);
  console.log(`  Test duration in JD = ${(testEndJD - haTestStart).toFixed(9)} days`);

  jumpToJulianDay(testEndJD);
  forceSceneUpdate();
  const haEnd = earth.planetObj.rotation.y - sun.ra;
  const earthRotEnd = earth.planetObj.rotation.y;
  const sunRAEnd = sun.ra;

  const actualHAChange = haEnd - haStart;
  const earthRotChange = earthRotEnd - earthRotStart;
  const sunRAChange = sunRAEnd - sunRAStart;

  // Wrap sunRA change to be positive (should accumulate ~360°)
  let sunRAChangeDeg = sunRAChange * 180 / Math.PI;
  if (sunRAChangeDeg < 0) sunRAChangeDeg += 360;

  const haExcess = actualHAChange - expectedHAChange;
  const haExcessDeg = haExcess * 180 / Math.PI;
  const haExcessSec = haExcessDeg * (86400 / 360);  // Convert to time

  console.log(`\nAfter ${testDays} mean solar days (${(testEndJD - haTestStart).toFixed(6)} JD):`);
  console.log(`  Earth rotation:      ${(earthRotChange * 180 / Math.PI).toFixed(4)}° (expected: ${(testDays * 360.9856).toFixed(4)}°)`);
  console.log(`  Sun RA change:       ${sunRAChangeDeg.toFixed(4)}° (expected: ~${(testDays * 0.9856).toFixed(4)}°)`);
  console.log(`  Hour angle change:   ${(actualHAChange * 180 / Math.PI).toFixed(4)}° (expected: ${(expectedHAChange * 180 / Math.PI).toFixed(4)}°)`);
  console.log(`  Hour angle excess:   ${haExcessDeg.toFixed(6)}° = ${haExcessSec.toFixed(3)} seconds`);

  // The excess is ~360° which is 1 full day - this reveals a conceptual issue!
  // Let's check what we ACTUALLY need:
  // In N mean solar days, hour angle should increase by exactly N × 360°
  // HA = Earth_rot - Sun_RA
  // So: Earth_rot should increase by N × 360° + (Sun_RA increase)
  // Sun_RA increases by N/365.2422 × 360° over N solar days
  // So Earth_rot should increase by N × 360° × (1 + 1/365.2422) = N × 360.9856°

  const expectedEarthRot = testDays * 360.9856;  // Sidereal rotation rate
  const actualEarthRotDeg = earthRotChange * 180 / Math.PI;
  const earthRotError = actualEarthRotDeg - expectedEarthRot;

  console.log(`\n  Earth rotation error: ${earthRotError.toFixed(6)}° over ${testDays} days`);
  console.log(`  Per day: ${(earthRotError / testDays).toFixed(8)}°`);
  console.log(`  As time: ${(earthRotError / testDays * 86400 / 360).toFixed(6)}s per day`);

  // Direct test: measure exactly when HA increases by 360° from a known starting point
  console.log('\n════════════════════════════════════════════════════════════════════════════');
  console.log('                 DIRECT SOLAR DAY LENGTH MEASUREMENT                         ');
  console.log('════════════════════════════════════════════════════════════════════════════');

  // Use binary search to find exact JD when HA = startHA + 2π
  const directTestStartJD = yearStartJD;
  jumpToJulianDay(directTestStartJD);
  forceSceneUpdate();
  const directStartHA = earth.planetObj.rotation.y - sun.ra;
  const directTargetHA = directStartHA + 2 * Math.PI;

  // Binary search for the crossing point
  let lo = directTestStartJD + 0.99;  // Slightly less than 1 day
  let hi = directTestStartJD + 1.01;  // Slightly more than 1 day

  for (let iter = 0; iter < 50; iter++) {  // 50 iterations = ~1e-15 precision
    const mid = (lo + hi) / 2;
    jumpToJulianDay(mid);
    forceSceneUpdate();
    const midHA = earth.planetObj.rotation.y - sun.ra;

    if (midHA < directTargetHA) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  const directSolarDayJD = (lo + hi) / 2;
  const directSolarDaySeconds = (directSolarDayJD - directTestStartJD) * 86400;

  // Verify
  jumpToJulianDay(directSolarDayJD);
  forceSceneUpdate();
  const finalHA = earth.planetObj.rotation.y - sun.ra;
  const haError = (finalHA - directTargetHA) * 180 / Math.PI;

  console.log(`\nBinary search result at JD ${directTestStartJD.toFixed(4)} (J2000 epoch):`);
  console.log(`  Solar day length:    ${directSolarDaySeconds.toFixed(9)} seconds`);
  console.log(`  Expected (model):    ${meanlengthofday.toFixed(9)} seconds`);
  console.log(`  Difference:          ${((directSolarDaySeconds - meanlengthofday) * 1000).toFixed(6)} ms`);
  console.log(`  HA error at end:     ${haError.toFixed(12)}° (should be ~0)`);

  // Also test at June Solstice for comparison
  const solsticeJD = 2451716.5;  // June 21, 2000
  jumpToJulianDay(solsticeJD);
  forceSceneUpdate();
  const solsticeStartHA = earth.planetObj.rotation.y - sun.ra;
  const solsticeTargetHA = solsticeStartHA + 2 * Math.PI;

  lo = solsticeJD + 0.99;
  hi = solsticeJD + 1.01;

  for (let iter = 0; iter < 50; iter++) {
    const mid = (lo + hi) / 2;
    jumpToJulianDay(mid);
    forceSceneUpdate();
    const midHA = earth.planetObj.rotation.y - sun.ra;

    if (midHA < solsticeTargetHA) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  const solsticeSolarDayJD = (lo + hi) / 2;
  const solsticeSolarDaySeconds = (solsticeSolarDayJD - solsticeJD) * 86400;

  console.log(`\nBinary search result at June Solstice (JD ${solsticeJD}):`);
  console.log(`  Solar day length:    ${solsticeSolarDaySeconds.toFixed(9)} seconds`);
  console.log(`  Expected (EoT ~+17s): ~86417 seconds`);
  console.log(`  Difference from mean: ${((solsticeSolarDaySeconds - meanlengthofday) * 1000).toFixed(3)} ms`);

  // Now measure the MEAN over a full year using binary search for each day
  // Use cumulative sun.ra to avoid wrap-around issues
  console.log('\n════════════════════════════════════════════════════════════════════════════');
  console.log('              FULL YEAR MEAN SOLAR DAY (HIGH PRECISION)                      ');
  console.log('════════════════════════════════════════════════════════════════════════════');
  console.log('Measuring 365 consecutive solar days with binary search precision...');

  const fullYearStartJD = yearStartJD;
  let currentJD = fullYearStartJD;
  const solarDayLengths = [];

  // Track cumulative sun.ra to avoid wrap-around issues
  let cumulativeSunRA = 0;
  let lastSunRA = null;

  // Helper to get cumulative hour angle (handles sun.ra wrap-around)
  const getCumulativeHA = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Track cumulative sun.ra
    if (lastSunRA !== null) {
      let deltaRA = sun.ra - lastSunRA;
      // Handle wrap-around: if delta is large negative, sun.ra wrapped from ~2π to ~0
      if (deltaRA < -Math.PI) deltaRA += 2 * Math.PI;
      // If delta is large positive, sun.ra wrapped from ~0 to ~2π (shouldn't happen going forward)
      if (deltaRA > Math.PI) deltaRA -= 2 * Math.PI;
      cumulativeSunRA += deltaRA;
    }
    lastSunRA = sun.ra;

    return earth.planetObj.rotation.y - cumulativeSunRA;
  };

  // Initialize cumulative tracking
  const initHA = getCumulativeHA(currentJD);

  for (let day = 0; day < 365; day++) {
    // Reset to current position and get starting HA
    const savedCumulativeRA = cumulativeSunRA;
    const savedLastRA = lastSunRA;

    const dayStartHA = getCumulativeHA(currentJD);
    const dayTargetHA = dayStartHA + 2 * Math.PI;

    // Binary search for next crossing
    let dayLo = currentJD + 0.99;
    let dayHi = currentJD + 1.01;

    for (let iter = 0; iter < 40; iter++) {
      const mid = (dayLo + dayHi) / 2;

      // Reset cumulative tracking for each probe
      cumulativeSunRA = savedCumulativeRA;
      lastSunRA = savedLastRA;
      getCumulativeHA(currentJD);  // Re-establish baseline

      const midHA = getCumulativeHA(mid);

      if (midHA < dayTargetHA) {
        dayLo = mid;
      } else {
        dayHi = mid;
      }
    }

    const nextJD = (dayLo + dayHi) / 2;
    const dayLength = (nextJD - currentJD) * 86400;

    // Sanity check
    if (dayLength < 86300 || dayLength > 86500) {
      console.warn(`  Day ${day}: Anomalous length ${dayLength.toFixed(1)}s`);
    }

    solarDayLengths.push(dayLength);

    // Move to next day - update cumulative tracking properly
    cumulativeSunRA = savedCumulativeRA;
    lastSunRA = savedLastRA;
    getCumulativeHA(currentJD);
    getCumulativeHA(nextJD);
    currentJD = nextJD;

    if (day % 50 === 0) {
      console.log(`  Progress: ${day}/365...`);
    }
  }

  const yearMeanSolarDay = solarDayLengths.reduce((a, b) => a + b, 0) / solarDayLengths.length;
  const yearMinSolarDay = Math.min(...solarDayLengths);
  const yearMaxSolarDay = Math.max(...solarDayLengths);

  // Count anomalies
  const anomalies = solarDayLengths.filter(d => d < 86300 || d > 86500).length;

  console.log(`\nFull year results (365 days with binary search):`);
  console.log(`  Mean solar day:      ${yearMeanSolarDay.toFixed(9)} seconds`);
  console.log(`  Expected (model):    ${meanlengthofday.toFixed(9)} seconds`);
  console.log(`  BIAS:                ${((yearMeanSolarDay - meanlengthofday) * 1000).toFixed(6)} ms`);
  console.log(`  Min solar day:       ${yearMinSolarDay.toFixed(3)} seconds`);
  console.log(`  Max solar day:       ${yearMaxSolarDay.toFixed(3)} seconds`);
  console.log(`  Range (EoT):         ${(yearMaxSolarDay - yearMinSolarDay).toFixed(3)} seconds`);
  console.log(`  Anomalies:           ${anomalies} days outside ±50s range`);

  console.log('\n═══════════════════════════════════════════════════════════════════════════');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;
}

/**
 * Detect the next solar noon after a given JD
 * Solar noon = when the Sun crosses the meridian
 *
 * This implementation uses binary search with cumulative RA tracking to find
 * when the hour angle has increased by exactly 2π (360°).
 *
 * Uses cumulative sun.ra tracking to handle wrap-around when sun.ra crosses
 * from ~2π back to ~0 (which happens once per year).
 *
 * @param {number} startJD - Julian Day to start searching from
 * @param {boolean} debug - Enable debug output
 * @param {object} cumulativeState - Optional state for tracking cumulative RA across calls
 * @returns {object} - { jd, sunRA, cumulativeState } at solar noon
 */
function solarNoonForJD(startJD, debug = false, cumulativeState = null) {
  // Initialize or use provided cumulative state
  let cumulativeSunRA = cumulativeState ? cumulativeState.cumulativeSunRA : 0;
  let lastSunRA = cumulativeState ? cumulativeState.lastSunRA : null;

  // Helper to get cumulative hour angle (handles sun RA wrap-around)
  // Uses calculateRAFromWobbleCenter() to eliminate the ~44ms/day parallax
  // artifact caused by Earth's precession wobble motion.
  const getCumulativeHA = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Get sun RA from wobble center (not Earth position) for accurate solar day
    const sunRAFromWobble = calculateRAFromWobbleCenter(sun);

    // Track cumulative sun RA
    if (lastSunRA !== null) {
      let deltaRA = sunRAFromWobble - lastSunRA;
      // Handle wrap-around: if delta is large negative, RA wrapped from ~2π to ~0
      if (deltaRA < -Math.PI) deltaRA += 2 * Math.PI;
      // If delta is large positive, RA wrapped from ~0 to ~2π (shouldn't happen going forward)
      if (deltaRA > Math.PI) deltaRA -= 2 * Math.PI;
      cumulativeSunRA += deltaRA;
    }
    lastSunRA = sunRAFromWobble;

    return earth.planetObj.rotation.y - cumulativeSunRA;
  };

  // Save state at start for binary search resets
  const savedCumulativeRA = cumulativeSunRA;
  const savedLastRA = lastSunRA;

  // Get starting hour angle
  const startHA = getCumulativeHA(startJD);
  const targetHA = startHA + 2 * Math.PI;  // Target: start + 360°

  // Binary search for the crossing point
  let lo = startJD + 0.99;  // Slightly less than 1 day
  let hi = startJD + 1.01;  // Slightly more than 1 day

  for (let iter = 0; iter < 40; iter++) {  // 40 iterations = sub-microsecond precision
    const mid = (lo + hi) / 2;

    // Reset cumulative tracking for each probe
    cumulativeSunRA = savedCumulativeRA;
    lastSunRA = savedLastRA;
    getCumulativeHA(startJD);  // Re-establish baseline

    const midHA = getCumulativeHA(mid);

    if (midHA < targetHA) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  const refinedJD = (lo + hi) / 2;

  // Update cumulative state for the final position
  cumulativeSunRA = savedCumulativeRA;
  lastSunRA = savedLastRA;
  getCumulativeHA(startJD);
  getCumulativeHA(refinedJD);

  if (debug) {
    const finalHA = earth.planetObj.rotation.y - cumulativeSunRA;
    console.log(`solarNoonForJD: start=${startJD.toFixed(6)}, refined=${refinedJD.toFixed(6)}`);
    console.log(`  Interval: ${((refinedJD - startJD) * 86400).toFixed(3)} seconds`);
    console.log(`  Start HA: ${(startHA * 180 / Math.PI).toFixed(4)}°`);
    console.log(`  Target HA: ${(targetHA * 180 / Math.PI).toFixed(4)}°`);
    console.log(`  Final HA: ${(finalHA * 180 / Math.PI).toFixed(4)}°`);
    console.log(`  HA diff from target: ${((finalHA - targetHA) * 180 / Math.PI).toFixed(6)}° (should be ~0)`);
  }

  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  return {
    jd: refinedJD,
    sunRA: (calculateRAFromWobbleCenter(sun) * 180 / Math.PI + 360) % 360,
    cumulativeState: { cumulativeSunRA, lastSunRA }
  };
}

/**
 * Find next solar noon after startJD - Method B (fixed reference frame)
 *
 * This method uses the Sun's world position angle from the origin (wobble center)
 * instead of sun.ra (which is measured from Earth's wobbling position).
 *
 * The wobble center is fixed at the origin, so this gives the "true" solar day
 * unaffected by Earth's precession wobble.
 *
 * @param {number} startJD - Julian Day to start from
 * @param {boolean} debug - Enable debug output
 * @returns {object} - { jd, sunWorldAngle } at solar noon
 */
function solarNoonForJDMethodB(startJD, debug = false) {
  // Expected solar day ≈ 1.0 Julian days
  const expectedSolarDayJD = 1.0;
  const approxJD = startJD + expectedSolarDayJD;

  // Reusable vector for Sun's world position
  const SUN_WORLD_POS = new THREE.Vector3();

  // Helper function: get hour angle using Sun's world position from origin
  // World angle = Earth's rotation - Sun's world angle (both in radians)
  const getHourAngleB = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Get Sun's world position (relative to origin = wobble center)
    sun.planetObj.getWorldPosition(SUN_WORLD_POS);

    // Sun's angle in world coordinates (from origin)
    const sunWorldAngle = Math.atan2(SUN_WORLD_POS.z, SUN_WORLD_POS.x);

    // Hour angle from fixed reference frame
    return earth.planetObj.rotation.y - sunWorldAngle;
  };

  // Get starting hour angle
  const startHA = getHourAngleB(startJD);
  const targetHA = startHA + 2 * Math.PI;  // Target: start + 360°

  // Search with 1-minute resolution - start with ±2 hours, expand if needed
  const step = 1 / (24 * 60);  // 1 minute in days
  let searchRange = 120;        // ±2 hours initially

  let crossingIdx = -1;
  let samples = [];

  // Try progressively wider search ranges if crossing not found
  while (crossingIdx === -1 && searchRange <= 360) {  // Max ±6 hours
    samples = [];
    for (let k = -searchRange; k <= searchRange; k++) {
      const jd = approxJD + k * step;
      const ha = getHourAngleB(jd);
      samples.push({ k, jd, ha });
    }

    // Find crossing where hour angle crosses targetHA
    for (let i = 1; i < samples.length; i++) {
      if (samples[i - 1].ha < targetHA && samples[i].ha >= targetHA) {
        crossingIdx = i;
        break;
      }
    }

    if (crossingIdx === -1) {
      searchRange += 60;  // Expand by 1 hour
    }
  }

  if (crossingIdx === -1) {
    // Last resort fallback: find sample closest to target
    let minDiff = Infinity;
    for (let i = 0; i < samples.length; i++) {
      const diff = Math.abs(samples[i].ha - targetHA);
      if (diff < minDiff) {
        minDiff = diff;
        crossingIdx = i;
      }
    }
  }

  // Phase 2: Linear interpolation for precise crossing
  let refinedJD;

  if (crossingIdx > 0 && crossingIdx < samples.length) {
    const ha1 = samples[crossingIdx - 1].ha;
    const ha2 = samples[crossingIdx].ha;
    const jd1 = samples[crossingIdx - 1].jd;
    const jd2 = samples[crossingIdx].jd;

    // Linear interpolation to find when ha = targetHA
    const t = (targetHA - ha1) / (ha2 - ha1);
    refinedJD = jd1 + t * (jd2 - jd1);
  } else {
    refinedJD = samples[crossingIdx].jd;
  }

  // Sanity check: result should be roughly 1 day after start
  const intervalSeconds = (refinedJD - startJD) * 86400;
  if (intervalSeconds < 86000 || intervalSeconds > 86800) {
    // Result is suspicious - try direct calculation at expected time
    if (debug) {
      console.warn(`solarNoonForJDMethodB: suspicious interval ${intervalSeconds.toFixed(1)}s, using expected time`);
    }
    refinedJD = approxJD;
  }

  if (debug) {
    const finalHA = getHourAngleB(refinedJD);
    console.log(`solarNoonForJDMethodB: start=${startJD.toFixed(6)}, refined=${refinedJD.toFixed(6)}`);
    console.log(`  Interval: ${((refinedJD - startJD) * 86400).toFixed(3)} seconds`);
    console.log(`  Start HA: ${(startHA * 180 / Math.PI).toFixed(4)}°`);
    console.log(`  Target HA: ${(targetHA * 180 / Math.PI).toFixed(4)}°`);
    console.log(`  Final HA: ${(finalHA * 180 / Math.PI).toFixed(4)}°`);
    console.log(`  HA diff from target: ${((finalHA - targetHA) * 180 / Math.PI).toFixed(6)}° (should be ~0)`);
  }

  jumpToJulianDay(refinedJD);
  forceSceneUpdate();

  // Get final sun world angle
  sun.planetObj.getWorldPosition(SUN_WORLD_POS);
  const finalSunAngle = Math.atan2(SUN_WORLD_POS.z, SUN_WORLD_POS.x);

  return {
    jd: refinedJD,
    sunWorldAngle: (finalSunAngle * 180 / Math.PI + 360) % 360
  };
}

/**
 * Solar noon detection using sun.ra directly from Earth's actual position (Method D)
 * This measures from Earth's real position, INCLUDING the wobble parallax effect.
 * Unlike Method A (which uses wobble center), this captures the full Earth-frame experience.
 *
 * @param {number} startJD - Julian day to start from
 * @param {boolean} debug - Enable debug output
 * @param {object|null} cumulativeState - State from previous call for tracking RA wrap-around
 * @returns {object} - { jd, cumulativeState } at solar noon
 */
function solarNoonForJDMethodD(startJD, debug = false, cumulativeState = null) {
  // Initialize or use provided cumulative state
  let cumulativeSunRA = cumulativeState ? cumulativeState.cumulativeSunRA : 0;
  let lastSunRA = cumulativeState ? cumulativeState.lastSunRA : null;

  // Helper to get cumulative hour angle using sun.ra directly (Earth's actual position)
  // This INCLUDES the wobble parallax effect, unlike Method A which uses wobble center
  const getCumulativeHA = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();

    // Get sun.ra directly - this is calculated from Earth's actual position
    const sunRA = sun.ra;

    // Track cumulative sun RA
    if (lastSunRA !== null) {
      let deltaRA = sunRA - lastSunRA;
      // Handle wrap-around: if delta is large negative, RA wrapped from ~2π to ~0
      if (deltaRA < -Math.PI) deltaRA += 2 * Math.PI;
      // If delta is large positive, RA wrapped from ~0 to ~2π (shouldn't happen going forward)
      if (deltaRA > Math.PI) deltaRA -= 2 * Math.PI;
      cumulativeSunRA += deltaRA;
    }
    lastSunRA = sunRA;

    return earth.planetObj.rotation.y - cumulativeSunRA;
  };

  // Save state at start for binary search resets
  const savedCumulativeRA = cumulativeSunRA;
  const savedLastRA = lastSunRA;

  // Get starting hour angle
  const startHA = getCumulativeHA(startJD);
  const targetHA = startHA + 2 * Math.PI;  // Target: start + 360°

  // Binary search for the crossing point
  let lo = startJD + 0.99;  // Slightly less than 1 day
  let hi = startJD + 1.01;  // Slightly more than 1 day

  for (let iter = 0; iter < 40; iter++) {  // 40 iterations = sub-microsecond precision
    const mid = (lo + hi) / 2;

    // Reset cumulative tracking for each probe
    cumulativeSunRA = savedCumulativeRA;
    lastSunRA = savedLastRA;
    getCumulativeHA(startJD);  // Re-establish baseline

    const midHA = getCumulativeHA(mid);

    if (midHA < targetHA) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  const refinedJD = (lo + hi) / 2;

  // Update cumulative state for the final position
  cumulativeSunRA = savedCumulativeRA;
  lastSunRA = savedLastRA;
  getCumulativeHA(startJD);
  getCumulativeHA(refinedJD);

  if (debug) {
    const finalHA = getCumulativeHA(refinedJD);
    console.log(`solarNoonForJDMethodD: start=${startJD.toFixed(6)}, refined=${refinedJD.toFixed(6)}`);
    console.log(`  Interval: ${((refinedJD - startJD) * 86400).toFixed(3)} seconds`);
  }

  return {
    jd: refinedJD,
    cumulativeState: {
      cumulativeSunRA,
      lastSunRA
    }
  };
}

/**
 * Analyze sidereal day length over a period
 * Measures the interval between successive sidereal noons (Earth completing one 360° rotation)
 *
 * In this model, Earth rotates (tropicalYear + 1) times per tropical year.
 * This defines the sidereal day: siderealDay = tropicalYear / (tropicalYear + 1) solar days
 *
 * The relationship solarDay = siderealDay × (tropicalYear + 1) / tropicalYear holds exactly.
 *
 * @param {number} startYear - Year to analyze (measures one tropical year of sidereal days)
 */
async function analyzeSiderealDay(startYear) {
  startYear = startYear || o.calibrationYearStart;

  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           SIDEREAL DAY LENGTH ANALYSIS                                   ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing year ${startYear}`);
  console.log('Sidereal day = time for Earth to rotate 360° relative to vernal equinox');
  console.log('Formula: siderealDay = tropicalYear / (tropicalYear + 1) × 86400 seconds');
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // Start from June solstice of start year
  const startSolstice = solsticeForYear(startYear);
  if (!startSolstice) {
    console.error('Could not find start solstice');
    return;
  }

  // Unlike solar day (which varies ±20-25s due to equation of time), sidereal day shows
  // zero variation throughout the year - every day is identical. This is because sidereal
  // day measures pure rotation (earth.planetObj.rotation.y), without any projection onto
  // the equatorial plane or dependence on orbital position.
  // Therefore, 30 days is sufficient to characterize the sidereal day.
  const numDays = 30;
  const intervals = [];

  console.log(`Measuring ${numDays} sidereal day intervals starting from JD ${startSolstice.jd.toFixed(4)}...`);
  console.log('Note: Sidereal day has no daily variation (unlike solar day), so 30 days is sufficient.');

  let prevJD = startSolstice.jd;

  for (let i = 0; i < numDays; i++) {
    const result = siderealNoonForJD(prevJD);
    if (result) {
      const interval = (result.jd - prevJD) * 86400;  // Convert to seconds
      intervals.push(interval);
      prevJD = result.jd;
    }

    // Progress indicator
    if (i % 10 === 0) {
      console.log(`  Progress: ${i}/${numDays} days...`);
      await new Promise(r => setTimeout(r, 10));
    }
  }

  // Calculate statistics
  const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
  const min = Math.min(...intervals);
  const max = Math.max(...intervals);

  // Reference value - IAU sidereal day
  const expectedSidereal = ASTRO_REFERENCE.siderealDayJ2000;

  // Derived value from model constants
  const derivedSidereal = meansolaryearlengthinDays / (meansolaryearlengthinDays + 1) * 86400;

  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('SIDEREAL DAY RESULTS');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`  Measurements:    ${intervals.length} sidereal days`);
  console.log(`  Mean:            ${mean.toFixed(6)} seconds`);
  console.log(`  Min:             ${min.toFixed(6)} seconds`);
  console.log(`  Max:             ${max.toFixed(6)} seconds`);
  console.log(`  Range:           ${(max - min).toFixed(6)} seconds`);
  console.log('');
  console.log('───────────────────────────────────────────────────────────────────────────');
  console.log('COMPARISON');
  console.log('───────────────────────────────────────────────────────────────────────────');
  console.log(`  Measured:         ${mean.toFixed(6)} seconds`);
  console.log(`  Derived (model):  ${derivedSidereal.toFixed(6)} seconds`);
  console.log(`  IAU reference:    ${expectedSidereal} seconds`);
  console.log('');
  console.log(`  Measured - Derived:  ${((mean - derivedSidereal) * 1000).toFixed(6)} ms`);
  console.log(`  Measured - IAU:      ${((mean - expectedSidereal) * 1000).toFixed(3)} ms`);
  console.log(`  Derived - IAU:       ${((derivedSidereal - expectedSidereal) * 1000).toFixed(3)} ms`);
  console.log('═══════════════════════════════════════════════════════════════════════════');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return {
    count: intervals.length,
    mean,
    min,
    max,
    derived: derivedSidereal,
    intervals
  };
}

/**
 * Analyze mean solar day length over a period
 * Measures the interval between successive solar noons
 * Also derives solar day from sidereal day + tropical year (Method B)
 *
 * @param {number} startYear - Start year
 * @param {number} endYear - End year
 */
async function analyzeSolarDay(startYear, endYear) {
  startYear = startYear || o.calibrationYearStart;
  endYear = endYear || o.calibrationYearEnd;

  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           MEAN SOLAR DAY LENGTH ANALYSIS                                 ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing year ${startYear} (one tropical year of daily measurements)...`);
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // Start from June solstice of start year
  const startSolstice = solsticeForYear(startYear);
  if (!startSolstice) {
    console.error('Could not find start solstice');
    return;
  }

  // Measure solar days over one tropical year
  const numDays = Math.floor(meansolaryearlengthinDays);  // ~365 solar days per year
  const solarIntervals = [];      // Method A: Wobble-center RA (calculateRAFromWobbleCenter)
  const solarIntervalsB = [];     // Method C: Fixed-frame (sun world angle from origin)
  const siderealIntervals = [];   // For Method B derivation
  const solarIntervalsD = [];     // Method D: Earth-frame RA (sun.ra directly) with cumulative tracking

  // First, find the first solar noon AFTER the solstice to establish a baseline
  // This ensures we start from an actual solar noon, not an arbitrary time
  console.log(`Finding first solar noon after solstice JD ${startSolstice.jd.toFixed(4)}...`);

  // Find first solar noon - we just use the solstice JD as our starting point
  // The solarNoonForJD function will find the next noon from any starting point
  // For the first measurement, we use a modified search that finds the nearest noon
  // Uses calculateRAFromWobbleCenter() for consistent wobble-corrected RA
  const findFirstSolarNoon = (startJD) => {
    // Get hour angle at start (using wobble-center RA for accuracy)
    jumpToJulianDay(startJD);
    forceSceneUpdate();
    const startHA = earth.planetObj.rotation.y - calculateRAFromWobbleCenter(sun);

    // Find nearest multiple of 2π (nearest solar noon)
    // Hour angle at solar noon is a multiple of 2π
    const nearestNoonHA = Math.round(startHA / (2 * Math.PI)) * (2 * Math.PI);

    // Search around this time to find the exact crossing
    const step = 1 / (24 * 60);  // 1 minute
    let bestJD = startJD;
    let bestDiff = Infinity;

    // Search ±12 hours to find the nearest noon
    for (let k = -12 * 60; k <= 12 * 60; k++) {
      const jd = startJD + k * step;
      jumpToJulianDay(jd);
      forceSceneUpdate();
      const ha = earth.planetObj.rotation.y - calculateRAFromWobbleCenter(sun);
      const diff = Math.abs(ha - nearestNoonHA);

      if (diff < bestDiff) {
        bestDiff = diff;
        bestJD = jd;
      }
    }

    return bestJD;
  };

  const firstSolarNoon = findFirstSolarNoon(startSolstice.jd);
  console.log(`First solar noon at JD ${firstSolarNoon.toFixed(6)}`);
  console.log(`Measuring ${numDays} solar day intervals...`);

  let prevSolarJD = firstSolarNoon;
  let prevSolarJD_B = firstSolarNoon;  // Method C uses same starting point
  let prevSolarJD_D = firstSolarNoon;  // Method D uses same starting point
  let prevSiderealJD = startSolstice.jd;
  let cumulativeState = null;  // Track cumulative RA state across calls (Method A)
  let cumulativeStateD = null; // Track cumulative RA state for Method D

  for (let i = 0; i < numDays; i++) {
    // Method A: Wobble-center RA (calculateRAFromWobbleCenter) - eliminates wobble parallax
    const solarResult = solarNoonForJD(prevSolarJD, false, cumulativeState);
    if (solarResult) {
      const interval = (solarResult.jd - prevSolarJD) * 86400;  // Convert to seconds
      solarIntervals.push(interval);
      prevSolarJD = solarResult.jd;
      cumulativeState = solarResult.cumulativeState;  // Carry forward cumulative state
    }

    // Method C: Fixed-frame solar noon detection (sun world angle from origin)
    const solarResultB = solarNoonForJDMethodB(prevSolarJD_B);
    if (solarResultB) {
      const interval = (solarResultB.jd - prevSolarJD_B) * 86400;
      solarIntervalsB.push(interval);
      prevSolarJD_B = solarResultB.jd;
    }

    // Method D: Earth-frame RA (sun.ra directly) - includes wobble parallax
    const solarResultD = solarNoonForJDMethodD(prevSolarJD_D, false, cumulativeStateD);
    if (solarResultD) {
      const interval = (solarResultD.jd - prevSolarJD_D) * 86400;
      solarIntervalsD.push(interval);
      prevSolarJD_D = solarResultD.jd;
      cumulativeStateD = solarResultD.cumulativeState;
    }

    // Also measure sidereal day for Method B derivation
    const siderealResult = siderealNoonForJD(prevSiderealJD);
    if (siderealResult) {
      const interval = (siderealResult.jd - prevSiderealJD) * 86400;
      siderealIntervals.push(interval);
      prevSiderealJD = siderealResult.jd;
    }

    // Progress indicator
    if (i % 50 === 0) {
      console.log(`  Progress: ${i}/${numDays} days...`);
      await new Promise(r => setTimeout(r, 10));
    }
  }

  // Calculate statistics for Method A (wobble-center RA)
  const meanSolar = solarIntervals.reduce((a, b) => a + b, 0) / solarIntervals.length;
  const minSolar = Math.min(...solarIntervals);
  const maxSolar = Math.max(...solarIntervals);

  // Calculate statistics for Method C (fixed-frame)
  const meanSolarB = solarIntervalsB.reduce((a, b) => a + b, 0) / solarIntervalsB.length;
  const minSolarB = Math.min(...solarIntervalsB);
  const maxSolarB = Math.max(...solarIntervalsB);

  // Calculate statistics for Method D (Earth-frame sun.ra)
  const meanSolarD = solarIntervalsD.reduce((a, b) => a + b, 0) / solarIntervalsD.length;
  const minSolarD = Math.min(...solarIntervalsD);
  const maxSolarD = Math.max(...solarIntervalsD);

  // Calculate Method B (derived from sidereal)
  const meanSidereal = siderealIntervals.reduce((a, b) => a + b, 0) / siderealIntervals.length;

  // Get tropical year for derivation
  const tropicalYearDays = meansolaryearlengthinDays;  // Use model value for now

  // Formula: solarDay = siderealDay × (tropicalYear + 1) / tropicalYear
  const derivedSolar = meanSidereal * (tropicalYearDays + 1) / tropicalYearDays;

  // Reference value
  const expectedSolarDay = meanlengthofday;  // From model constants

  // Find outliers for diagnostics
  const sortedIntervals = [...solarIntervals].sort((a, b) => a - b);
  const median = sortedIntervals[Math.floor(sortedIntervals.length / 2)];

  // Count intervals in different ranges
  const near86400 = solarIntervals.filter(i => Math.abs(i - 86400) < 50).length;
  const outliers = solarIntervals.filter(i => Math.abs(i - 86400) > 50);

  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('METHOD A: DIRECT SOLAR NOON DETECTION');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log(`  Measurements:    ${solarIntervals.length} solar days`);
  console.log(`  Mean:            ${meanSolar.toFixed(6)} seconds`);
  console.log(`  Median:          ${median.toFixed(6)} seconds`);
  console.log(`  Min:             ${minSolar.toFixed(6)} seconds`);
  console.log(`  Max:             ${maxSolar.toFixed(6)} seconds`);
  console.log(`  Range:           ${(maxSolar - minSolar).toFixed(6)} seconds`);
  console.log(`  Near 86400 (±50s): ${near86400}/${solarIntervals.length}`);
  if (outliers.length > 0 && outliers.length <= 10) {
    console.log(`  Outliers: ${outliers.map(o => o.toFixed(1)).join(', ')}`);
  } else if (outliers.length > 10) {
    console.log(`  Outliers: ${outliers.length} values outside ±50s range`);
  }

  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('EQUATION OF TIME - Daily Variation from Mean');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('Day# | Day Length (s) | Diff from 86400 | Cumulative Drift');
  console.log('-----|----------------|-----------------|------------------');

  // Show key points throughout the year (every ~30 days + extremes)
  let cumulativeDrift = 0;
  let minDay = { idx: 0, val: Infinity };
  let maxDay = { idx: 0, val: -Infinity };

  for (let i = 0; i < solarIntervals.length; i++) {
    const diff = solarIntervals[i] - 86400;
    cumulativeDrift += diff;

    if (solarIntervals[i] < minDay.val) {
      minDay = { idx: i, val: solarIntervals[i], cumDrift: cumulativeDrift };
    }
    if (solarIntervals[i] > maxDay.val) {
      maxDay = { idx: i, val: solarIntervals[i], cumDrift: cumulativeDrift };
    }

    // Show every 30 days + first and last
    if (i === 0 || i === solarIntervals.length - 1 || i % 30 === 0) {
      console.log(
        `${String(i).padStart(4)} | ` +
        `${solarIntervals[i].toFixed(3).padStart(14)} | ` +
        `${(diff >= 0 ? '+' : '') + diff.toFixed(3).padStart(14)} | ` +
        `${(cumulativeDrift >= 0 ? '+' : '') + cumulativeDrift.toFixed(3).padStart(15)}`
      );
    }
  }

  // Calculate dates for extremes (days are counted from the summer solstice start)
  const minDayJD = firstSolarNoon + minDay.idx;
  const maxDayJD = firstSolarNoon + maxDay.idx;
  const minDayDate = jdToDateString(minDayJD).date;
  const maxDayDate = jdToDateString(maxDayJD).date;

  console.log('');
  console.log('Extremes (days counted from summer solstice):');
  console.log(`  Shortest day: Day ${minDay.idx} (${minDayDate}) = ${minDay.val.toFixed(3)}s (${(minDay.val - 86400).toFixed(3)}s from 86400)`);
  console.log(`  Longest day:  Day ${maxDay.idx} (${maxDayDate}) = ${maxDay.val.toFixed(3)}s (${(maxDay.val - 86400).toFixed(3)}s from 86400)`);

  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('METHOD B: DERIVED FROM SIDEREAL DAY');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('Measures Earth\'s rotation relative to distant stars (sidereal day), then');
  console.log('derives the solar day using: solarDay = siderealDay × (year+1) / year');
  console.log('');
  console.log(`  Sidereal mean:   ${meanSidereal.toFixed(6)} seconds`);
  console.log(`  Tropical year:   ${tropicalYearDays.toFixed(9)} days`);
  console.log(`  Derived solar:   ${derivedSolar.toFixed(6)} seconds`);

  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('METHOD C: FIXED-FRAME SOLAR NOON DETECTION');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('Measures Sun position in world coordinates using atan2(z, x).');
  console.log('This ignores Earth\'s equatorial plane and axial tilt entirely.');
  console.log('');
  console.log(`  Measurements:    ${solarIntervalsB.length} solar days`);
  console.log(`  Mean:            ${meanSolarB.toFixed(6)} seconds`);
  console.log(`  Min:             ${minSolarB.toFixed(6)} seconds`);
  console.log(`  Max:             ${maxSolarB.toFixed(6)} seconds`);
  console.log(`  Range:           ${(maxSolarB - minSolarB).toFixed(6)} seconds`);

  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('METHOD D: EARTH-POSITION RA (sun.ra directly)');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('Measures sun.ra from Earth\'s ACTUAL position (includes wobble parallax).');
  console.log('This is the "true" Earth observer experience, unlike Method A (wobble center).');
  console.log('');
  console.log(`  Measurements:    ${solarIntervalsD.length} solar days`);
  console.log(`  Mean:            ${meanSolarD.toFixed(6)} seconds`);
  console.log(`  Min:             ${minSolarD.toFixed(6)} seconds`);
  console.log(`  Max:             ${maxSolarD.toFixed(6)} seconds`);
  console.log(`  Range:           ${(maxSolarD - minSolarD).toFixed(6)} seconds`);

  console.log('');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('RESULTS SUMMARY');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('');
  console.log('╔════════════════════════════════╤══════════════════════╤════════════════════╗');
  console.log('║ Method                         │ Mean Solar Day (s)   │ Diff from Model    ║');
  console.log('╠════════════════════════════════╪══════════════════════╪════════════════════╣');

  const diffAModel = (meanSolar - expectedSolarDay) * 1000;
  const diffBModel = (derivedSolar - expectedSolarDay) * 1000;
  const diffCModel = (meanSolarB - expectedSolarDay) * 1000;
  const diffDModel = (meanSolarD - expectedSolarDay) * 1000;

  console.log(`║ A: Wobble-center RA            │ ${meanSolar.toFixed(6).padStart(16)}     │ ${(diffAModel >= 0 ? '+' : '') + diffAModel.toFixed(3).padStart(10)} ms   ║`);
  console.log(`║ B: Derived from sidereal       │ ${derivedSolar.toFixed(6).padStart(16)}     │ ${(diffBModel >= 0 ? '+' : '') + diffBModel.toFixed(3).padStart(10)} ms   ║`);
  console.log(`║ C: Fixed-frame (reference)     │ ${meanSolarB.toFixed(6).padStart(16)}     │ ${(diffCModel >= 0 ? '+' : '') + diffCModel.toFixed(3).padStart(10)} ms   ║`);
  console.log(`║ D: Earth-pos RA (cumulative)   │ ${meanSolarD.toFixed(6).padStart(16)}     │ ${(diffDModel >= 0 ? '+' : '') + diffDModel.toFixed(3).padStart(10)} ms   ║`);
  console.log('╠════════════════════════════════╪══════════════════════╪════════════════════╣');
  console.log(`║ Model expected                 │ ${expectedSolarDay.toFixed(6).padStart(16)}     │         —          ║`);
  console.log(`║ IAU reference (at epoch)       │ ${(86400).toFixed(6).padStart(16)}     │ ${((86400 - expectedSolarDay) * 1000 >= 0 ? '+' : '') + ((86400 - expectedSolarDay) * 1000).toFixed(3).padStart(10)} ms   ║`);
  console.log('╚════════════════════════════════╧══════════════════════╧════════════════════╝');
  console.log('');
  console.log('Method A vs D difference: ' + ((meanSolarD - meanSolar) * 1000).toFixed(3) + ' ms');
  console.log('');
  console.log('───────────────────────────────────────────────────────────────────────────');
  console.log('METHOD DESCRIPTIONS:');
  console.log('───────────────────────────────────────────────────────────────────────────');
  console.log('A: Uses RA from wobble center (calculateRAFromWobbleCenter). Eliminates wobble parallax.');
  console.log('B: Derives solar day from sidereal day: solarDay = siderealDay × (Y+1)/Y');
  console.log('C: Measures Sun angle in world XZ plane. Always 86400s (confirms JD step).');
  console.log('D: Uses sun.ra with cumulative tracking from Earth\'s position.');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return {
    methodA: {
      count: solarIntervals.length,
      mean: meanSolar,
      min: minSolar,
      max: maxSolar
    },
    methodB: {
      siderealMean: meanSidereal,
      tropicalYear: tropicalYearDays,
      derivedSolar: derivedSolar
    },
    methodC: {
      count: solarIntervalsB.length,
      mean: meanSolarB,
      min: minSolarB,
      max: maxSolarB
    },
    methodD: {
      count: solarIntervalsD.length,
      mean: meanSolarD,
      min: minSolarD,
      max: maxSolarD
    },
    differenceAB: meanSolar - derivedSolar,
    differenceAC: meanSolar - meanSolarB,
    differenceAD: meanSolar - meanSolarD,
    differenceCB: meanSolarB - derivedSolar
  };
}

/**
 * Stellar Day Analysis - Three Methods
 *
 * The stellar day differs from the sidereal day due to precession:
 * - Sidereal day: 360° rotation relative to the vernal equinox (precessing frame)
 * - Stellar day: 360° rotation relative to fixed stars (ICRF/inertial frame)
 *
 * The difference is caused by precession:
 * - Precession rate: ~50.3 arcsec/year = 360° / 25,772 years
 * - Per day: 360° / (25,772 × 365.25) ≈ 0.0383 arcsec/day
 * - Time difference: ~9.1 ms (stellar day is shorter than sidereal day)
 *
 * IAU values:
 * - Sidereal day: 86164.0905309 seconds (relative to precessing equinox)
 * - Stellar day:  86164.0989 seconds (relative to fixed stars) - approx
 */

/**
 * Method A: Track Earth rotation + orbital position to get ICRF orientation
 * The key insight: Earth's prime meridian direction in ICRF =
 *   earth.planetObj.rotation.y (daily spin) + orbital position (defines equinox direction)
 */
function stellarNoonMethodA(startJD, debug = false) {
  // Get Earth's total orientation in ICRF at start
  jumpToJulianDay(startJD);
  forceSceneUpdate();

  // Earth's rotation relative to equinox (sidereal)
  const startEarthRot = earth.planetObj.rotation.y;

  // Earth's orbital position (defines the equinox direction in ICRF)
  // The equinox precesses with Earth's orbit around the Sun
  const startOrbitalAngle = earth.orbitObj.rotation.y;

  // Combined angle gives Earth's orientation in ICRF
  // (rotation relative to equinox + equinox position in ICRF)
  const startICRFAngle = startEarthRot + startOrbitalAngle;

  // Target: find when this combined angle increases by exactly 2π
  const targetICRFAngle = startICRFAngle + 2 * Math.PI;

  // Estimate: approximately one sidereal day
  const expectedSiderealDayJD = meansolaryearlengthinDays / (meansolaryearlengthinDays + 1);
  const approxJD = startJD + expectedSiderealDayJD;

  // Binary search for precise crossing
  let lo = approxJD - 0.01;
  let hi = approxJD + 0.01;

  for (let iter = 0; iter < 40; iter++) {
    const mid = (lo + hi) / 2;
    jumpToJulianDay(mid);
    forceSceneUpdate();

    const midICRFAngle = earth.planetObj.rotation.y + earth.orbitObj.rotation.y;
    if (midICRFAngle < targetICRFAngle) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  const refinedJD = (lo + hi) / 2;

  if (debug) {
    console.log(`stellarNoonMethodA: start=${startJD.toFixed(6)}, refined=${refinedJD.toFixed(6)}`);
    console.log(`  Interval: ${((refinedJD - startJD) * 86400).toFixed(6)} seconds`);
  }

  return { jd: refinedJD };
}

/**
 * Method B: Track Earth's rotation using world matrix Y-axis (rotation axis)
 *
 * The issue with projecting meridian to XZ plane is that Earth's tilt causes
 * non-uniform projection. Instead, we track the angle of Earth's local X-axis
 * in a plane perpendicular to Earth's rotation axis.
 *
 * We use the world coordinates of Earth's local X and Z axes, then compute
 * the rotation angle around the world-transformed Y axis.
 */
function stellarNoonMethodB(startJD, debug = false) {
  const _localX = new THREE.Vector3();
  const _localY = new THREE.Vector3();
  const _localZ = new THREE.Vector3();
  const _earthPos = new THREE.Vector3();
  const _refDir = new THREE.Vector3();

  // Helper to get Earth's rotation angle in world coordinates
  // We track where Earth's local X axis points relative to a fixed reference
  const getRotationAngle = (jd, refY = null) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    earth.planetObj.updateMatrixWorld(true);

    // Get Earth's local axes in world coordinates
    _localX.set(1, 0, 0);
    _localY.set(0, 1, 0);
    _localZ.set(0, 0, 1);
    earth.planetObj.localToWorld(_localX);
    earth.planetObj.localToWorld(_localY);
    earth.planetObj.localToWorld(_localZ);
    earth.planetObj.getWorldPosition(_earthPos);
    _localX.sub(_earthPos).normalize();
    _localY.sub(_earthPos).normalize();
    _localZ.sub(_earthPos).normalize();

    // If no reference, return axes for initialization
    if (!refY) return { localX: _localX.clone(), localY: _localY.clone(), localZ: _localZ.clone() };

    // Project local X onto plane perpendicular to reference Y axis
    // This gives us the rotation angle around the fixed axis
    const dot = _localX.dot(refY);
    _refDir.copy(_localX).addScaledVector(refY, -dot).normalize();

    // Now compute angle of this projected vector
    // Use atan2 with two perpendicular reference directions in the plane
    return Math.atan2(_localZ.dot(_refDir), _localX.dot(_refDir));
  };

  // Initialize - get reference frame at start
  jumpToJulianDay(startJD);
  forceSceneUpdate();
  earth.planetObj.updateMatrixWorld(true);

  const startAxes = getRotationAngle(startJD, null);
  const refY = startAxes.localY.clone();  // Fixed reference: Earth's rotation axis at start

  // Actually, for stellar day we want to track rotation relative to ICRF, not relative
  // to Earth's precessing axis. Let's use the world +Y axis (ecliptic pole) as reference.
  // No wait - we need to track the actual Earth rotation.

  // Simpler approach: Use Earth's rotation.y directly but account for the precession
  // by tracking in the world frame using world matrix extraction.

  // Extract the rotation component from Earth's world matrix
  const getWorldRotationY = (jd) => {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    earth.planetObj.updateMatrixWorld(true);

    // Extract rotation from world matrix
    const euler = new THREE.Euler();
    euler.setFromRotationMatrix(earth.planetObj.matrixWorld, 'YXZ');
    return euler.y;
  };

  const startWorldRotY = getWorldRotationY(startJD);

  // Estimate
  const expectedSiderealDayJD = meansolaryearlengthinDays / (meansolaryearlengthinDays + 1);
  const approxJD = startJD + expectedSiderealDayJD;

  // Binary search with cumulative tracking
  let lo = approxJD - 0.01;
  let hi = approxJD + 0.01;

  for (let iter = 0; iter < 40; iter++) {
    const mid = (lo + hi) / 2;

    // Step from start to mid, tracking cumulative angle
    const numSteps = 24;
    const stepSize = (mid - startJD) / numSteps;

    let cumulativeAngle = 0;
    let lastAngle = startWorldRotY;

    for (let s = 1; s <= numSteps; s++) {
      const jd = startJD + s * stepSize;
      const currentAngle = getWorldRotationY(jd);

      // Handle wrap-around
      let deltaAngle = currentAngle - lastAngle;
      if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
      if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
      cumulativeAngle += deltaAngle;
      lastAngle = currentAngle;
    }

    // Target is 2π
    if (cumulativeAngle < 2 * Math.PI) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  const refinedJD = (lo + hi) / 2;

  if (debug) {
    console.log(`stellarNoonMethodB: start=${startJD.toFixed(6)}, refined=${refinedJD.toFixed(6)}`);
    console.log(`  Interval: ${((refinedJD - startJD) * 86400).toFixed(6)} seconds`);
  }

  return { jd: refinedJD };
}

/**
 * Method C: Derive stellar day from sidereal day using precession rate
 * stellar_day = sidereal_day × precession_factor
 * where precession_factor accounts for the equinox drift
 */
function stellarDayMethodC_Derived(siderealDaySeconds) {
  // Precession period in years (from model constant)
  // Earth's axial precession period is holisticyearLength/13
  const precessionPeriodYears = holisticyearLength / 13;

  // How much shorter is stellar day than sidereal day?
  // In one precession cycle, the equinox shifts by 360°
  // So per year, equinox shifts by 360/precessionPeriod degrees
  // Per sidereal day, equinox shifts by 360/(precessionPeriod × daysPerYear) degrees

  // The relationship:
  // stellarDay = siderealDay × (1 - 1/(precessionPeriod × daysPerYear))
  // Because in each sidereal day, the equinox has moved slightly,
  // so we need slightly less rotation to reach the same star

  const daysPerYear = meansolaryearlengthinDays;
  const precessionFactor = 1 - 1 / (precessionPeriodYears * daysPerYear);

  // Actually, the stellar day is LONGER than sidereal day
  // because the equinox precesses WESTWARD (retrograde)
  // So Earth has to rotate MORE to catch up to the stars
  // stellarDay = siderealDay × (1 + 1/(precessionPeriod × rotationsPerYear))

  const rotationsPerYear = daysPerYear + 1;  // sidereal rotations per tropical year
  const stellarDayFactor = 1 + 1 / (precessionPeriodYears * rotationsPerYear);

  const stellarDaySeconds = siderealDaySeconds * stellarDayFactor;

  return {
    siderealDay: siderealDaySeconds,
    stellarDay: stellarDaySeconds,
    precessionPeriodYears,
    correction: (stellarDaySeconds - siderealDaySeconds) * 1000  // ms
  };
}

/**
 * Main stellar day analysis function - runs all three methods
 */
async function analyzeStellarDay(startYear) {
  startYear = startYear || o.calibrationYearStart;

  console.log('╔══════════════════════════════════════════════════════════════════════════╗');
  console.log('║           STELLAR DAY LENGTH ANALYSIS                                    ║');
  console.log('╚══════════════════════════════════════════════════════════════════════════╝');
  console.log(`Analyzing year ${startYear}`);
  console.log('');
  console.log('The stellar day differs from sidereal day due to precession:');
  console.log('- Sidereal day: 360° rotation relative to vernal equinox (precessing)');
  console.log('- Stellar day:  360° rotation relative to fixed stars (ICRF)');
  console.log('');

  const savedJD = o.julianDay;
  const savedRun = o.Run;
  o.Run = false;

  // Start from June solstice
  const startSolstice = solsticeForYear(startYear);
  if (!startSolstice) {
    console.error('Could not find start solstice');
    return;
  }

  // Unlike solar day (which varies ±20-25s due to equation of time), stellar day shows
  // zero variation throughout the year - every day is identical. This is because stellar
  // day measures pure rotation in inertial space, without any equatorial plane projection.
  // Therefore, 30 days is sufficient to characterize the stellar day.
  const numDays = 30;
  console.log(`Measuring ${numDays} day intervals starting from JD ${startSolstice.jd.toFixed(4)}...`);
  console.log('Note: Stellar day has no daily variation (unlike solar day), so 30 days is sufficient.');
  console.log('');

  // ═══════════════════════════════════════════════════════════════════════════
  // Method A: Earth rotation + orbital position (ICRF orientation)
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('METHOD A: Rotation Angles Sum');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('Sums earth.planetObj.rotation.y (daily spin) + earth.orbitObj.rotation.y');
  console.log('(orbital angle). The orbital angle defines the equinox direction in ICRF,');
  console.log('so the sum gives Earth\'s total orientation relative to fixed stars.');
  console.log('');

  const intervalsA = [];
  let prevJD = startSolstice.jd;

  for (let i = 0; i < numDays; i++) {
    const result = stellarNoonMethodA(prevJD, i === 0);
    if (result) {
      const interval = (result.jd - prevJD) * 86400;
      intervalsA.push(interval);
      prevJD = result.jd;
    }
    if (i % 10 === 0) {
      console.log(`  Progress A: ${i}/${numDays}...`);
      await new Promise(r => setTimeout(r, 10));
    }
  }

  const meanA = intervalsA.reduce((a, b) => a + b, 0) / intervalsA.length;
  const minA = Math.min(...intervalsA);
  const maxA = Math.max(...intervalsA);

  console.log(`  Measurements: ${intervalsA.length} stellar days`);
  console.log(`  Mean:         ${meanA.toFixed(6)} seconds`);
  console.log(`  Min:          ${minA.toFixed(6)} seconds`);
  console.log(`  Max:          ${maxA.toFixed(6)} seconds`);
  console.log(`  Range:        ${(maxA - minA).toFixed(6)} seconds`);
  console.log('');

  // ═══════════════════════════════════════════════════════════════════════════
  // Method B: World matrix Y-rotation extraction
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('METHOD B: World Matrix Y-Rotation');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('Extracts the Y-rotation component from Earth\'s world transformation matrix');
  console.log('using Euler decomposition. This captures the actual rotation around the');
  console.log('world Y-axis (perpendicular to ecliptic) after all parent transforms.');
  console.log('');

  const intervalsB = [];
  prevJD = startSolstice.jd;

  for (let i = 0; i < numDays; i++) {
    const result = stellarNoonMethodB(prevJD, i === 0);
    if (result) {
      const interval = (result.jd - prevJD) * 86400;
      intervalsB.push(interval);
      prevJD = result.jd;
    }
    if (i % 10 === 0) {
      console.log(`  Progress B: ${i}/${numDays}...`);
      await new Promise(r => setTimeout(r, 10));
    }
  }

  const meanB = intervalsB.reduce((a, b) => a + b, 0) / intervalsB.length;
  const minB = Math.min(...intervalsB);
  const maxB = Math.max(...intervalsB);

  console.log(`  Measurements: ${intervalsB.length} stellar days`);
  console.log(`  Mean:         ${meanB.toFixed(6)} seconds`);
  console.log(`  Min:          ${minB.toFixed(6)} seconds`);
  console.log(`  Max:          ${maxB.toFixed(6)} seconds`);
  console.log(`  Range:        ${(maxB - minB).toFixed(6)} seconds`);
  console.log('');

  // ═══════════════════════════════════════════════════════════════════════════
  // Method C: Derived from sidereal day using precession rate
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('METHOD C: Mathematical Derivation');
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('Derives stellar day from the model\'s sidereal day using precession period.');
  console.log('Formula: stellar = sidereal × (1 + 1/(precessionPeriod × rotationsPerYear))');
  console.log('The equinox precesses westward, so Earth must rotate slightly MORE to');
  console.log('reach the same star position, making stellar day longer than sidereal.');
  console.log('');

  // Get sidereal day from our existing measurement
  const siderealDayExpected = meansolaryearlengthinDays / (meansolaryearlengthinDays + 1) * 86400;
  const methodC = stellarDayMethodC_Derived(siderealDayExpected);

  console.log(`  Sidereal day (model):    ${methodC.siderealDay.toFixed(6)} seconds`);
  console.log(`  Precession period:       ${methodC.precessionPeriodYears.toFixed(1)} years`);
  console.log(`  Derived stellar day:     ${methodC.stellarDay.toFixed(6)} seconds`);
  console.log(`  Precession correction:   ${methodC.correction.toFixed(6)} ms`);
  console.log('');

  // ═══════════════════════════════════════════════════════════════════════════
  // Comparison
  // ═══════════════════════════════════════════════════════════════════════════
  console.log('═══════════════════════════════════════════════════════════════════════════');
  console.log('COMPARISON');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  // Reference values
  const siderealDayIAU = ASTRO_REFERENCE.siderealDayJ2000;
  const stellarDayIAU = ASTRO_REFERENCE.stellarDayJ2000;

  console.log('Reference values:');
  console.log(`  IAU Sidereal day:  ${siderealDayIAU} seconds`);
  console.log(`  IAU Stellar day:   ${stellarDayIAU} seconds`);
  console.log(`  Expected diff:     ~${((stellarDayIAU - siderealDayIAU) * 1000).toFixed(3)} ms`);
  console.log('');

  console.log('Measured results:');
  console.log(`  Method A (rotation+orbit):  ${meanA.toFixed(6)} seconds`);
  console.log(`  Method B (world matrix):    ${meanB.toFixed(6)} seconds`);
  console.log(`  Method C (derived):         ${methodC.stellarDay.toFixed(6)} seconds`);
  console.log('');

  console.log('Differences from sidereal day:');
  console.log(`  Method A - sidereal:  ${((meanA - siderealDayExpected) * 1000).toFixed(3)} ms`);
  console.log(`  Method B - sidereal:  ${((meanB - siderealDayExpected) * 1000).toFixed(3)} ms`);
  console.log(`  Method C - sidereal:  ${((methodC.stellarDay - siderealDayExpected) * 1000).toFixed(3)} ms`);
  console.log('');

  console.log('Method agreement:');
  console.log(`  A - B:  ${((meanA - meanB) * 1000).toFixed(3)} ms`);
  console.log(`  A - C:  ${((meanA - methodC.stellarDay) * 1000).toFixed(3)} ms`);
  console.log(`  B - C:  ${((meanB - methodC.stellarDay) * 1000).toFixed(3)} ms`);
  console.log('');

  console.log('───────────────────────────────────────────────────────────────────────────');
  console.log('WHY THE METHODS DIFFER:');
  console.log('───────────────────────────────────────────────────────────────────────────');
  console.log('');
  console.log('Method A (Rotation Angles Sum) - ALGEBRAIC APPROACH');
  console.log('  Adds two rotation angles: earth.planetObj.rotation.y (daily spin relative');
  console.log('  to the equinox) + earth.orbitObj.rotation.y (orbital position that defines');
  console.log('  where the equinox points in ICRF). The sum represents total ICRF rotation.');
  console.log('  Advantage: Simple, fast, uses model\'s internal rotation values directly.');
  console.log('');
  console.log('Method B (World Matrix Y-Rotation) - GEOMETRIC APPROACH');
  console.log('  Extracts Y-rotation from Earth\'s world transformation matrix via Euler');
  console.log('  decomposition. This captures the final rotation around the world Y-axis');
  console.log('  after applying all parent transforms (orbit, tilt, precession).');
  console.log('  Advantage: Direct geometric measurement, independent of internal angles.');
  console.log('  Note: Euler decomposition can have numerical precision limitations.');
  console.log('');
  console.log('Method C (Mathematical Derivation) - ANALYTICAL APPROACH');
  console.log('  Derives stellar day from sidereal day using precession correction:');
  console.log('  stellar = sidereal × (1 + 1/(precessionPeriod × rotationsPerYear))');
  console.log('  The equinox precesses westward ~50"/year, so Earth must rotate ~9ms');
  console.log('  more each day to reach the same fixed star position.');
  console.log('  Advantage: No simulation required, pure mathematical relationship.');
  console.log('');
  console.log('Expected: stellar day > sidereal day by ~8-9 ms (model: ~9.16 ms)');
  console.log('═══════════════════════════════════════════════════════════════════════════');

  jumpToJulianDay(savedJD);
  o.Run = savedRun;

  return {
    methodA: { mean: meanA, min: minA, max: maxA, count: intervalsA.length },
    methodB: { mean: meanB, min: minB, max: maxB, count: intervalsB.length },
    methodC: methodC,
    siderealDayExpected: siderealDayExpected
  };
}

function buildJdArray () {

  if (o.testMode === 'List') {
    const field = document.querySelector('input[data-property="testJDsText"]');
    const raw   = field ? field.value : o.testJDsText;

    //    ┌─ optional sign ─┐┌──── digits ───┐┌─ optional .fraction ──┐┌ optional exponent ┐
    const numRE = /[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;

    return (raw.match(numRE) || [])
           .map(Number)             // Number/parseFloat both keep decimals
           .filter(Number.isFinite);
  }

  /* ── Range mode ────────────────────────────────────────── */
  const s = Number(o.rangeStart);
  const e = Number(o.rangeEnd);
  const n = Math.max(2, Number(o.rangePieces) | 0);   // force integer ≥ 2

  if (!Number.isFinite(s) || !Number.isFinite(e) || !Number.isFinite(n)) {
    console.error('RA-test “Range” values must be numbers:', s, e, n);
    return [];
  }
  const step = (e - s) / (n - 1);
  return Array.from({ length: n }, (_, i) => Math.round(s + i * step));
}

/* ────────────────────────────────────────────────────────── */
/*  Helper – do exactly what the “Julian day” GUI field does */
/* ────────────────────────────────────────────────────────── */
function jumpToJulianDay (jd) {
  o.julianDay = jd;

  // Calculate position from JD alone - Day already contains the time fraction
  // (Fixed: removed "+ timeToPos(o.Time)" which caused double-counting of time)
  o.Day = o.julianDay - startmodelJD;
  o.pos = sDay * o.Day;

  const p = dayToDateNew(o.julianDay,'julianday','perihelion-calendar');
  o.perihelionDate = `${p.date}`;

  positionChanged = true; // Signal animation loop to update scene
}

/* Force all the astro calculations that the render loop usually so RA & DEC are up-to-date. */
function forceSceneUpdate () {
  o.Day           = posToDays(o.pos);
  o.Date          = daysToDate(o.Day);
  o.Time          = posToTime(o.pos);
  o.currentYear   = julianDateToDecimalYear(o.julianDay); // Required for updatePredictions & updateAscendingNodes
  trace(o.pos);
  moveModel(o.pos);
  updatePredictions();
  updatePositions();
  updatePerihelion();
  updateAscendingNodes();
  updatePlanetAnomalies();
  updatePlanetInvariablePlaneHeights();
  updateDynamicInclinations();
  updateInvariablePlaneBalance();
  calculateInvariablePlaneFromAngularMomentum();
  updateOrbitOrientations();
  // -- anything else your render loop does that affects .ra/.dec
}

/*  Load SheetJS the first time we need it  */
function ensureSheetJs () {
  return new Promise(res => {
    if (window.XLSX) return res();
    const s = document.createElement('script');
    s.src   = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
    s.onload = res;
    document.head.appendChild(s);
  });
}

/*  Convert workbook → Blob  */
function workbookToBlob (wb) {
  const wbout = XLSX.write(wb, { bookType:'xlsx', type:'array' });
  return new Blob([wbout], { type:
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
}

async function runRATest() {

  const jds = buildJdArray();
  if (!jds.length) {
    alert('No valid Julian dates — please check your input.');
    return;
  }

  /* headers */
  const earthRows  = [['JD', 'Date', 'Time', 'Year', 'Earth Wobble RA', 'Earth Wobble Dec', 'Earth Wobble Dist Earth', 'Earth Wobble Dist Sun', 'Earth Longitude RA', 'Earth Longitude Dec', 'Earth Longitude Dist Earth', 'Earth Longitude Dist Sun', 'Mid-eccentricity RA', 'Mid-eccentricity Dec', 'Mid-eccentricity Dist Earth', 'Mid-eccentricity Dist Sun']];
  const periRows   = [['JD', 'Date', 'Time', 'Year',
    'Mercury Perihelion', 'Mercury Asc Node', 'Mercury Arg Peri', 'Mercury Ecliptic Inclination', 'Mercury Asc Node InvPlane', 'Mercury Asc Node InvPlane MaxIncl', 'Mercury Inclination Phase Angle', 'Mercury InvPlane Inclination',
    'Venus Perihelion', 'Venus Asc Node', 'Venus Arg Peri', 'Venus Ecliptic Inclination', 'Venus Asc Node InvPlane', 'Venus Asc Node InvPlane MaxIncl', 'Venus Inclination Phase Angle', 'Venus InvPlane Inclination',
    'Earth Perihelion', 'Earth Asc Node InvPlane', 'Earth Asc Node InvPlane MaxIncl', 'Earth InvPlane Inclination',
    'Mars Perihelion', 'Mars Asc Node', 'Mars Arg Peri', 'Mars Ecliptic Inclination', 'Mars Asc Node InvPlane', 'Mars Asc Node InvPlane MaxIncl', 'Mars Inclination Phase Angle', 'Mars InvPlane Inclination',
    'Jupiter Perihelion', 'Jupiter Asc Node', 'Jupiter Arg Peri', 'Jupiter Ecliptic Inclination', 'Jupiter Asc Node InvPlane', 'Jupiter Asc Node InvPlane MaxIncl', 'Jupiter Inclination Phase Angle', 'Jupiter InvPlane Inclination',
    'Saturn Perihelion', 'Saturn Asc Node', 'Saturn Arg Peri', 'Saturn Ecliptic Inclination', 'Saturn Asc Node InvPlane', 'Saturn Asc Node InvPlane MaxIncl', 'Saturn Inclination Phase Angle', 'Saturn InvPlane Inclination',
    'Uranus Perihelion', 'Uranus Asc Node', 'Uranus Arg Peri', 'Uranus Ecliptic Inclination', 'Uranus Asc Node InvPlane', 'Uranus Asc Node InvPlane MaxIncl', 'Uranus Inclination Phase Angle', 'Uranus InvPlane Inclination',
    'Neptune Perihelion', 'Neptune Asc Node', 'Neptune Arg Peri', 'Neptune Ecliptic Inclination', 'Neptune Asc Node InvPlane', 'Neptune Asc Node InvPlane MaxIncl', 'Neptune Inclination Phase Angle', 'Neptune InvPlane Inclination'
  ]];
  //const periRows   = [['JD', 'Date', 'Time', 'Mercury Perihelion', 'Venus Perihelion', 'Earth Perihelion', 'Mars Perihelion', 'Jupiter Perihelion', 'Saturn Perihelion', 'Uranus Perihelion', 'Neptune Perihelion', 'Pluto Perihelion', 'Halleys Perihelion', 'Eros Perihelion']]; 
  const planetRows = [['JD', 'Date', 'Time', 'Year', 'Sun RA', 'Sun Dec', 'Sun Dist Earth', 'Mercury RA', 'Mercury Dec', 'Mercury Dist Earth', 'Mercury Dist Sun', 'Venus RA', 'Venus Dec', 'Venus Dist Earth', 'Venus Dist Sun','Mars RA', 'Mars Dec', 'Mars Dist Earth', 'Mars Dist Sun','Jupiter RA', 'Jupiter Dec', 'Jupiter Dist Earth', 'Jupiter Dist Sun','Saturn RA', 'Saturn Dec', 'Saturn Dist Earth', 'Saturn Dist Sun','Uranus RA', 'Uranus Dec', 'Uranus Dist Earth', 'Uranus Dist Sun','Neptune RA', 'Neptune Dec', 'Neptune Dist Earth', 'Neptune Dist Sun']]; 
  //const planetRows = [['JD', 'Date', 'Time', 'Sun RA', 'Sun Dec', 'Sun Dist Earth', 'Mercury RA', 'Mercury Dec', 'Mercury Dist Earth', 'Mercury Dist Sun', 'Venus RA', 'Venus Dec', 'Venus Dist Earth', 'Venus Dist Sun','Mars RA', 'Mars Dec', 'Mars Dist Earth', 'Mars Dist Sun','Jupiter RA', 'Jupiter Dec', 'Jupiter Dist Earth', 'Jupiter Dist Sun','Saturn RA', 'Saturn Dec', 'Saturn Dist Earth', 'Saturn Dist Sun','Uranus RA', 'Uranus Dec', 'Uranus Dist Earth', 'Uranus Dist Sun','Neptune RA', 'Neptune Dec', 'Neptune Dist Earth', 'Neptune Dist Sun','Pluto RA', 'Pluto Dec', 'Pluto Dist Earth', 'Pluto Dist Sun','Halleys RA', 'Halleys Dec', 'Halleys Dist Earth', 'Halleys Dist Sun', 'Eros RA', 'Eros Dec', 'Eros Dist Earth', 'Eros Dist Sun']]; 

  /* freeze viewer */
  const oldRun = o.Run;
  const oldJD  = o.julianDay;
  const oldTime = o.Time;

  o.Run = false;
  o.Time = '12:00:00';

  /* yield to browser periodically to keep UI responsive */
  const YIELD_EVERY = 25;
  let done = 0;

  for (const jd of jds) {
    jumpToJulianDay(jd);
    forceSceneUpdate();
    
    const date = o.Date
    const time = o.Time

    const earthWobbRA    = (earthWobbleCenter.ra * 180 / Math.PI + 360) % 360;
    const earthWobbDec   = 90-(earthWobbleCenter.dec * 180 / Math.PI);
    const earthWobbDistE = earthWobbleCenter.distAU;
    const earthWobbDistS = earthWobbleCenter.sunDistAU;
    const earthPerRA     = (earthPerihelionFromEarth.ra * 180 / Math.PI + 360) % 360;
    const earthPerDec    = 90-(earthPerihelionFromEarth.dec * 180 / Math.PI);
    const earthPerDistE  = earthPerihelionFromEarth.distAU;
    const earthPerDistS  = earthPerihelionFromEarth.sunDistAU;
    const earthMidRA     = (midEccentricityOrbit.ra   * 180 / Math.PI + 360) % 360;
    const earthMidDec    = 90-(midEccentricityOrbit.dec * 180 / Math.PI);
    const earthMidDistE  = midEccentricityOrbit.distAU;
    const earthMidDistS  = midEccentricityOrbit.sunDistAU;
                            
    const mercuryPer   = o.mercuryPerihelion;
    const mercuryAsc   = o.mercuryAscendingNode;
    const mercuryArg   = o.mercuryArgumentOfPeriapsis;
    const mercuryAscInv = o.mercuryAscendingNodeInvPlane;  // ICRF coords
    const mercuryAppIncl = o.mercuryEclipticInclinationDynamic;
    const venusPer     = o.venusPerihelion;
    const venusAsc     = o.venusAscendingNode;
    const venusArg     = o.venusArgumentOfPeriapsis;
    const venusAscInv  = o.venusAscendingNodeInvPlane;  // ICRF coords
    const venusAppIncl = o.venusEclipticInclinationDynamic;
    const earthAscInv  = o.earthAscendingNodeInvPlane;  // ICRF coords
    const earthIncl    = o.earthInvPlaneInclinationDynamic;
    const marsPer      = o.marsPerihelion;
    const marsAsc      = o.marsAscendingNode;
    const marsArg      = o.marsArgumentOfPeriapsis;
    const marsAscInv   = o.marsAscendingNodeInvPlane;  // ICRF coords
    const marsAppIncl  = o.marsEclipticInclinationDynamic;
    const jupiterPer   = o.jupiterPerihelion;
    const jupiterAsc   = o.jupiterAscendingNode;
    const jupiterArg   = o.jupiterArgumentOfPeriapsis;
    const jupiterAscInv = o.jupiterAscendingNodeInvPlane;  // ICRF coords
    const jupiterAppIncl = o.jupiterEclipticInclinationDynamic;
    const saturnPer    = o.saturnPerihelion;
    const saturnAsc    = o.saturnAscendingNode;
    const saturnArg    = o.saturnArgumentOfPeriapsis;
    const saturnAscInv = o.saturnAscendingNodeInvPlane;  // ICRF coords
    const saturnAppIncl = o.saturnEclipticInclinationDynamic;
    const uranusPer    = o.uranusPerihelion;
    const uranusAsc    = o.uranusAscendingNode;
    const uranusArg    = o.uranusArgumentOfPeriapsis;
    const uranusAscInv = o.uranusAscendingNodeInvPlane;  // ICRF coords
    const uranusAppIncl = o.uranusEclipticInclinationDynamic;
    const neptunePer   = o.neptunePerihelion;
    const neptuneAsc   = o.neptuneAscendingNode;
    const neptuneArg   = o.neptuneArgumentOfPeriapsis;
    const neptuneAscInv = o.neptuneAscendingNodeInvPlane;  // ICRF coords
    const neptuneAppIncl = o.neptuneEclipticInclinationDynamic;

    // Inclination phase angles (Ω - φ) and InvPlane inclinations (dynamic)
    // Using ICRF ascending nodes for oscillation phase (same as "Current Oscillation Phase" in planet stats)
    const mercuryPhaseAngle = (o.mercuryAscendingNodeInvPlane - mercuryInclinationPhaseAngle + 360) % 360;
    const mercuryInvPlaneIncl = o.mercuryInvPlaneInclinationDynamic;
    const venusPhaseAngle = (o.venusAscendingNodeInvPlane - venusInclinationPhaseAngle + 360) % 360;
    const venusInvPlaneIncl = o.venusInvPlaneInclinationDynamic;
    const marsPhaseAngle = (o.marsAscendingNodeInvPlane - marsInclinationPhaseAngle + 360) % 360;
    const marsInvPlaneIncl = o.marsInvPlaneInclinationDynamic;
    const jupiterPhaseAngle = (o.jupiterAscendingNodeInvPlane - jupiterInclinationPhaseAngle + 360) % 360;
    const jupiterInvPlaneIncl = o.jupiterInvPlaneInclinationDynamic;
    const saturnPhaseAngle = (o.saturnAscendingNodeInvPlane - saturnInclinationPhaseAngle + 360) % 360;
    const saturnInvPlaneIncl = o.saturnInvPlaneInclinationDynamic;
    const uranusPhaseAngle = (o.uranusAscendingNodeInvPlane - uranusInclinationPhaseAngle + 360) % 360;
    const uranusInvPlaneIncl = o.uranusInvPlaneInclinationDynamic;
    const neptunePhaseAngle = (o.neptuneAscendingNodeInvPlane - neptuneInclinationPhaseAngle + 360) % 360;
    const neptuneInvPlaneIncl = o.neptuneInvPlaneInclinationDynamic;

    // Ascending node at max inclination - fixed ICRF values (phase angle offsets)
    const mercuryAscInvMaxIncl = mercuryInclinationPhaseAngle;
    const venusAscInvMaxIncl = venusInclinationPhaseAngle;
    const earthAscInvMaxIncl = earthInclinationPhaseAngle;
    const marsAscInvMaxIncl = marsInclinationPhaseAngle;
    const jupiterAscInvMaxIncl = jupiterInclinationPhaseAngle;
    const saturnAscInvMaxIncl = saturnInclinationPhaseAngle;
    const uranusAscInvMaxIncl = uranusInclinationPhaseAngle;
    const neptuneAscInvMaxIncl = neptuneInclinationPhaseAngle;

    const plutoPer     = o.plutoPerihelion;
    const halleysPer   = o.halleysPerihelion;
    const erosPer      = o.erosPerihelion;
    
    const sunRA         = (sun.ra   * 180 / Math.PI + 360) % 360;
    const sunDec        = 90-(sun.dec * 180 / Math.PI);
    const sunDistE      = sun.distAU;
    
    const mercuryRA     = (mercury.ra   * 180 / Math.PI + 360) % 360;
    const mercuryDec    = 90-(mercury.dec * 180 / Math.PI);
    const mercuryDistE  = mercury.distAU;
    const mercuryDistS  = mercury.sunDistAU;
    const venusRA       = (venus.ra   * 180 / Math.PI + 360) % 360;
    const venusDec      = 90-(venus.dec * 180 / Math.PI);
    const venusDistE    = venus.distAU;
    const venusDistS    = venus.sunDistAU;
    const marsRA        = (mars.ra   * 180 / Math.PI + 360) % 360;
    const marsDec       = 90-(mars.dec * 180 / Math.PI);
    const marsDistE     = mars.distAU;
    const marsDistS     = mars.sunDistAU;
    const jupiterRA     = (jupiter.ra   * 180 / Math.PI + 360) % 360;
    const jupiterDec    = 90-(jupiter.dec * 180 / Math.PI);
    const jupiterDistE  = jupiter.distAU;
    const jupiterDistS  = jupiter.sunDistAU;
    const saturnRA      = (saturn.ra   * 180 / Math.PI + 360) % 360;
    const saturnDec     = 90-(saturn.dec * 180 / Math.PI);
    const saturnDistE   = saturn.distAU;
    const saturnDistS   = saturn.sunDistAU;
    const uranusRA      = (uranus.ra   * 180 / Math.PI + 360) % 360;
    const uranusDec     = 90-(uranus.dec * 180 / Math.PI);
    const uranusDistE   = uranus.distAU;
    const uranusDistS   = uranus.sunDistAU;
    const neptuneRA     = (neptune.ra   * 180 / Math.PI + 360) % 360;
    const neptuneDec    = 90-(neptune.dec * 180 / Math.PI);
    const neptuneDistE  = neptune.distAU;
    const neptuneDistS  = neptune.sunDistAU;
    const plutoRA       = (pluto.ra   * 180 / Math.PI + 360) % 360;
    const plutoDec      = 90-(pluto.dec * 180 / Math.PI);
    const plutoDistE    = pluto.distAU;
    const plutoDistS    = pluto.sunDistAU;
    const halleysRA     = (halleys.ra   * 180 / Math.PI + 360) % 360;
    const halleysDec    = 90-(halleys.dec * 180 / Math.PI);
    const halleysDistE  = halleys.distAU;
    const halleysDistS  = halleys.sunDistAU;
    const erosRA        = (eros.ra   * 180 / Math.PI + 360) % 360;
    const erosDec       = 90-(eros.dec * 180 / Math.PI);
    const erosDistE     = eros.distAU;
    const erosDistS     = eros.sunDistAU;
        
        const year = Math.floor(o.currentYear);
        earthRows.push([jd, date, time, year, earthWobbRA.toFixed(6), earthWobbDec.toFixed(6), earthWobbDistE.toFixed(8), earthWobbDistS.toFixed(8), earthPerRA.toFixed(6), earthPerDec.toFixed(6), earthPerDistE.toFixed(8), earthPerDistS.toFixed(8), earthMidRA.toFixed(6), earthMidDec.toFixed(6), earthMidDistE.toFixed(8), earthMidDistS.toFixed(8)]);
    
//    periRows.push([jd, date, time, mercuryPer.toFixed(6), venusPer.toFixed(6), earthPerRA.toFixed(6), marsPer.toFixed(6), jupiterPer.toFixed(6), saturnPer.toFixed(6), uranusPer.toFixed(6), neptunePer.toFixed(6), plutoPer.toFixed(6), halleysPer.toFixed(6), erosPer.toFixed(6)]);

        periRows.push([jd, date, time, year,
          mercuryPer.toFixed(6), mercuryAsc.toFixed(6), mercuryArg.toFixed(6), mercuryAppIncl.toFixed(6), mercuryAscInv.toFixed(6), mercuryAscInvMaxIncl.toFixed(6), mercuryPhaseAngle.toFixed(6), mercuryInvPlaneIncl.toFixed(6),
          venusPer.toFixed(6), venusAsc.toFixed(6), venusArg.toFixed(6), venusAppIncl.toFixed(6), venusAscInv.toFixed(6), venusAscInvMaxIncl.toFixed(6), venusPhaseAngle.toFixed(6), venusInvPlaneIncl.toFixed(6),
          earthPerRA.toFixed(6), earthAscInv.toFixed(6), earthAscInvMaxIncl.toFixed(6), earthIncl.toFixed(6),
          marsPer.toFixed(6), marsAsc.toFixed(6), marsArg.toFixed(6), marsAppIncl.toFixed(6), marsAscInv.toFixed(6), marsAscInvMaxIncl.toFixed(6), marsPhaseAngle.toFixed(6), marsInvPlaneIncl.toFixed(6),
          jupiterPer.toFixed(6), jupiterAsc.toFixed(6), jupiterArg.toFixed(6), jupiterAppIncl.toFixed(6), jupiterAscInv.toFixed(6), jupiterAscInvMaxIncl.toFixed(6), jupiterPhaseAngle.toFixed(6), jupiterInvPlaneIncl.toFixed(6),
          saturnPer.toFixed(6), saturnAsc.toFixed(6), saturnArg.toFixed(6), saturnAppIncl.toFixed(6), saturnAscInv.toFixed(6), saturnAscInvMaxIncl.toFixed(6), saturnPhaseAngle.toFixed(6), saturnInvPlaneIncl.toFixed(6),
          uranusPer.toFixed(6), uranusAsc.toFixed(6), uranusArg.toFixed(6), uranusAppIncl.toFixed(6), uranusAscInv.toFixed(6), uranusAscInvMaxIncl.toFixed(6), uranusPhaseAngle.toFixed(6), uranusInvPlaneIncl.toFixed(6),
          neptunePer.toFixed(6), neptuneAsc.toFixed(6), neptuneArg.toFixed(6), neptuneAppIncl.toFixed(6), neptuneAscInv.toFixed(6), neptuneAscInvMaxIncl.toFixed(6), neptunePhaseAngle.toFixed(6), neptuneInvPlaneIncl.toFixed(6)
        ]);
    
//    planetRows.push([jd, date, time, sunRA.toFixed(6), sunDec.toFixed(6), sunDistE.toFixed(6), mercuryRA.toFixed(6), mercuryDec.toFixed(6), mercuryDistE.toFixed(6), mercuryDistS.toFixed(6), venusRA.toFixed(6),  venusDec.toFixed(6), venusDistE.toFixed(6), venusDistS.toFixed(6), marsRA.toFixed(6), marsDec.toFixed(6), marsDistE.toFixed(6), marsDistS.toFixed(6), jupiterRA.toFixed(6), jupiterDec.toFixed(6), jupiterDistE.toFixed(6), jupiterDistS.toFixed(6), saturnRA.toFixed(6), saturnDec.toFixed(6),  saturnDistE.toFixed(6), saturnDistS.toFixed(6), uranusRA.toFixed(6), uranusDec.toFixed(6), uranusDistE.toFixed(6), uranusDistS.toFixed(6), neptuneRA.toFixed(6), neptuneDec.toFixed(6), neptuneDistE.toFixed(6), neptuneDistS.toFixed(6), plutoRA.toFixed(6), plutoDec.toFixed(6), plutoDistE.toFixed(6), plutoDistS.toFixed(6), halleysRA.toFixed(6), halleysDec.toFixed(6), halleysDistE.toFixed(6), halleysDistS.toFixed(6), erosRA.toFixed(6), erosDec.toFixed(6), erosDistE.toFixed(6), erosDistS.toFixed(6)]);
    
        planetRows.push([jd, date, time, year, sunRA.toFixed(6), sunDec.toFixed(6), sunDistE.toFixed(6), mercuryRA.toFixed(6), mercuryDec.toFixed(6), mercuryDistE.toFixed(6), mercuryDistS.toFixed(6), venusRA.toFixed(6),  venusDec.toFixed(6), venusDistE.toFixed(6), venusDistS.toFixed(6), marsRA.toFixed(6), marsDec.toFixed(6), marsDistE.toFixed(6), marsDistS.toFixed(6), jupiterRA.toFixed(6), jupiterDec.toFixed(6), jupiterDistE.toFixed(6), jupiterDistS.toFixed(6), saturnRA.toFixed(6), saturnDec.toFixed(6),  saturnDistE.toFixed(6), saturnDistS.toFixed(6), uranusRA.toFixed(6), uranusDec.toFixed(6), uranusDistE.toFixed(6), uranusDistS.toFixed(6), neptuneRA.toFixed(6), neptuneDec.toFixed(6), neptuneDistE.toFixed(6), neptuneDistS.toFixed(6)]);

    /* yield to browser every YIELD_EVERY rows to prevent timeout */
    if (++done % YIELD_EVERY === 0) {
      await new Promise(requestAnimationFrame);
    }
  }

  /* restore viewer */
  o.Time = oldTime;
  jumpToJulianDay(oldJD);
  o.Run = oldRun;

  const CSV_THRESHOLD = 5000;

  if (jds.length > CSV_THRESHOLD) {
    /* --- Large dataset: export as TSV files (tab-separated, works in all Excel locales) --- */

    // Detect locale decimal separator (uses system regional settings)
    const decimalSeparator = (1.1).toLocaleString().charAt(1);
    const useCommaDecimal = decimalSeparator === ',';

    // Helper to convert array of arrays to TSV string (tab-separated)
    // Automatically uses the correct decimal separator based on system locale
    const arrayToTSV = (rows) => rows.map(row =>
      row.map(cell => {
        let str = String(cell);
        // Replace decimal point with comma if locale uses comma as decimal separator
        if (useCommaDecimal && (typeof cell === 'number' || (!isNaN(cell) && str.includes('.')))) {
          str = str.replace(/\./g, ',');
        }
        return str.replace(/\t/g, ' ').replace(/\n/g, ' ');
      }).join('\t')
    ).join('\n');

    // Create and download each TSV file
    const downloadTSV = (rows, filename) => {
      const tsv = arrayToTSV(rows);
      const blob = new Blob([tsv], { type: 'text/tab-separated-values;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      Object.assign(document.createElement('a'),
        { href: url, download: filename }).click();
      URL.revokeObjectURL(url);
    };

    await new Promise(requestAnimationFrame);
    downloadTSV(earthRows, 'Holistic_objects_EarthLongitude.tsv');

    await new Promise(requestAnimationFrame);
    downloadTSV(periRows, 'Holistic_objects_PerihelionPlanets.tsv');

    await new Promise(requestAnimationFrame);
    downloadTSV(planetRows, 'Holistic_objects_SunPlanets.tsv');

  } else {
    /* --- Small dataset: export as Excel --- */
    await ensureSheetJs();
    const wb = XLSX.utils.book_new();

    // Convert string numbers to actual numbers for Excel
    // Excel stores numbers in binary format and displays according to user's locale
    // This ensures consistent behavior regardless of export machine's locale
    const processRowsForExcel = (rows) => rows.map(row =>
      row.map(cell => {
        // If it's a string that looks like a number with decimal point, convert to number
        if (typeof cell === 'string' && !isNaN(cell) && cell.includes('.')) {
          return parseFloat(cell);
        }
        return cell;
      })
    );

    XLSX.utils.book_append_sheet(wb,
        XLSX.utils.aoa_to_sheet(processRowsForExcel(earthRows)),  'Earth Longitude');
    await new Promise(requestAnimationFrame);

    XLSX.utils.book_append_sheet(wb,
        XLSX.utils.aoa_to_sheet(processRowsForExcel(periRows)),   'Perihelion Planets');
    await new Promise(requestAnimationFrame);

    XLSX.utils.book_append_sheet(wb,
        XLSX.utils.aoa_to_sheet(processRowsForExcel(planetRows)), 'Sun & Planets');
    await new Promise(requestAnimationFrame);

    try {
      const wbBlob = workbookToBlob(wb);
      const url    = URL.createObjectURL(wbBlob);

      Object.assign(document.createElement('a'),
        { href: url, download: 'Holistic_objects_results.xlsx' }).click();
      URL.revokeObjectURL(url);
    } catch (err) {
      alert(`Failed to create Excel file: ${err.message}\n\nTry reducing data points below ${CSV_THRESHOLD}.`);
    }
  }
}

// ================================================================
// PLANET POSITION REPORT - Step 5 of Planet Hierarchy Inspector
// ================================================================

/**
 * Convert RA in radians to HMS format string (matches radiansToRa but with more precision)
 */
function raToHMSFromRadians(rad) {
  if (rad < 0) rad += 2 * Math.PI;
  const totalHours = rad * 12 / Math.PI;
  const h = Math.floor(totalHours);
  const mFloat = (totalHours - h) * 60;
  const m = Math.floor(mFloat);
  const s = (mFloat - m) * 60;
  return `${h}h ${m.toString().padStart(2, '0')}m ${s.toFixed(2).padStart(5, '0')}s`;
}

/**
 * Convert RA in decimal hours (e.g., 7.682) to HMS format string
 */
function raDecimalHoursToHMS(decimalHours) {
  const totalHours = parseFloat(decimalHours);
  if (isNaN(totalHours)) return decimalHours;
  const h = Math.floor(totalHours);
  const mFloat = (totalHours - h) * 60;
  const m = Math.floor(mFloat);
  const s = (mFloat - m) * 60;
  return `${h}h ${m.toString().padStart(2, '0')}m ${s.toFixed(2).padStart(5, '0')}s`;
}

/**
 * Convert Dec from decimal degrees (e.g., 18.8969 or -23.5) to DMS format string
 */
function decDecimalDegreesToDMS(decimalDegrees) {
  const deg = parseFloat(decimalDegrees);
  if (isNaN(deg)) return decimalDegrees;

  const sign = deg < 0 ? '-' : '+';
  const absDeg = Math.abs(deg);

  const d = Math.floor(absDeg);
  const mFloat = (absDeg - d) * 60;
  const m = Math.floor(mFloat);
  const s = (mFloat - m) * 60;
  return `${sign}${d}° ${m.toString().padStart(2, '0')}' ${s.toFixed(1).padStart(4, '0')}"`;
}

/**
 * Convert Dec in radians (spherical phi) to DMS format string (matches radiansToDec but with more precision)
 */
function decToDMSFromRadians(rad) {
  // Convert spherical phi to standard declination (0 at equator, ±90 at poles)
  rad = (rad <= 0) ? rad + Math.PI / 2 : Math.PI / 2 - rad;
  let degDec = rad * 180 / Math.PI;

  const sign = degDec < 0 ? '-' : '+';
  degDec = Math.abs(degDec);

  const d = Math.floor(degDec);
  const mFloat = (degDec - d) * 60;
  const m = Math.floor(mFloat);
  const s = (mFloat - m) * 60;
  return `${sign}${d}° ${m.toString().padStart(2, '0')}' ${s.toFixed(1).padStart(4, '0')}"`;
}

/**
 * Convert Julian Day to calendar date string
 */
function jdToDateString(jd) {
  // Julian Day to calendar date conversion
  const z = Math.floor(jd + 0.5);
  const f = jd + 0.5 - z;
  let a = z;
  if (z >= 2299161) {
    const alpha = Math.floor((z - 1867216.25) / 36524.25);
    a = z + 1 + alpha - Math.floor(alpha / 4);
  }
  const b = a + 1524;
  const c = Math.floor((b - 122.1) / 365.25);
  const d = Math.floor(365.25 * c);
  const e = Math.floor((b - d) / 30.6001);

  const day = b - d - Math.floor(30.6001 * e);
  const month = e < 14 ? e - 1 : e - 13;
  const year = month > 2 ? c - 4716 : c - 4715;

  // Time from fractional day
  const totalHours = f * 24;
  const hours = Math.floor(totalHours);
  const mins = Math.floor((totalHours - hours) * 60);
  const secs = Math.floor(((totalHours - hours) * 60 - mins) * 60);

  return {
    date: `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`,
    time: `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  };
}

/**
 * Collect position and longitude data for a specific planet at current simulation state
 */
function collectPlanetDataForDate(planetKey, testDate) {
  const planet = PLANET_OBJECTS[planetKey]();
  const dateInfo = jdToDateString(testDate.jd);

  // Position data - store raw radians for proper conversion
  const planetRARad = planet.ra;
  const planetDecRad = planet.dec;
  const planetDistE = planet.distAU;
  const planetDistS = planet.sunDistAU;
  const sunRARad = sun.ra;
  const sunDecRad = sun.dec;
  const sunDistE = sun.distAU;

  // Reference values from test date (if provided, for position types)
  const refDec = testDate.dec || '';
  const refRA = testDate.ra;  // Reference RA in decimal hours (e.g., 7.682)
  const refLongitude = testDate.longitude;  // Reference longitude in degrees (for Occultation)
  const comparePlanet = testDate.comparePlanet;  // Companion planet key (for Occultation)

  // Longitude data from o object
  const longPeriCalc = o[`${planetKey}Perihelion`];
  const longPeriRef = LONGITUDE_PERIHELION_REFS[planetKey];
  const ascNodeCalc = o[`${planetKey}AscendingNode`];
  const ascNodeRef = ASCENDING_NODE_REFS[planetKey];
  const argPeriCalc = o[`${planetKey}ArgumentOfPeriapsis`];

  return {
    dateInfo,
    position: {
      planetRARad,
      planetDecRad,
      planetDistE,
      planetDistS,
      sunRARad,
      sunDecRad,
      sunDistE,
      refDec,
      refRA,
      refLongitude,
      comparePlanet
    },
    longitude: {
      longPeriCalc,
      longPeriRef,
      longPeriDiff: longPeriCalc - longPeriRef,
      ascNodeCalc,
      ascNodeRef,
      ascNodeDiff: ascNodeCalc - ascNodeRef,
      argPeriCalc,
      argPeriDerived: ((longPeriCalc - ascNodeCalc) % 360 + 360) % 360
    },
    positionRow: (() => {
      // Get companion planet data if comparePlanet is specified
      let companionRA = '';
      let companionDec = '';
      if (comparePlanet && PLANET_OBJECTS[comparePlanet]) {
        const companion = PLANET_OBJECTS[comparePlanet]();
        companionRA = raToHMSFromRadians(companion.ra);
        companionDec = decToDMSFromRadians(companion.dec);
      }

      // Format reference RA (from decimal hours if provided)
      const refRAFormatted = refRA ? raDecimalHoursToHMS(refRA) : '';

      // Format reference longitude-derived RA (if longitude provided)
      const refLongitudeRA = refLongitude ? longitudeToRAHMS(refLongitude) : '';

      return [
        String(testDate.jd),  // Force as string to avoid comma/dot issues
        dateInfo.date,
        dateInfo.time,
        testDate.label,
        raToHMSFromRadians(planetRARad),
        decToDMSFromRadians(planetDecRad),
        refRAFormatted || refLongitudeRA,  // Reference RA (from ra field or longitude)
        refDec,  // Reference Dec (empty if not provided)
        refLongitude || '',  // Reference Longitude
        comparePlanet || '',  // Compare Planet
        companionRA,  // Companion RA
        companionDec,  // Companion Dec
        planetDistE.toFixed(8),
        planetDistS.toFixed(8),
        raToHMSFromRadians(sunRARad),
        decToDMSFromRadians(sunDecRad),
        sunDistE.toFixed(8)
      ];
    })(),
    longitudeRow: [
      String(testDate.jd),  // Force as string to avoid comma/dot issues
      dateInfo.date,
      dateInfo.time,
      testDate.label,
      longPeriCalc.toFixed(6),
      longPeriRef.toFixed(6),
      (longPeriCalc - longPeriRef).toFixed(6),
      ascNodeCalc.toFixed(6),
      ascNodeRef.toFixed(6),
      (ascNodeCalc - ascNodeRef).toFixed(6),
      argPeriCalc.toFixed(6)
    ]
  };
}

/**
 * Build the report header for screen display
 */
function buildReportHeader(planetKey) {
  const planetLabel = PLANET_HIERARCHIES[planetKey]?.label || planetKey;
  return `POSITION REPORT: ${planetLabel}\n${'='.repeat(50)}\n\n`;
}

/**
 * Compare calculated Dec with reference Dec and determine match status
 * Returns: 'match' if within 1 degree, 'mismatch' otherwise, or 'none' if no reference
 */
function compareDecValues(calculatedDecRad, refDecStr) {
  if (!refDecStr) return 'none';

  // Convert calculated Dec from radians to degrees (same as decToDMSFromRadians)
  let rad = calculatedDecRad;
  rad = (rad <= 0) ? rad + Math.PI / 2 : Math.PI / 2 - rad;
  const calculatedDeg = rad * 180 / Math.PI;

  // Parse reference Dec (it's in decimal degrees as a string like "-14.68" or "15.61")
  const refDeg = parseFloat(refDecStr);

  if (isNaN(refDeg)) return 'none';

  // Compare - within 1 degree is a match
  const diff = Math.abs(calculatedDeg - refDeg);
  return diff <= 1.0 ? 'match' : 'mismatch';
}

/**
 * Compare Planet RA vs Sun RA (for NASA transit dates)
 * Returns: 'green' if within 5 minutes, 'amber' if 5-15 minutes, 'red' if > 15 minutes
 */
function compareRAToSun(planetRARad, sunRARad) {
  // Convert both to total minutes (0-1440 for 24 hours)
  let planetMinutes = (planetRARad * 12 / Math.PI) * 60;
  let sunMinutes = (sunRARad * 12 / Math.PI) * 60;

  // Normalize to 0-1440 range
  if (planetMinutes < 0) planetMinutes += 1440;
  if (sunMinutes < 0) sunMinutes += 1440;

  // Calculate difference in minutes, accounting for wrap-around at 24h
  let diffMinutes = Math.abs(planetMinutes - sunMinutes);
  if (diffMinutes > 720) diffMinutes = 1440 - diffMinutes;

  // Return status based on thresholds
  if (diffMinutes <= 5) return 'green';
  if (diffMinutes <= 15) return 'amber';
  return 'red';
}

/**
 * Compare Planet RA vs Sun RA for Opposition (should be 12 hours / 720 minutes apart)
 * Returns: 'green' if within 5 minutes of 12h, 'amber' if 5-15 minutes, 'red' if > 15 minutes
 */
function compareRAOpposition(planetRARad, sunRARad) {
  // Convert both to total minutes (0-1440 for 24 hours)
  let planetMinutes = (planetRARad * 12 / Math.PI) * 60;
  let sunMinutes = (sunRARad * 12 / Math.PI) * 60;

  // Normalize to 0-1440 range
  if (planetMinutes < 0) planetMinutes += 1440;
  if (sunMinutes < 0) sunMinutes += 1440;

  // Calculate difference in minutes, accounting for wrap-around at 24h
  let diffMinutes = Math.abs(planetMinutes - sunMinutes);
  if (diffMinutes > 720) diffMinutes = 1440 - diffMinutes;

  // For opposition, we expect 720 minutes (12 hours) difference
  // Calculate how far from 720 minutes we are
  const deviationFromOpposition = Math.abs(diffMinutes - 720);

  // Return status based on thresholds (deviation from perfect 12h opposition)
  if (deviationFromOpposition <= 5) return 'green';
  if (deviationFromOpposition <= 15) return 'amber';
  return 'red';
}

/**
 * Compare Planet RA vs Reference RA (for model validation dates)
 * refRA is in decimal hours (e.g., 7.682 for ~7h 40m)
 * Returns: 'green' if within 5 minutes, 'amber' if 5-15 minutes, 'red' if > 15 minutes, 'none' if no reference
 */
function compareRAToReference(planetRARad, refRA) {
  if (refRA === undefined || refRA === null) return 'none';

  // Convert planet RA from radians to minutes
  let planetMinutes = (planetRARad * 12 / Math.PI) * 60;
  if (planetMinutes < 0) planetMinutes += 1440;

  // Convert reference RA from decimal hours to minutes
  let refMinutes = parseFloat(refRA) * 60;
  if (isNaN(refMinutes)) return 'none';
  if (refMinutes < 0) refMinutes += 1440;

  // Calculate difference in minutes, accounting for wrap-around at 24h
  let diffMinutes = Math.abs(planetMinutes - refMinutes);
  if (diffMinutes > 720) diffMinutes = 1440 - diffMinutes;

  // Return status based on thresholds
  if (diffMinutes <= 5) return 'green';
  if (diffMinutes <= 15) return 'amber';
  return 'red';
}

/**
 * Convert ecliptic longitude (degrees) to RA (radians)
 * Uses proper ecliptic-to-equatorial coordinate transformation
 * Assumes ecliptic latitude ≈ 0 (appropriate for Jupiter-Saturn conjunctions near the ecliptic)
 * @param {number|string} longitudeDeg - Ecliptic longitude in degrees
 * @param {number} obliquityDeg - Obliquity of the ecliptic in degrees (defaults to o.obliquityEarth)
 */
function longitudeToRARad(longitudeDeg, obliquityDeg) {
  const lon = parseFloat(longitudeDeg);
  if (isNaN(lon)) return null;

  // Use provided obliquity or get from global o object
  const obliquity = obliquityDeg !== undefined ? obliquityDeg : (o.obliquityEarth || 23.4393);
  const obliquityRad = obliquity * Math.PI / 180;
  const lonRad = lon * Math.PI / 180;

  // For a point on the ecliptic (ecliptic latitude = 0):
  // tan(RA) = sin(λ) * cos(ε) / cos(λ)
  // RA = atan2(sin(λ) * cos(ε), cos(λ))
  let raRad = Math.atan2(Math.sin(lonRad) * Math.cos(obliquityRad), Math.cos(lonRad));

  // Normalize to [0, 2π)
  if (raRad < 0) raRad += 2 * Math.PI;
  return raRad;
}

/**
 * Convert ecliptic longitude (degrees) to RA in HMS format string
 * Uses proper ecliptic-to-equatorial coordinate transformation
 * @param {number|string} longitudeDeg - Ecliptic longitude in degrees
 * @param {number} obliquityDeg - Obliquity of the ecliptic in degrees (defaults to o.obliquityEarth)
 */
function longitudeToRAHMS(longitudeDeg, obliquityDeg) {
  const lon = parseFloat(longitudeDeg);
  if (isNaN(lon)) return longitudeDeg;

  // Use provided obliquity or get from global o object
  const obliquity = obliquityDeg !== undefined ? obliquityDeg : (o.obliquityEarth || 23.4393);
  const obliquityRad = obliquity * Math.PI / 180;
  const lonRad = lon * Math.PI / 180;

  // For a point on the ecliptic (ecliptic latitude = 0):
  // RA = atan2(sin(λ) * cos(ε), cos(λ))
  let raRad = Math.atan2(Math.sin(lonRad) * Math.cos(obliquityRad), Math.cos(lonRad));
  if (raRad < 0) raRad += 2 * Math.PI;

  // Convert radians to decimal hours (RA in hours = radians * 12 / π)
  const decimalHours = raRad * 12 / Math.PI;
  const h = Math.floor(decimalHours);
  const mFloat = (decimalHours - h) * 60;
  const m = Math.floor(mFloat);
  const s = (mFloat - m) * 60;
  return `${h}h ${m.toString().padStart(2, '0')}m ${s.toFixed(2).padStart(5, '0')}s`;
}

/**
 * Compare Planet RA vs Longitude-derived RA (for Occultation dates)
 * Uses proper ecliptic-to-equatorial coordinate transformation
 * @param {number} planetRARad - Planet RA in radians
 * @param {number|string} longitudeDeg - Ecliptic longitude in degrees (e.g., 55.77)
 * @param {number} obliquityDeg - Obliquity of the ecliptic in degrees (defaults to o.obliquityEarth)
 * @returns {'green'|'amber'|'red'|'none'} - Status based on difference thresholds
 */
function compareRAToLongitude(planetRARad, longitudeDeg, obliquityDeg) {
  if (longitudeDeg === undefined || longitudeDeg === null) return 'none';

  // Convert planet RA from radians to minutes
  let planetMinutes = (planetRARad * 12 / Math.PI) * 60;
  if (planetMinutes < 0) planetMinutes += 1440;

  // Convert ecliptic longitude to RA using proper transformation
  const refRARad = longitudeToRARad(longitudeDeg, obliquityDeg);
  if (refRARad === null) return 'none';

  // Convert reference RA to minutes
  let refMinutes = (refRARad * 12 / Math.PI) * 60;
  if (refMinutes < 0) refMinutes += 1440;

  // Calculate difference in minutes, accounting for wrap-around at 24h
  let diffMinutes = Math.abs(planetMinutes - refMinutes);
  if (diffMinutes > 720) diffMinutes = 1440 - diffMinutes;

  // Return status based on thresholds
  if (diffMinutes <= 5) return 'green';
  if (diffMinutes <= 15) return 'amber';
  return 'red';
}

/**
 * Get companion planet RA for Occultation comparison
 * Returns the RA in radians of the specified planet at current simulation state
 */
function getCompanionPlanetRA(companionKey) {
  const planetGetter = PLANET_OBJECTS[companionKey];
  if (!planetGetter) return null;
  const planet = planetGetter();
  return planet.ra;
}

/**
 * Build a date section for screen display (HTML format with color coding)
 */
function buildDateSection(planetKey, testDate, data) {
  const planetLabel = PLANET_HIERARCHIES[planetKey]?.label || planetKey;
  let section = '';

  // Use ASCII box drawing for consistent width across all fonts
  const W = 48; // content width
  const HR = '-'.repeat(W); // horizontal rule

  section += `+${HR}+\n`;
  section += `|  ${testDate.label.padEnd(W - 2)}|\n`;
  section += `|  JD: ${testDate.jd}  |  ${data.dateInfo.date} ${data.dateInfo.time}`.padEnd(W + 1) + `|\n`;
  section += `+${HR}+\n`;

  // Position data
  if (testDate.type === 'position' || testDate.type === 'both') {
    // Determine comparison mode based on label and comparePlanet field
    const isNasaDate = testDate.label.toLowerCase().includes('nasa');
    const isOpposition = testDate.label.toLowerCase().includes('opposition');
    const isOccultation = !!data.position.comparePlanet;  // Has companion planet to compare

    // Helper to get color from status
    const getColorFromStatus = (status) => {
      if (status === 'green') return '#4caf50';
      if (status === 'amber') return '#ffb300';
      if (status === 'red') return '#ff5252';
      return '#e8e8e8'; // 'none' - no reference, use default white
    };

    section += `|  POSITION DATA`.padEnd(W + 1) + `|\n`;
    section += `|  ${'-'.repeat(W - 4)}  |\n`;

    if (isOccultation) {
      // Occultation: Compare both planets against reference longitude-derived RA
      const refLongitude = data.position.refLongitude;
      const companionKey = data.position.comparePlanet;
      const companionLabel = PLANET_HIERARCHIES[companionKey]?.label || companionKey;
      const companionRARad = getCompanionPlanetRA(companionKey);

      // Compare current planet RA to longitude reference (only if longitude provided)
      const planetRAStatus = refLongitude != null ? compareRAToLongitude(data.position.planetRARad, refLongitude) : 'none';
      const planetRAColor = getColorFromStatus(planetRAStatus);

      // Compare companion planet RA to longitude reference (only if longitude provided)
      const companionRAStatus = refLongitude != null ? compareRAToLongitude(companionRARad, refLongitude) : 'none';
      const companionRAColor = getColorFromStatus(companionRAStatus);

      // Reference RA from longitude (only show if longitude provided)
      if (refLongitude != null) {
        const refRAValue = longitudeToRAHMS(refLongitude);
        const refRAContent = 'Reference RA:'.padEnd(24) + refRAValue.padStart(22);
        section += `|  ${refRAContent}|\n`;

        // Show longitude value
        const longContent = `(from longitude ${refLongitude}°)`.padEnd(46);
        section += `|  ${longContent}|\n`;

        section += `|  ${'-'.repeat(W - 4)}  |\n`;
      }

      // Current planet RA (color-coded)
      const planetRAValue = raToHMSFromRadians(data.position.planetRARad);
      const planetRAContentLine = `${planetLabel} RA:`.padEnd(24) + planetRAValue.padStart(22);
      section += `|  <span style="color:${planetRAColor}">${planetRAContentLine}</span>|\n`;

      // Current planet Dec
      const decValue = decToDMSFromRadians(data.position.planetDecRad);
      section += `|  ${(`${planetLabel} Dec:`.padEnd(24) + decValue.padStart(22))}|\n`;

      section += `|  ${'-'.repeat(W - 4)}  |\n`;

      // Companion planet RA (color-coded independently)
      const companionRAValue = raToHMSFromRadians(companionRARad);
      const companionRAContentLine = `${companionLabel} RA:`.padEnd(24) + companionRAValue.padStart(22);
      section += `|  <span style="color:${companionRAColor}">${companionRAContentLine}</span>|\n`;

      // Companion planet Dec
      const companionPlanet = PLANET_OBJECTS[companionKey]();
      const companionDecValue = decToDMSFromRadians(companionPlanet.dec);
      section += `|  ${(`${companionLabel} Dec:`.padEnd(24) + companionDecValue.padStart(22))}|\n`;

    } else {
      // Standard comparison (NASA, Opposition, Model start date, etc.)
      let raStatus;
      if (isOpposition) {
        // Opposition dates: Planet RA should be ~12h away from Sun RA
        raStatus = compareRAOpposition(data.position.planetRARad, data.position.sunRARad);
      } else if (isNasaDate) {
        // NASA dates: compare Planet RA vs Sun RA (transit check)
        raStatus = compareRAToSun(data.position.planetRARad, data.position.sunRARad);
      } else {
        // Other dates (e.g., Model start date): compare Planet RA vs Reference RA
        raStatus = compareRAToReference(data.position.planetRARad, data.position.refRA);
      }

      const raColor = getColorFromStatus(raStatus);

      // Color-coded Planet RA
      const planetRAValue = raToHMSFromRadians(data.position.planetRARad);
      const planetRAContent = `${planetLabel} RA:`.padEnd(24) + planetRAValue.padStart(22);
      section += `|  <span style="color:${raColor}">${planetRAContent}</span>|\n`;

      // Show reference RA if provided (for non-NASA dates) - same color as Planet RA
      if (!isNasaDate && !isOpposition && data.position.refRA) {
        const refRAValue = raDecimalHoursToHMS(data.position.refRA);
        const refRAContent = 'Reference RA:'.padEnd(24) + refRAValue.padStart(22);
        section += `|  <span style="color:${raColor}">${refRAContent}</span>|\n`;
      }

      // Dec line (no color coding)
      const decValue = decToDMSFromRadians(data.position.planetDecRad);
      section += `|  ${(`${planetLabel} Dec:`.padEnd(24) + decValue.padStart(22))}|\n`;

      // Show reference Dec if provided (no color coding)
      if (data.position.refDec) {
        const refDecValue = decDecimalDegreesToDMS(data.position.refDec);
        section += `|  ${('Reference Dec:'.padEnd(24) + refDecValue.padStart(22))}|\n`;
      }
      section += `|  ${(`${planetLabel} Dist Earth:`.padEnd(24) + (data.position.planetDistE.toFixed(6) + ' AU').padStart(22))}|\n`;
      section += `|  ${(`${planetLabel} Dist Sun:`.padEnd(24) + (data.position.planetDistS.toFixed(6) + ' AU').padStart(22))}|\n`;

      // Show Sun data for NASA dates (transit) and Opposition dates
      if (isNasaDate || isOpposition) {
        section += `|  ${'-'.repeat(W - 4)}  |\n`;

        // Color-coded Sun RA (same color as Planet RA since they're being compared)
        const sunRAValue = raToHMSFromRadians(data.position.sunRARad);
        const sunRAContent = 'Sun RA:'.padEnd(24) + sunRAValue.padStart(22);
        section += `|  <span style="color:${raColor}">${sunRAContent}</span>|\n`;

        section += `|  ${('Sun Dec:'.padEnd(24) + decToDMSFromRadians(data.position.sunDecRad).padStart(22))}|\n`;
        section += `|  ${('Sun Dist Earth:'.padEnd(24) + (data.position.sunDistE.toFixed(6) + ' AU').padStart(22))}|\n`;
      }
    }
  }

  // Longitude data
  if (testDate.type === 'longitude' || testDate.type === 'both') {
    if (testDate.type === 'both') {
      section += `+${HR}+\n`;
    }
    section += `|  LONGITUDE DATA`.padEnd(W + 1) + `|\n`;
    section += `|  ${'-'.repeat(W - 4)}  |\n`;
    section += `|  Longitude of Perihelion (ϖ)`.padEnd(W + 1) + `|\n`;
    section += `|  ${('  Calculated:'.padEnd(24) + (data.longitude.longPeriCalc.toFixed(6) + '°').padStart(22))}|\n`;
    section += `|  ${('  Reference:'.padEnd(24) + (data.longitude.longPeriRef.toFixed(6) + '°').padStart(22))}|\n`;
    section += `|  ${('  Difference:'.padEnd(24) + (data.longitude.longPeriDiff.toFixed(6) + '°').padStart(22))}|\n`;
    section += `|  ${'-'.repeat(W - 4)}  |\n`;
    section += `|  Longitude of Ascending Node (Ω)`.padEnd(W + 1) + `|\n`;
    section += `|  ${('  Calculated:'.padEnd(24) + (data.longitude.ascNodeCalc.toFixed(6) + '°').padStart(22))}|\n`;
    section += `|  ${('  Reference:'.padEnd(24) + (data.longitude.ascNodeRef.toFixed(6) + '°').padStart(22))}|\n`;
    section += `|  ${('  Difference:'.padEnd(24) + (data.longitude.ascNodeDiff.toFixed(6) + '°').padStart(22))}|\n`;
    section += `|  ${'-'.repeat(W - 4)}  |\n`;
    section += `|  Argument of Periapsis (ω)`.padEnd(W + 1) + `|\n`;
    section += `|  ${('  Calculated:'.padEnd(24) + (data.longitude.argPeriCalc.toFixed(6) + '°').padStart(22))}|\n`;
    section += `|  ${('  (ϖ - Ω):'.padEnd(24) + (data.longitude.argPeriDerived.toFixed(6) + '°').padStart(22))}|\n`;
  }

  section += `+${HR}+\n\n`;
  return section;
}

/**
 * Generate the planet position report for Step 5
 * @param {string} planetKey - The planet identifier
 * @param {boolean} showAll - If true, show all results regardless of showOnScreen flag
 */
async function generatePlanetReport(planetKey, showAll = false) {
  const testDates = PLANET_TEST_DATES[planetKey];
  if (!testDates || testDates.length === 0) {
    return { screenReport: 'No test dates configured for this planet.', excelData: null };
  }

  // Save current state
  const savedState = {
    run: o.Run,
    julianDay: o.julianDay,
    time: o.Time,
    pos: o.pos
  };

  o.Run = false;

  let screenReport = buildReportHeader(planetKey);
  const positionRows = [[
    'JD', 'Date', 'Time', 'Label',
    'Planet RA', 'Planet Dec',
    'Reference RA', 'Reference Dec', 'Reference Longitude',
    'Compare Planet', 'Companion RA', 'Companion Dec',
    'Planet Dist Earth (AU)', 'Planet Dist Sun (AU)',
    'Sun RA', 'Sun Dec', 'Sun Dist Earth (AU)'
  ]];
  const longitudeRows = [['JD', 'Date', 'Time', 'Label', 'Long Perihelion Calc (°)', 'Long Perihelion Ref (°)', 'Long Perihelion Diff (°)', 'Asc Node Calc (°)', 'Asc Node Ref (°)', 'Asc Node Diff (°)', 'Arg Periapsis Calc (°)']];

  // Process each test date
  for (const testDate of testDates) {
    jumpToJulianDay(testDate.jd);
    forceSceneUpdate();

    const data = collectPlanetDataForDate(planetKey, testDate);

    // Always add to Excel data
    if (testDate.type === 'position' || testDate.type === 'both') {
      positionRows.push(data.positionRow);
    }
    if (testDate.type === 'longitude' || testDate.type === 'both') {
      longitudeRows.push(data.longitudeRow);
    }

    // Add to screen report if showOnScreen is true OR showAll is enabled
    if (testDate.showOnScreen || showAll) {
      screenReport += buildDateSection(planetKey, testDate, data);
    }
  }

  // Restore state
  o.Run = savedState.run;
  jumpToJulianDay(savedState.julianDay);
  o.Time = savedState.time;
  o.pos = savedState.pos;
  forceSceneUpdate();

  return {
    screenReport,
    excelData: { positionRows, longitudeRows }
  };
}

/**
 * Export planet report to Excel file
 */
async function exportPlanetReportToExcel(planetKey, excelData) {
  await ensureSheetJs();

  const planetLabel = PLANET_HIERARCHIES[planetKey]?.label || planetKey;
  const wb = XLSX.utils.book_new();

  // Create Documentation front sheet
  const docRows = [
    ['PLANET POSITION REPORT - DOCUMENTATION'],
    [''],
    ['Planet:', planetLabel],
    ['Generated:', new Date().toISOString()],
    ['Model Start Date:', 'JD 2451716.5 (June 21, 2000 00:00 UTC)'],
    [''],
    ['DATA SOURCES'],
    ['─'.repeat(60)],
    ['Mercury transits:', 'https://eclipse.gsfc.nasa.gov/transit/catalog/MercuryCatalog.html (NASA GSFC)'],
    ['Venus transits:', 'https://eclipse.gsfc.nasa.gov/transit/catalog/VenusCatalog.html (NASA GSFC)'],
    ['Mars oppositions:', 'https://stjerneskinn.com/mars-at-opposition.htm (Jean Meeus tables)'],
    ['', 'https://www.nakedeyeplanets.com/mars-oppositions.htm'],
    ['Jupiter/Saturn conjunctions:', 'https://astropixels.com/ephemeris/planets/jupiter2020.html (JPL DE405)'],
    ['', 'https://www.astropro.com/features/tables/geo/ju-sa/ju000sa.html'],
    ['Mutual planetary occultations:', 'https://en.wikipedia.org/wiki/List_of_mutual_planetary_eclipses'],
    ['', 'https://www.projectpluto.com/mut_pln.htm'],
    ['', 'https://www.bogan.ca/astro/occultations/occltlst.htm'],
    [''],
    ['COLUMN DESCRIPTIONS'],
    ['─'.repeat(60)],
    ['JD:', 'Julian Day number'],
    ['Date/Time:', 'Calendar date and time (UTC)'],
    ['Label:', 'Event type (NASA date, Opposition, Occultation, etc.)'],
    ['Planet RA:', 'Calculated Right Ascension of the planet'],
    ['Planet Dec:', 'Calculated Declination of the planet'],
    ['Reference RA:', 'Reference Right Ascension from source data (if provided)'],
    ['Reference Dec:', 'Reference Declination from source data (if provided)'],
    ['Reference Longitude:', 'Ecliptic longitude from source data (for conjunctions)'],
    ['Compare Planet:', 'Companion planet for occultation comparisons'],
    ['Companion RA/Dec:', 'Position of companion planet at same date'],
    ['Planet Dist Earth/Sun:', 'Distance in AU from Earth/Sun'],
    [''],
    ['CALCULATIONS'],
    ['─'.repeat(60)],
    ['Longitude to RA conversion:', 'Uses proper ecliptic-to-equatorial transformation'],
    ['Formula:', 'RA = atan2(sin(λ) × cos(ε), cos(λ))'],
    ['', 'where λ = ecliptic longitude, ε = obliquity (~23.44°)'],
    ['Obliquity source:', 'Dynamic value from o.obliquityEarth at simulation date'],
    [''],
    ['COLOR CODING (in screen report)'],
    ['─'.repeat(60)],
    ['Green:', 'Difference ≤ 5 minutes of RA'],
    ['Amber:', 'Difference 5-15 minutes of RA'],
    ['Red:', 'Difference > 15 minutes of RA'],
  ];
  XLSX.utils.book_append_sheet(wb,
    XLSX.utils.aoa_to_sheet(docRows),
    'Documentation');

  if (excelData.positionRows.length > 1) {
    XLSX.utils.book_append_sheet(wb,
      XLSX.utils.aoa_to_sheet(excelData.positionRows),
      `${planetLabel} Position`);
  }

  if (excelData.longitudeRows.length > 1) {
    XLSX.utils.book_append_sheet(wb,
      XLSX.utils.aoa_to_sheet(excelData.longitudeRows),
      `${planetLabel} Longitude`);
  }

  const wbBlob = workbookToBlob(wb);
  const url = URL.createObjectURL(wbBlob);
  Object.assign(document.createElement('a'),
    { href: url, download: `${planetKey}_position_report.xlsx` }).click();
  URL.revokeObjectURL(url);
}

/**
 * Copy report text to clipboard
 * Strips HTML tags (like color spans) from the text before copying
 */
function copyReportToClipboard(reportText) {
  // Remove HTML tags (e.g., <span style="color:...">...</span>) for plain text copy
  const plainText = reportText.replace(/<[^>]*>/g, '');
  navigator.clipboard.writeText(plainText)
    .then(() => {
      // Show brief feedback
      const copyBtn = document.querySelector('.hi-report-btn.copy');
      if (copyBtn) {
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'Copied!';
        setTimeout(() => { copyBtn.textContent = originalText; }, 1500);
      }
    })
    .catch(err => {
      console.error('Failed to copy report:', err);
    });
}

// Store current report data for button handlers
let _currentReportData = null;

/**
 * Generate and display the planet position report in the inspector panel
 */
async function generateAndDisplayReport(planetKey) {
  const panel = hierarchyInspector.panel;
  if (!panel) return;

  const reportElement = panel.querySelector('.hi-report');
  const loadingElement = panel.querySelector('.hi-report-loading');
  const buttonsElement = panel.querySelector('.hi-report-buttons');

  if (!reportElement || !loadingElement) return;

  // Show loading state
  loadingElement.style.display = 'block';
  reportElement.style.display = 'none';
  buttonsElement.style.display = 'none';

  try {
    // Get current showAll state from checkbox
    const showAllCheckbox = panel.querySelector('.hi-report-show-all');
    const showAll = showAllCheckbox ? showAllCheckbox.checked : false;

    // Generate the report
    const result = await generatePlanetReport(planetKey, showAll);

    // Store for button handlers
    _currentReportData = {
      planetKey,
      screenReport: result.screenReport,
      excelData: result.excelData
    };

    // Display the report (use innerHTML to render color-coded spans)
    reportElement.innerHTML = result.screenReport;
    loadingElement.style.display = 'none';
    reportElement.style.display = 'block';
    buttonsElement.style.display = 'flex';
  } catch (err) {
    console.error('Error generating report:', err);
    reportElement.textContent = `Error generating report: ${err.message}`;
    loadingElement.style.display = 'none';
    reportElement.style.display = 'block';
    buttonsElement.style.display = 'none';
  }
}

// ---------------------------------------------------------------------------
//  HELPER — "excess seconds per (mean) day" at the *current* JD
//  Positive  => Earth day is longer than 86 400 s  ➜ ΔT increases
//  Negative  => Earth day is shorter            ➜ ΔT decreases
// ---------------------------------------------------------------------------
function secondsExcessPerDay () {
  // `o.lengthofDay` must already hold the length of *this* day in seconds.
  // (If you compute that elsewhere each tick, just reference the same value.)
  return o.lengthofDay - 86400;
}

// ---------------------------------------------------------------------------
//  CALL THIS ONCE *EACH* SIMULATION STEP *AFTER* YOU ADVANCE YOUR CLOCK
//  (`currentJD` must be the new Julian Day number for the model)
// ---------------------------------------------------------------------------
function updateDeltaT() {
  const currentJD = o.julianDay;                       // use your existing value
  const daysElapsed = currentJD - state.prevJD;
  const excess = o.lengthofDay - 86400;

  if (isNaN(excess) || isNaN(daysElapsed)) {
    console.warn("Bad input to updateDeltaT", { excess, daysElapsed });
    return;
  }

  state.deltaT += excess * daysElapsed;
  state.prevJD = currentJD;
}

function resetDeltaTForJump() {
  /* ------------------------------------------------------------------ */
  const BASE_YEAR          = startmodelYear;
  const SUBSTEPS_PER_YEAR  = 10; 
  /* ------------------------------------------------------------------ */

  const targetYear = o.currentYear;
  const startYear  = Math.min(BASE_YEAR, targetYear);
  const endYear    = Math.max(BASE_YEAR, targetYear);

  let deltaTsum = 0;           // total change to apply to deltaTStart

  /* ── integrate whole years, sampling “one-year-before” each slice ── */
  for (let y = startYear; y < endYear; y++) {
    for (let i = 0; i < SUBSTEPS_PER_YEAR; i++) {

      /* sample ***one year earlier*** than the slice we are adding   */
      const subYear    = y + i / SUBSTEPS_PER_YEAR;
      const sourceYear = subYear - 1;

      const lod = computeLengthofDay(
        sourceYear,
        balancedYear,
        perihelionCycleLength,
        o.perihelionprecessioncycleYear,
        meansolardayAmplitudeinSeconds,
        meanlengthofday
      );

      const solarYear = computeLengthofsolarYear(
        sourceYear,
        balancedYear,
        perihelionCycleLength,
        o.perihelionprecessioncycleYear,
        meansolaryearAmplitudeinDays,
        meansolaryearlengthinDays
      );

      const dTchangePerYr = (lod - 86_400) * solarYear;       // seconds/yr
      deltaTsum += dTchangePerYr / SUBSTEPS_PER_YEAR;         // fraction
    }
  }

  /* ── fractional part of the final calendar year (if any) ─────────── */
  const frac = targetYear - Math.floor(targetYear);           // 0 … <1
  if (frac !== 0) {
    const y = Math.floor(targetYear);
    const slices = Math.round(SUBSTEPS_PER_YEAR * frac);

    for (let i = 0; i < slices; i++) {
      const subYear    = y + i / SUBSTEPS_PER_YEAR;
      const sourceYear = subYear - 1;

      const lod = computeLengthofDay(
        sourceYear,
        balancedYear,
        perihelionCycleLength,
        o.perihelionprecessioncycleYear,
        meansolardayAmplitudeinSeconds,
        meanlengthofday
      );

      const solarYear = computeLengthofsolarYear(
        sourceYear,
        balancedYear,
        perihelionCycleLength,
        o.perihelionprecessioncycleYear,
        meansolaryearAmplitudeinDays,
        meansolaryearlengthinDays
      );

      const dTchangePerYr = (lod - 86_400) * solarYear;
      deltaTsum += dTchangePerYr / SUBSTEPS_PER_YEAR;
    }
  }

  /* ── final ΔT: add for future, subtract for past ─────────────────── */
  const deltaT = (targetYear >= BASE_YEAR)
    ? deltaTStart + deltaTsum   // stepping FORWARD  → grows
    : deltaTStart - deltaTsum;  // stepping BACKWARD → shrinks

  state.deltaT = deltaT;
  state.prevJD = o.julianDay;     // avoid monster step on next frame
}

// ---------------------------------------------------------------------------
//  CONVENIENCE GETTERS — call whenever you need to *display* the values
// ---------------------------------------------------------------------------

// predicted change *per* tropical year at "right now"
function getDeltaTChangePerYear () {
  return secondsExcessPerDay() * o.lengthofsolarYear;  // seconds / yr
}

// total accumulated ΔT (seconds) since 2000-06-21
function getDeltaT () {
  return state.deltaT;
}

function detectAndUpdateDeltaT() {
  const currentJD = o.julianDay;
  const jumpThreshold = 5; // days – tune this as needed

  if (Math.abs(currentJD - state.prevJD) > jumpThreshold) {
    resetDeltaTForJump();
  } else {
    updateDeltaT();
  }
}

function focusPlanet(pd, pad = 1.01) {
  if (!pd?.planetObj) {
    // user picked "Please select" → remove limits
    controls.minDistance = 0;
    controls.maxDistance = Infinity;
    return;
  }

  /* — planet world-space centre — */
  // Update from root of hierarchy to ensure all parent transforms are current
  // (needed when called while simulation is paused/idle)
  startingPoint.pivotObj.updateMatrixWorld(true);
  pd.planetObj.getWorldPosition(_ctrWS);

  /* — scaled radius (uniform scaling assumed) — */
  pd.planetObj.getWorldScale(_scale);
  const R = pd.size * _scale.x;          // pd.size = "pretty" radius
  const minD = R * pad;

  controls.target.copy(_ctrWS);
  controls.minDistance = minD;
  controls.maxDistance = Infinity;        // generous zoom-out

  /* — if camera is *inside* new shell → pop it to the skin — */
  _offset.subVectors(camera.position, _ctrWS);
  if (_offset.length() < minD) {
    camera.position.copy(_ctrWS).add(_offset.setLength(minD));
    controls.update();                   // rebuild spherical coords
  }

  /* — near plane: 20 % of min distance for good z-precision — */
  camera.near = Math.max(0.01, minD * 0.2);
  camera.updateProjectionMatrix();
}

/**
 * Blow-up slider for the physical planets only.
 * Pass a slider value `t` ∈ [0, 1].
 */
function updatePlanetSizes(t) {

  t = THREE.MathUtils.clamp(t, 0, 1);   // safety against out-of-range
  const BOOST = 250.0;                    // max multiple at t = 1

  planetObjects.forEach(pd => {

    /* ignore helpers / ghost objects */
    if (pd.isNotPhysicalObject === true || pd.visible === false) return;
    if (!pd.rotationAxis) return;

    /* linear scale from 1 → BOOST */
    const scale = 1 + t * (BOOST - 1);  // 0 ↦ 1, 1 ↦ BOOST
    pd.rotationAxis.scale.setScalar(scale);
  });
}

function addWidthToggle(gui, sizes = [300, 550]) {
  let idx = 0;

  /* create the floating badge */
  const badge = document.createElement('div');
  badge.id = 'guiWidthToggle';
  badge.textContent = '⇆';
  document.body.appendChild(badge);

  /* positioning — centred beside the panel */
  function align() {
    const r  = gui.domElement.getBoundingClientRect();
    const bh = badge.getBoundingClientRect().height;
    badge.style.left = `${r.left - badge.offsetWidth}px`;
    badge.style.top  = `${r.top + (r.height - bh) / 2}px`;
  }
  align();                               // first run

  /* keep badge in place on window resizes */
  window.addEventListener('resize', align);

  /*—--- feature-detect ResizeObserver ----*/
  if ('ResizeObserver' in window) {
    new ResizeObserver(align).observe(gui.domElement);
  } else {
    /* fallback: re-align every 1 s on browsers without the API */
    setInterval(align, 1000);
  }

  /* click / tap toggles the panel width */
  badge.onclick = () => {
    idx = 1 - idx;
    gui.domElement.style.width = `${sizes[idx]}px`;
    align();                             // badge tracks the new width
  };
}

function initConstellations() {
  console.log(`⏳ initConstellations() [${o.constellationLayout}] fetching…`);

  fetch(constellationsUrl)
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      // build raw strokes
      const strokes = [];
      let stroke = [];
      data.asterismIndices.forEach(idx => {
        if (idx !== -1) {
          const ra  = data.rightAscension[idx];
          const dec = data.declination   [idx];
          if (!Number.isFinite(ra) || !Number.isFinite(dec)) return;
          const R = o.starDistance;
          stroke.push(new THREE.Vector3(
            R * Math.cos(dec) * Math.sin(ra),
            R * Math.sin(dec),
            R * Math.cos(dec) * Math.cos(ra)
          ));
        } else {
          if (stroke.length > 1) strokes.push(stroke);
          stroke = [];
        }
      });
      if (stroke.length > 1) strokes.push(stroke);
      console.log(`  → parsed ${strokes.length} strokes`);

      // clear old
      sceneObjects.constellations.clear();
      drawMaterials.length = 0;

      if (o.constellationLayout === 'asterism') {
        console.log('  → drawing ASTERISM segments');
        const pts = [];
        strokes.forEach(s => {
          for (let i = 0; i < s.length - 1; i++) pts.push(s[i], s[i+1]);
        });
        if (pts.length === 0) return;

        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        const distArr = new Float32Array(pts.length);
        let acc = 0;
        distArr[0] = 0;
        for (let i = 1; i < pts.length; i++) {
          acc += pts[i].distanceTo(pts[i - 1]);
          distArr[i] = acc;
        }
        geo.setAttribute('lineDistance', new THREE.BufferAttribute(distArr, 1));
        geo.computeBoundingSphere();

        const mesh = new THREE.LineSegments(geo, constellationMaterial);
        mesh.frustumCulled = false;
        sceneObjects.constellations.add(mesh);

        // single render if you’re not in a loop
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
        console.log('  → ASTERISM render complete');

      } else {
        console.log('  → drawing STELLARIUM curves');

        // build curves & collect materials
        strokes.forEach(pts => {
          if (pts.length < 2) return;
          const curve     = new THREE.CatmullRomCurve3(pts, false, 'catmullrom', 0.5);
          const divisions = pts.length * 5;
          const splinePts = curve.getPoints(divisions);

          const geo = new THREE.BufferGeometry().setFromPoints(splinePts);
          const count = splinePts.length;
          const dArr  = new Float32Array(count);
          dArr[0] = 0;
          let totalLen = 0;
          for (let i = 1; i < count; i++) {
            totalLen += splinePts[i].distanceTo(splinePts[i - 1]);
            dArr[i] = totalLen;
          }
          geo.setAttribute('lineDistance', new THREE.BufferAttribute(dArr, 1));
          geo.computeBoundingSphere();

          const mat = drawOnShaderProto.clone();
          mat.uniforms.uTotalLength.value = totalLen;
          mat.uniforms.uColor.value       = constellationMaterial.color.clone();
          drawMaterials.push(mat);

          const line = new THREE.Line(geo, mat);
          line.frustumCulled = false;
          sceneObjects.constellations.add(line);
        });

        console.log(`  → created ${drawMaterials.length} curved lines`);

        if (drawMaterials.length) {
          console.log('  → starting draw-on animation');
          const start    = performance.now();
          const duration = 2000;
          (function animateDraw() {
            const t = Math.min((performance.now() - start) / duration, 1);
            drawMaterials.forEach(m => m.uniforms.uDrawProgress.value = t);
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
            if (t < 1) requestAnimationFrame(animateDraw);
            else console.log('  → draw-on animation complete');
          })();
        }
      }
    })
    .catch(err => console.error('❌ initConstellations error:', err));
}

// — Make sure you have these at the top of your script —
// const bsc5url = 'https://raw.githubusercontent.com/dvansonsbeek/3d/main/public/input/stars.json';
// let starSizeMaterial = null;
// sceneObjects.stars = new THREE.Object3D();  scene.add(sceneObjects.stars);

function initStars() {
  console.log('⏳ initStars(): fetching', bsc5url);
  fetch(bsc5url)
    .then(r => {
      if (!r.ok) throw new Error(`Stars load failed: ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (!Array.isArray(data) || data.length === 0) {
        throw new Error('Stars JSON is not an array or is empty');
      }

      // 1) Prepare flat arrays and label holders
      const positions    = [];
      const colors       = [];
      const sizes        = [];
      const labelObjects = [];
      const tmpColor     = new THREE.Color();
      const R            = o.starDistance    || 10000;
      const baseSize     = o.starsizeBase    ||   50;

      data.forEach((star, i) => {
        // 2) Parse & validate fields
        const ra   = raToRadians(star.RA);
        const dec  = decToRadians(star.Dec);
        const mag  = parseFloat(star.V);
        const kel  = parseFloat(star.K);
        const name = star.N;
        if (![ra, dec, mag, kel].every(Number.isFinite) || !name) return;

        // 3) Spherical → Cartesian via THREE.Spherical
        const sph = new THREE.Spherical(
          R,
          Math.PI/2 - dec,  // polar angle
          ra                 // azimuthal angle
        );
        const pos = new THREE.Vector3().setFromSpherical(sph);
        // tiny jitter to avoid z-fighting
        pos.x += (Math.random() - 0.5) * 0.001;
        pos.y += (Math.random() - 0.5) * 0.001;
        pos.z += (Math.random() - 0.5) * 0.001;

        // 4) Collect for BufferGeometry
        positions.push(pos.x, pos.y, pos.z);
        tmpColor.set(colorTemperature2rgb(kel));
        colors.push(tmpColor.r, tmpColor.g, tmpColor.b);
        const s = mag < 1 ? 1.5 : mag < 3 ? 1.0 : mag < 5 ? 0.6 : 0.3;
        sizes.push(s * baseSize);

        // 5) Create CSS2D label inline
        const labelDiv = document.createElement('div');
        labelDiv.className   = 'star-label';
        labelDiv.textContent = name;
        // (All styling comes from your CSS .star-label rules)
        labelDiv.style.pointerEvents = 'none';

        const labelObj = new CSS2DObject(labelDiv);
        labelObj.position.copy(pos);
        labelObj.visible = o.starNamesVisible;
        labelObjects.push(labelObj);
      });

      console.log(`  → kept ${positions.length/3} stars`);

      // 6) Build one BufferGeometry
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position',  new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('starColor', new THREE.Float32BufferAttribute(colors,    3));
      geo.setAttribute('starSize',  new THREE.Float32BufferAttribute(sizes,     1));
      geo.computeBoundingSphere();
      console.log('  → boundingSphere radius =', geo.boundingSphere.radius);

      // 7) Create ShaderMaterial with additive blending & alpha‐only sprite
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          pointTexture: { value: starTexture },
          uScaleFactor: { value: 2500.0 },
          fadeStart:    { value: 7500.0 },
          fadeEnd:      { value: 30000.0 }
        },
        vertexShader: `
          uniform float uScaleFactor;
          attribute float starSize;
          attribute vec3 starColor;
          varying vec3 vColor;
          varying float vDist;
          void main() {
            vColor = starColor;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            vDist = -mv.z;
            gl_PointSize = starSize * (uScaleFactor / max(vDist, 0.0001));
            gl_Position  = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          uniform sampler2D pointTexture;
          uniform float fadeStart, fadeEnd;
          varying vec3 vColor;
          varying float vDist;
          void main() {
            float a = texture2D(pointTexture, gl_PointCoord).a;
            float f = 1.0 - smoothstep(fadeStart, fadeEnd, vDist);
            gl_FragColor = vec4(vColor * f, a * f);
          }
        `,
        blending:     THREE.AdditiveBlending,
        depthWrite:   false,
        transparent:  true,
        vertexColors: true
      });
      // optional: expose for GUI tweaks
      starSizeMaterial = mat;

      // 8) Create & insert the Points mesh
      const points = new THREE.Points(geo, mat);
      points.frustumCulled = false;

      // clear any old stars & labels
      while (sceneObjects.stars.children.length) {
        sceneObjects.stars.remove(sceneObjects.stars.children[0]);
      }
      sceneObjects.stars.add(points);

      // 9) Add all CSS2D labels into the same group
      labelObjects.forEach(lo => sceneObjects.stars.add(lo));

      console.log('✅ initStars: complete');
    })
    .catch(err => console.error('❌ initStars error:', err));
}

function loadTexture( url, onLoad ) {
  if ( textureCache.has( url ) ) {
    // reuse
    const tex = textureCache.get( url );
    onLoad && onLoad( tex );
    return tex;
  }
  // first time: load + store
  const tex = textureLoader.load( url, t => {
    onLoad && onLoad( t );
  });
  textureCache.set( url, tex );
  return tex;
}

// 0 — per-frame stats
const planetStats = {
    earth: [
      {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => holisticyearLength-13, dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Earth orbits the Sun ${fmtNum((holisticyearLength-13),0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.earthDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/Earth',
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => o.obliquityEarth, dec:8, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '1' }],
       static: true},
      {label : () => `Mass (M⊕)`,
       value : [ { v: () => fmtScientific(M_EARTH, 12) },{ small: 'kg' }],
       hover : [`Earth's mass derived from Moon's orbital data using Kepler's 3rd Law: GM = 4π²a³/P² ≈ 5.97 × 10²⁴ kg`],
       info  : 'https://en.wikipedia.org/wiki/Earth_mass',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_EARTH, dec:2, sep:',' },{ small: 'km³/s²' }],
       hover : [`Derived from Moon's orbit, corrected for Moon's mass: GM_Earth = GM_system × (ratio/(ratio+1)) ≈ 398,600 km³/s²`],
       static: true},
      {label : () => `Mass ratio (M⊕/M☽)`,
       value : [ { v: () => MASS_RATIO_EARTH_MOON, dec:6, sep:',' },{ small: '' }],
       hover : [`Earth is ~81.3 times more massive than Moon`],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => o.eccentricityEarth, dec:8, sep:',' },{ small: '' }]},
    null,
      {label : () => `Ecliptic Inclination (i)`,
       value : [ { v: () => o.obliquityEarth-radiansToDecDecimal(earthWobbleCenter.dec), dec:8, sep:',' },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I)`,
       value : [ { v: () => o.earthInvPlaneInclinationDynamic, dec:8, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => earthInvPlaneInclinationMean, dec:8, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => earthInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(o.lengthofAU, M_EARTH, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Earth's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 1.5 million km. Moon orbits at ~384,400 km (25% of Hill sphere)`]},
      {label : () => `Hill Sphere`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(o.lengthofAU, M_EARTH, M_SUN) / o.lengthofAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Hill sphere radius as fraction of semi-major axis ≈ 0.01 AU`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(o.lengthofAU, M_EARTH, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 925,000 km. Used for spacecraft trajectory calculations`]},
      {label : () => `Lagrange L1 Distance`,
       value : [ { v: () => OrbitalFormulas.lagrangeL1L2Distance(o.lengthofAU, M_EARTH, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`L1 point distance from Earth toward Sun ≈ r_Hill. Location of SOHO, DSCOVR spacecraft`]},
      {label : () => `Lagrange L2 Distance`,
       value : [ { v: () => OrbitalFormulas.lagrangeL1L2Distance(o.lengthofAU, M_EARTH, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`L2 point distance from Earth away from Sun ≈ r_Hill. Location of JWST, Gaia spacecraft`]},
    null,
      {label : () => `Earth-Moon Barycenter`,
       value : [ { v: () => OrbitalFormulas.barycenterDistance(moonDistance, MASS_RATIO_EARTH_MOON), dec:2, sep:',' },{ small: 'km from Earth center' }],
       hover : [`d_bary = r_Moon/(1+M⊕/M☽) ≈ 4,670 km. The barycenter is inside Earth (radius 6,371 km)`],
       static: true},
      {label : () => `Barycenter (% of Earth radius)`,
       value : [ { v: () => (OrbitalFormulas.barycenterDistance(moonDistance, MASS_RATIO_EARTH_MOON) / (diameters.earthDiameter/2)) * 100, dec:2, sep:',' },{ small: '%' }],
       hover : [`Barycenter is at ~73% of Earth's radius from center - about 1,700 km below the surface`],
       static: true},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_EARTH) * 1000000, dec:3, sep:',' },{ small: 'mm' }],
       hover : [`r_s = 2GM/c² ≈ 8.87 mm. If Earth compressed to this size, it would become a black hole`],
       static: true},
      {label : () => `Tidal Force Ratio (Sun/Moon)`,
       value : [ { v: () => OrbitalFormulas.tidalForceRatio(M_SUN, M_MOON, o.lengthofAU, moonDistance), dec:4, sep:',' },{ small: '' }],
       hover : [`Sun's tidal force on Earth is ~46% of Moon's: (M_Sun/M_Moon) × (r_Moon/r_Sun)³`]},

    {header : '—  Surface & Physical Properties —' },
      {label : () => `Surface Gravity (g)`,
       value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_EARTH, diameters.earthDiameter/2), dec:4, sep:',' },{ small: 'm/s²' }],
       hover : [`g = GM/R² ≈ 9.82 m/s². Standard gravity defined as 9.80665 m/s² at the Earth's surface`],
       static: true},
      {label : () => `Surface Escape Velocity`,
       value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_EARTH, diameters.earthDiameter/2), dec:3, sep:',' },{ small: 'km/s' }],
       hover : [`v_esc = √(2GM/R) ≈ 11.19 km/s. Minimum velocity to escape Earth's gravity`],
       static: true},
      {label : () => `Mean Density (ρ)`,
       value : [ { v: () => OrbitalFormulas.meanDensity(M_EARTH, diameters.earthDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
       hover : [`ρ = 3M/(4πR³) ≈ 5,515 kg/m³. Earth is the densest planet in the Solar System`],
       static: true},
      {label : () => `Gravitational Potential at Moon`,
       value : [ { v: () => OrbitalFormulas.gravitationalPotential(GM_EARTH, moonDistance), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Φ = -GM/r. Potential energy per unit mass at Moon's distance`],
       static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => o.lengthofsolarYear/meansolaryearlengthinDays, dec:6, sep:',' },{ small : 'years' }]},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => o.lengthofsolarYear, dec:8, sep:',' },{ small : 'days' }]},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => o.lengthofsiderealYear/o.lengthofDay, dec:8, sep:',' },{ small : 'days' }]},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion(o.lengthofsolarYear), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`]},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => o.lengthofDay/86400*24, dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => o.lengthofsiderealDayRealLOD/86400*24, dec:6, sep:',' },{ small: 'hours' }]},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => o.lengthofAU/((meansiderealyearlengthinSeconds/60/60 * speedofSuninKM) / (2 * Math.PI)), dec:6, sep:',' },{ small : 'AU' }]},
      {label : () => `Semi-major axis`,
       value : [ { v: () => o.lengthofAU, dec:6, sep:',' },{ small : 'km' }]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(1, o.eccentricityEarth), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`]},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(1, o.eccentricityEarth), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`]},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(1, o.eccentricityEarth), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`]},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => sun.distAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Earth's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(1, o.eccentricityEarth), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`]},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(1, o.eccentricityEarth), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`]},
      {label : () => `PERIHELION-OF-EARTH Distance`,
       value : [ { v: () => eccentricityMean, dec:8, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => speedofSuninKM, dec:2, sep:',' },{ small: 'km/h' }],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(sun.distAU * o.lengthofAU, o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a))`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(o.lengthofAU, o.eccentricityEarth, o.earthTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(o.lengthofAU, o.eccentricityEarth, o.earthTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(o.lengthofAU, o.eccentricityEarth) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(o.lengthofAU, o.eccentricityEarth) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(o.eccentricityEarth), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`]},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(sun.distAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(sun.distAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(sun.distAU * o.lengthofAU, o.lengthofAU), sun.distAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(o.lengthofAU, o.eccentricityEarth), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(o.lengthofAU, o.eccentricityEarth), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => ((earthPerihelionFromEarth.ra * 180 / Math.PI + 360) % 360).toFixed(8), dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.earthArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => 0, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Earth's ascending node on ecliptic is 0° by definition (ecliptic reference)`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => 180, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},

    {header : '—  Orbital Orientation to Invariable Plane —' },
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.earthAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where Earth's orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.earthAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => earthInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Earth's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.earthAscendingNodeInvPlane - earthInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current position in inclination oscillation cycle: (Ω - offset). 0°=max incl (2.059°), 180°=min incl (0.931°)`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.earthHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.earthAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether planet is currently north (above) or south (below) of the invariable plane`]},
    null,
       {label : () => `Earth Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.earthInvPlaneInclinationDynamic * Math.PI / 180), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × 1 AU. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Earth Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.earthInvPlaneInclinationDynamic * Math.PI / 180) * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.earthMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.earthEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.earthTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.earthTrueAnomaly - o.earthMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.earthMeanAnomaly, o.earthPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.earthArgumentOfPeriapsis, o.earthTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(o.eccentricityEarth, o.earthTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.earthInvPlaneInclinationDynamic, o.earthArgumentOfPeriapsis, o.earthTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u)`]},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion(o.lengthofsolarYear), o.eccentricityEarth, o.earthTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion(o.lengthofsolarYear), o.eccentricityEarth, o.earthEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(o.lengthofAU, o.eccentricityEarth, o.earthTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(o.lengthofsolarYear, o.earthMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(o.lengthofsolarYear, o.earthMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},
      {label : () => `Approximate Date of Perihelion`,
       value : [ { v: () => o.longitudePerihelionDatePer },{ small: 'D/M/Y, h:m:s' }],
       hover : [`Estimated date when Earth will be closest to the Sun`],
       info  : 'https://en.wikipedia.org/wiki/Perihelion_and_aphelion'},
      {label : () => `Approximate Date of Aphelion`,
       value : [ { v: () => o.longitudePerihelionDateAp },{ small: 'D/M/Y, h:m:s' }],
       hover : [`Estimated date when Earth will be farthest from the Sun`]},

    {header : '—  Date Specific Characteristics —', date: () => o.Date },
      {''                                           : [ { small : 'mean' },'on date']},
      {label : () => `Solar Day (SI seconds)`,
       value : [ { small: meanlengthofday },{ v: () => o.lengthofDay, dec:10, sep:',' }]},
      {label : () => `Sidereal day (SI seconds)`,
       value : [ { small: meanSiderealday },{ v: () => o.lengthofsiderealDayRealLOD, dec:10, sep:',' }]},
      {label : () => `Stellar day (SI seconds)`,
       value : [ { small: meanStellarday },{ v: () => o.lengthofstellarDayRealLOD, dec:10, sep:',' }]},
     null,
      {label : () => `Solar year (SI seconds)`,
       value : [ { small: meanlengthofday*meansolaryearlengthinDays },{ v: () => o.lengthofsolarYearSecRealLOD, dec:6, sep:',' }]},
      {label : () => `Solar year (days)`,
       value : [ { small: meansolaryearlengthinDays },{ v: () => o.lengthofsolarYear, dec:11, sep:',' }]},
     null,
      {label : () => `Sidereal year (SI seconds)`,
       value : [ { small: meansiderealyearlengthinSeconds },{ v: () => o.lengthofsiderealYear, dec:6, sep:',' }]},
      {label : () => `Sidereal year (days)`,
       value : [ { small: meansiderealyearlengthinSeconds/meanlengthofday },{ v: () => o.lengthofsiderealYear/o.lengthofDay, dec:11, sep:',' }]},
     null,
      {label : () => `Anomalistic year (SI seconds)`,
       value : [ { small: meanAnomalisticYearinDays*meanlengthofday },{ v: () => o.lengthofanomalisticYearRealLOD, dec:6, sep:',' }]},
      {label : () => `Anomalistic year (days)`,
       value : [ { small: meanAnomalisticYearinDays },{ v: () => o.lengthofanomalisticYearRealLOD/o.lengthofDay, dec:11, sep:',' }]},
     null,
      {label : () => `Obliquity (degrees)`,
       value : [ { small: earthtiltMean },{ v: () => o.obliquityEarth, dec:12, sep:',' }]},
      {label : () => `Orbital Eccentricity`,
       value : [ { small: eccentricityMean },{ v: () => o.eccentricityEarth, dec:13, sep:',' }]},
      {label : () => `Inclination to Invariable plane (degrees)`,
       value : [ { small: earthInvPlaneInclinationMean },{ v: () => o.earthInvPlaneInclinationDynamic, dec:13, sep:',' }]},
     null,
      {label : () => `Length of AU (km)`,
       value : [ { small:{ v: () => (meansiderealyearlengthinSeconds/60/60 * speedofSuninKM) / (2 * Math.PI), dec:6, sep:',' }},{ v: () => o.lengthofAU, dec:5, sep:',' }]},

    {header : '—  Precession Cycles —' },
      {label : () => `Axial precession (years)`,
       value : [ { small: { v: () => holisticyearLength/13, dec:2, sep:',' }},{ v: () => o.axialPrecessionRealLOD, dec:9, sep:',' }],
       hover : [`The mean value for axial precession is calculated as ${fmtNum(holisticyearLength,0,',')}/13`],
       info  : 'https://en.wikipedia.org/wiki/Axial_precession'},
      {label : () => `Inclination precession (years)`,
       value : [ { small: { v: () => holisticyearLength/3, dec:2, sep:',' }},{ v: () => o.inclinationPrecessionRealLOD, dec:8, sep:',' }],
       hover : [`The mean value for inclination precession is calculated as ${fmtNum(holisticyearLength,0,',')}/3`],
       info  : 'https://en.wikipedia.org/wiki/Apsidal_precession'},
      {label : () => `Perihelion precession (years)`,
       value : [ { small: { v: () => holisticyearLength/16, dec:2, sep:',' }},{ v: () => o.perihelionPrecessionRealLOD, dec:9, sep:',' }],
       hover : [`The mean value for perihelion precession is calculated as ${fmtNum(holisticyearLength,0,',')}/16`],
       info  : 'https://en.wikipedia.org/wiki/Milankovitch_cycles#Apsidal_precession'},
      {label : () => `Obliquity precession (years)`,
       value : [ { small: { v: () => holisticyearLength/8, dec:2, sep:',' }},{ v: () => o.obliquityPrecessionRealLOD, dec:9, sep:',' }],
       hover : [`The mean value for obliquity precession is calculated as ${fmtNum(holisticyearLength,0,',')}/8`],
       info  : 'https://en.wikipedia.org/wiki/Axial_tilt#Long_term'},
      {label : () => `Ecliptic precession (years)`,
       value : [ { small: { v: () => holisticyearLength/5, dec:2, sep:',' }},{ v: () => o.eclipticPrecessionRealLOD, dec:9, sep:',' }],
       hover : [`The mean value for ecliptic precession is calculated as ${fmtNum(holisticyearLength,0,',')}/5`],
       info  : 'https://en.wikipedia.org/wiki/Milankovitch_cycles#Orbital_inclination'},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession against Ecliptic`,
       value : [ { v: () => earthPerihelionICRFYears, dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution relative to the ecliptic plane`],
       static: true},
      {label : () => `Perihelion Precession against ICRF`,
       value : [ { v: () => holisticyearLength/13, dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period in the inertial ICRF frame: ${fmtNum(holisticyearLength,0,',')} / 13`],
       static: true},
      {label : () => `Perihelion precession per century`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(earthPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/100 yrs' }],
       hover : [`Rate = 129,600,000 / period_years arcseconds per century`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(earthPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},

    ],

    moon: [
    {header : '—  General characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (meansolaryearlengthinDays*holisticyearLength)/moonSiderealMonth, dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`The Moon orbits Earth ${fmtNum((meansolaryearlengthinDays*holisticyearLength)/moonSiderealMonth,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.moonDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/Moon',
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => moonTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Mass (M☽)`,
       value : [ { v: () => fmtScientific(M_MOON, 12) },{ small: 'kg' }],
       hover : [`Moon's mass derived from Earth-Moon system: M_Moon = M_Earth / ${MASS_RATIO_EARTH_MOON.toFixed(2)} ≈ 7.35 × 10²² kg`],
       info  : 'https://en.wikipedia.org/wiki/Moon',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_MOON, dec:6, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM_Moon = GM_system / (1 + mass_ratio) ≈ 4,903 km³/s²`],
       static: true},
     null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => moonOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
      {label : () => `Ecliptic Inclination (i)`,
       value : [ { v: () => moonEclipticInclinationJ2000, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(moonDistance, M_MOON, M_EARTH), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Moon's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 60,000 km`],
       static: true},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(moonDistance, M_MOON, M_EARTH), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 66,000 km`],
       static: true},
      {label : () => `Earth-Moon Barycenter`,
       value : [ { v: () => moonDistance - OrbitalFormulas.barycenterDistance(moonDistance, MASS_RATIO_EARTH_MOON), dec:2, sep:',' },{ small: 'km from Moon center' }],
       hover : [`Moon's distance from the Earth-Moon barycenter ≈ 379,700 km`],
       static: true},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_MOON) * 1000000, dec:4, sep:',' },{ small: 'mm' }],
       hover : [`r_s = 2GM/c² ≈ 0.11 mm. If Moon compressed to this size, it would become a black hole`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_MOON, diameters.moonDiameter/2), dec:4, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 1.62 m/s². About 16.5% of Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_MOON, diameters.moonDiameter/2), dec:3, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 2.38 km/s. About 21% of Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_MOON, diameters.moonDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 3,346 kg/m³. About 61% of Earth's density`],
      static: true},
     {label : () => `Gravitational Potential at Surface`,
      value : [ { v: () => OrbitalFormulas.gravitationalPotential(GM_MOON, diameters.moonDiameter/2), dec:4, sep:',' },{ small: 'km²/s²' }],
      hover : [`Φ = -GM/r. Potential energy per unit mass at Moon's surface`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Sidereal month`,
       value : [ { v: () => moonSiderealMonth, dec:10, sep:',' },{ small: 'days' }],
       info  : 'https://en.wikipedia.org/wiki/Orbit_of_the_Moon',
       static: true},
      {label : () => `Synodic month`,
       value : [ { v: () => moonSynodicMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `Anomalistic month`,
       value : [ { v: () => moonAnomalisticMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `Draconic month (a.k.a. nodal period)`,
       value : [ { v: () => moonNodalMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `Tropical month`,
       value : [ { v: () => moonTropicalMonth, dec:10, sep:',' },{ small: 'days' }],
       info  : 'https://eclipse.gsfc.nasa.gov/LEcat5/LEcatalog.html',
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Orbit distance to Earth`,
       value : [ { v: () => moonDistance, dec:2, sep:',' },{ small: 'km' }],
       static: true},
      {label : () => `Orbital speed around Earth`,
       value : [ { v: () => moonSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       static: true},

    {header : '—  Moon Cycles & Precession —' },
      {label : () => `Full Moon cycle ICRF`,
       value : [ { v: () => moonFullMoonCycleICRF, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `Full Moon cycle Earth`,
       value : [ { v: () => moonFullMoonCycleEarth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
     null,
      {label : () => `Draconic year ICRF`,
       value : [ { v: () => moonDraconicYearICRF, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `Draconic year Earth`,
       value : [ { v: () => moonDraconicYearEarth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
    null,
      {label : () => `Apsidal precession ICRF`,
       value : [ { v: () => moonApsidalPrecessionindaysICRF, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => ``,
       value : [ { v: () => moonApsidalPrecessionindaysICRF/meansolaryearlengthinDays, dec:10, sep:',' },{ small: 'years' }],
       static: true},
      {label : () => `Apsidal precession Earth`,
       value : [ { v: () => moonApsidalPrecessionindaysEarth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => ``,
       value : [ { v: () => moonApsidalPrecessionindaysEarth/meansolaryearlengthinDays, dec:10, sep:',' },{ small: 'years' }],
       static: true},
     null,
      {label : () => `Nodal precession ICRF`,
       value : [ { v: () => moonNodalPrecessionindaysICRF, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => ``,
       value : [ { v: () => moonNodalPrecessionindaysICRF/meansolaryearlengthinDays, dec:10, sep:',' },{ small: 'years' }],
       static: true},
      {label : () => `Nodal precession Earth`,
       value : [ { v: () => moonNodalPrecessionindaysEarth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => ``,
       value : [ { v: () => moonNodalPrecessionindaysEarth/meansolaryearlengthinDays, dec:10, sep:',' },{ small: 'years' }],
       static: true},
    null,
      {label : () => `Nodal meets Apsidal precession`,
       value : [ { v: () => moonApsidalMeetsNodalindays, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => ``,
       value : [ { v: () => moonApsidalMeetsNodalindays/meansolaryearlengthinDays, dec:10, sep:',' },{ small: 'years' }],
       static: true},
    null,
      {label : () => `Royer Cycle`,
       value : [ { v: () => moonRoyerCycleindays, dec:10, sep:',' },{ small: 'days' }],
       info  : 'https://geoenergymath.com/2014/04/05/the-chandler-wobble-and-the-soim/',
       static: true},
      {label : () => ``,
       value : [ { v: () => moonRoyerCycleindays/meansolaryearlengthinDays, dec:10, sep:',' },{ small: 'years' }],
       static: true},

    {header : '—  Eclipse Cycles: Metonic —' },
      {label : () => `235 Synodic Months`,
       value : [ { v: () => 235*moonSynodicMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `255 Draconic months`,
       value : [ { v: () => 255*moonNodalMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `19 Solar years`,
       value : [ { v: () => 19*o.lengthofsolarYear, dec:10, sep:',' },{ small: 'days' }]},

    {header : '—  Eclipse Cycles: Saros —' },
      {label : () => `223 Synodic Months`,
       value : [ { v: () => 223*moonSynodicMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `239 Anomalistic Months`,
       value : [ { v: () => 239*moonAnomalisticMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `242 Draconic months`,
       value : [ { v: () => 242*moonNodalMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `19 Draconic year cycles`,
       value : [ { v: () => 19*moonDraconicYearEarth, dec:10, sep:',' },{ small: 'days' }],
       static: true},

    {header : '—  Eclipse Cycles: Exeligmos (3× Saros) —' },
      {label : () => `3 * 223 Synodic Months`,
       value : [ { v: () => 3*223*moonSynodicMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `3 * 239 Anomalistic Months`,
       value : [ { v: () => 3*239*moonAnomalisticMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `3 * 242 Draconic months`,
       value : [ { v: () => 3*242*moonNodalMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `3 * 19 Draconic year cycles`,
       value : [ { v: () => 3*19*moonDraconicYearEarth, dec:10, sep:',' },{ small: 'days' }],
       static: true},

    {header : '—  Eclipse Cycles: Callippic —' },
      {label : () => `940 Synodic Months`,
       value : [ { v: () => 940*moonSynodicMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `1020 Draconic months`,
       value : [ { v: () => 1020*moonNodalMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `1016 Sidereal Months`,
       value : [ { v: () => 1016*moonSiderealMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `1016 Tropical Months`,
       value : [ { v: () => 1016*moonTropicalMonth, dec:10, sep:',' },{ small: 'days' }],
       static: true},
      {label : () => `76 Solar years`,
       value : [ { v: () => 76*o.lengthofsolarYear, dec:10, sep:',' },{ small: 'days' }]},
    ],
  
    sun: [
    { header : '—  General characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => 0, dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`The Sun is responsible for the length of the Holistic-Year of ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.sunDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/Sun',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_SUN, dec:0, sep:',' },{ small: 'km³/s²' }],
       hover : [`Derived from Kepler's 3rd Law: GM = (2π)² × a³ / P² ≈ 1.327 × 10¹¹ km³/s²`],
       info  : 'https://en.wikipedia.org/wiki/Standard_gravitational_parameter',
       static: true},
      {label : () => `Mass (M☉)`,
       value : [ { v: () => fmtScientific(M_SUN, 12) },{ small: 'kg' }],
       hover : [`Sun's mass derived from GM/G ≈ 1.989 × 10³⁰ kg`],
       info  : 'https://en.wikipedia.org/wiki/Solar_mass',
       static: true},
      {label : () => `Mass ratio (M☉/M⊕)`,
       value : [ { v: () => MASS_RATIO_SUN_EARTH, dec:0, sep:',' },{ small: '' }],
       hover : [`Sun is ~332,946 times more massive than Earth`],
       static: true},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_SUN), dec:3, sep:',' },{ small: 'km' }],
       hover : [`r_s = 2GM/c² ≈ 2.95 km. If Sun compressed to this size, it would become a black hole. Sun's actual radius is 695,700 km`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => sunTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '0' }],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_SUN, diameters.sunDiameter/2), dec:2, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 274 m/s². About 28 times Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_SUN, diameters.sunDiameter/2), dec:2, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 617.5 km/s. About 55 times Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_SUN, diameters.sunDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 1,408 kg/m³. Only about 25% of Earth's density`],
      static: true},
     null,
      { header : 'Our Sun is orbiting the Milky Way' },
     null,
      {label : () => `Orbit period of our Sun`,
       value : [ { v: () => sunOrbitPeriod, dec:0, sep:',' },{ small: 'years' }],
       static: true},
      {label : () => `Orbit distance of Sun to the Milky Way center`,
       value : [ { v: () => milkywayDistance, dec:0, sep:',' },{ small: 'light-years' }],
       static: true},
      {label : () => `Orbital speed of Sun around Milky Way galaxy`,
       value : [ { v: () => sunSpeed, dec:0, sep:',' },{ small: 'km/h' }],
       info  : 'https://en.wikipedia.org/wiki/Galactic_year',
       static: true},
    null,
      { header : 'Our Milky Way is orbiting the Great Attractor' },
    null,
      {label : () => `Orbit period of our Milky Way galaxy`,
       value : [ { v: () => milkywayOrbitPeriod, dec:0, sep:',' },{ small: 'years' }],
       hover : [`Calculated based upon 2 mln light-years to the great attractor center, so (${fmtNum(greatattractorDistance,0,',')}*${fmtNum(lightYear,0,',')}*2*PI)/${fmtNum(milkywaySpeed,0,',')}/60/60*${fmtNum(meanlengthofday,6,',')}*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit distance to the Great Attractor`,
       value : [ { v: () => greatattractorDistance, dec:0, sep:',' },{ small: 'light-years' }],
       static: true},
      {label : () => `Orbital speed of Milky Way to Great Attractor`,
       value : [ { v: () => milkywaySpeed, dec:0, sep:',' },{ small: 'km/h' }],
       info  : 'https://en.wikipedia.org/wiki/Great_Attractor',
       static: true},
    null,
      { header : 'The age of the universe' },
    null,
      {label : () => `Visible age of the universe`,
       value : [ { v: () => ((((((meansiderealyearlengthinSeconds/60/60 * speedofSuninKM) / (2 * Math.PI)*Math.PI*2)/1296000)*(648000/(Math.PI))**2)/speedOfLight)/meanlengthofday/meansolaryearlengthinDays)*4.22*1000000000, dec:0, sep:',' },{ small: 'years' }],
       hover : [`Calculated based upon 4.220 billion parsecs visible`],
       info  : 'https://en.wikipedia.org/wiki/Observable_universe',
       static: true},
    null,
      { header : 'New Constants which can be used for long term calculations' },
    null,
      {label : () => `NEW-AU`,
       value : [ { small:{ v: () => (meansiderealyearlengthinSeconds/60/60 * speedofSuninKM) / (2 * Math.PI), dec:6, sep:',' }},{ small: 'km' }],
       static: true},
      {label : () => `NEW-Light-year`,
       value : [ { small:{ v: () => lightYear, dec:0, sep:',' }},{ small: 'km' }],
       static: true},
      {label : () => `NEW-Arcsecond`,
       value : [ { small:{ v: () => ((meansiderealyearlengthinSeconds/60/60 * speedofSuninKM) / (2 * Math.PI)*Math.PI*2)/1296000, dec:6, sep:',' }},{ small: 'km' }],
       hover : [`The angular diameter in km of an object at a distance of 1 NEW-AU`],
       static: true},
      {label : () => `NEW-SI second`,
       value : [ { small:{ v: () => meanlengthofday/86400, dec:8, sep:',' }},{ small: 'SI second' }],
       hover : [`A NEW-SI second is ${fmtNum(meanlengthofday,8,',')}/86,400 times the current SI second to make sure we can keep using 86,400 seconds a day`],
       static: true},
      {label : () => ``,
       value : [ { small:{ v: () => 9192631770/ 86400*meanlengthofday, dec:0, sep:',' }},{ small: 'transitions' }],
       hover : [`A NEW-SI second is 9,192,631,770/86,400*${fmtNum(meanlengthofday,8,',')} periods of the radiation corresponding to the transition between the two hyperfine levels of the ground state of the caesium-133 atom`],
       static: true},
    ],
    
    mercury: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (mercurySolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Mercury orbits the Sun ${fmtNum(mercurySolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.mercuryDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/Mercury_(planet)',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_MERCURY, 12) },{ small: 'kg' }],
       hover : [`Mass derived from Sun/Mercury mass ratio (1:${fmtNum(MASS_RATIO_SUN_MERCURY,0,',')}), originally measured via MESSENGER spacecraft`],
       info  : 'https://en.wikipedia.org/wiki/Mercury_(planet)',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_MERCURY, dec:2, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM = GM_SUN / mass_ratio ≈ 22,032 km³/s². Mercury has no moons, so mass was determined via spacecraft tracking`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => mercuryTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '0' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => mercuryOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null, 
      {label : () => `Ecliptic Inclination (i) (J2000: ${mercuryEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.mercuryEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.mercuryEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${mercuryInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.mercuryInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => mercuryInvPlaneInclinationMean, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => mercuryInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(mercuryOrbitDistance * o.lengthofAU, M_MERCURY, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Mercury's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 175,000 km`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(mercuryOrbitDistance * o.lengthofAU, M_MERCURY, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 112,000 km`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_MERCURY) * 1000000, dec:6, sep:',' },{ small: 'mm' }],
       hover : [`r_s = 2GM/c² ≈ 0.49 mm. If Mercury compressed to this size, it would become a black hole`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_MERCURY, diameters.mercuryDiameter/2), dec:4, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 3.70 m/s². About 38% of Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_MERCURY, diameters.mercuryDiameter/2), dec:3, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 4.25 km/s. About 38% of Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_MERCURY, diameters.mercuryDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 5,427 kg/m³. Second densest planet after Earth`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/mercurySolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Mercury's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(mercurySolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/mercurySolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Mercury's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(mercurySolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(mercurySolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Mercury's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(mercurySolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => (holisticyearLength/(mercurySolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Mercury's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(mercurySolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(mercurySolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(mercuryOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (mercuryRotationPeriod*(((holisticyearLength/mercurySolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/mercurySolarYearCount)*meansolaryearlengthinDays)*24)-mercuryRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => mercuryRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => mercuryOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mercury distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(mercurySolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => mercuryOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Mercury distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(mercurySolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(mercuryOrbitDistance, mercuryOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(mercuryOrbitDistance, mercuryOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(mercuryOrbitDistance, mercuryOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => mercury.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mercury's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(mercuryOrbitDistance, mercuryOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(mercuryOrbitDistance, mercuryOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-MERCURY Distance`,
       value : [ { v: () => mercuryPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => mercurySpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Mercury mean speed around the sun is calculated as (${fmtNum(mercuryOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/mercurySolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(mercury.sunDistAU * o.lengthofAU, mercuryOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity, o.mercuryTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity, o.mercuryTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(mercuryOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(mercury.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(mercury.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(mercury.sunDistAU * o.lengthofAU, mercuryOrbitDistance * o.lengthofAU), mercury.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(mercuryOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.mercuryPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.mercuryArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.mercuryAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.mercuryDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},

    {header : '—  Orbital Orientation to Invariable Plane —' },
       {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.mercuryAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.mercuryAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => mercuryInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Mercury's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.mercuryAscendingNodeInvPlane - mercuryInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current phase in the inclination oscillation cycle: Ω(t) - offset. When phase = 0°, inclination is at maximum. When phase = 180°, inclination is at minimum.`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.mercuryHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.mercuryAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether planet is currently north (above) or south (below) of the invariable plane`]},
    null,
      {label : () => `Mercury Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.mercuryInvPlaneInclinationDynamic * Math.PI / 180) * mercuryOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × a. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Mercury Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.mercuryInvPlaneInclinationDynamic * Math.PI / 180) * mercuryOrbitDistance * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × a × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.mercuryMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.mercuryEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.mercuryTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.mercuryTrueAnomaly-o.mercuryMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.mercuryMeanAnomaly, o.mercuryPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.mercuryTrueAnomaly, o.mercuryPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.mercuryArgumentOfPeriapsis, o.mercuryTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(mercuryOrbitalEccentricity, o.mercuryTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.mercuryInvPlaneInclinationDynamic, o.mercuryArgumentOfPeriapsis, o.mercuryTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.mercuryTrueAnomaly, o.mercuryPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(mercurySolarYearCount-13))*meansolaryearlengthinDays), mercuryOrbitalEccentricity, o.mercuryTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(mercurySolarYearCount-13))*meansolaryearlengthinDays), mercuryOrbitalEccentricity, o.mercuryEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(mercuryOrbitDistance * o.lengthofAU, mercuryOrbitalEccentricity, o.mercuryTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(mercurySolarYearInput, o.mercuryMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(mercurySolarYearInput, o.mercuryMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => mercuryPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(mercuryPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(mercuryPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(mercuryPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(mercuryPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(mercuryPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('mercury'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('mercury'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,
      {label : () => `Missing advance 1800-1900 (Einstein's century)`,
       value : [ { v: () => calculateEinsteinCenturyMissingAdvance(), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1800 to 1900`]},
      {label : () => `Predicted missing advance (next century)`,
       value : [ { v: () => calculatePredictedMissingAdvance(), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Predicted difference between Earth-frame and Ecliptic-frame perihelion advance from 2000 to 2100`]},
    null,

    {header : '—  Theorized Precession Breakdown —',
     hover : [`The theorized precession breakdown numbers do not always align perfectly with observed precession values. See docs/precession-breakdown-implementation.md for details.`]},
      {label : () => `┌ Venus`,
       value : [ { v: () => getContribution(getMercuryPrecessionBreakdown(o), 'Venus'), dec:1, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Venus (outer): Dominant contributor due to proximity despite lower mass`]},
      {label : () => `├ Jupiter`,
       value : [ { v: () => getContribution(getMercuryPrecessionBreakdown(o), 'Jupiter'), dec:1, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Jupiter (outer): Second largest due to enormous mass`]},
      {label : () => `├ Earth`,
       value : [ { v: () => getContribution(getMercuryPrecessionBreakdown(o), 'Earth'), dec:1, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth (outer): Third contributor`]},
      {label : () => `├ Saturn`,
       value : [ { v: () => getContribution(getMercuryPrecessionBreakdown(o), 'Saturn'), dec:1, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Saturn (outer): Small contribution due to distance`]},
      {label : () => `├ Mars`,
       value : [ { v: () => getContribution(getMercuryPrecessionBreakdown(o), 'Mars'), dec:1, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Mars (outer): Small due to low mass`]},
      {label : () => `├ Uranus`,
       value : [ { v: () => getContribution(getMercuryPrecessionBreakdown(o), 'Uranus'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Uranus (outer): Negligible contribution`]},
      {label : () => `└ Neptune`,
       value : [ { v: () => getContribution(getMercuryPrecessionBreakdown(o), 'Neptune'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Neptune (outer): Negligible contribution`]},
    null,
      {label : () => `Σ Calculated Total`,
       value : [ { v: () => { const b = getMercuryPrecessionBreakdown(o); return b ? b.calculatedTotal : 0; }, dec:1, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Sum of all planetary contributions from Lagrange-Laplace secular theory`]},
    ],
    venus: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (venusSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Venus orbits the Sun ${fmtNum(venusSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.venusDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/venus',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_VENUS, 12) },{ small: 'kg' }],
       hover : [`Mass derived from Sun/Venus mass ratio (1:${fmtNum(MASS_RATIO_SUN_VENUS,2,',')}), originally measured via Venera and Magellan spacecraft`],
       info  : 'https://en.wikipedia.org/wiki/Venus',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_VENUS, dec:2, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM = GM_SUN / mass_ratio ≈ 324,859 km³/s². Venus has no moons, so mass was determined via spacecraft tracking`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => venusTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '0' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => venusOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,
      {label : () => `Ecliptic Inclination (i) (J2000: ${venusEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.venusEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.venusEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${venusInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.venusInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => venusInvPlaneInclinationMean, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => venusInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(venusOrbitDistance * o.lengthofAU, M_VENUS, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Venus's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 1,000,000 km`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(venusOrbitDistance * o.lengthofAU, M_VENUS, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 616,000 km`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_VENUS) * 1000000, dec:3, sep:',' },{ small: 'mm' }],
       hover : [`r_s = 2GM/c² ≈ 7.22 mm. If Venus compressed to this size, it would become a black hole`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_VENUS, diameters.venusDiameter/2), dec:4, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 8.87 m/s². About 90% of Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_VENUS, diameters.venusDiameter/2), dec:3, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 10.36 km/s. About 93% of Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_VENUS, diameters.venusDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 5,243 kg/m³. About 95% of Earth's density`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/venusSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Venus's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(venusSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/venusSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Venus's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(venusSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(venusSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Venus's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(venusSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => (holisticyearLength/(venusSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Venus's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(venusSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(venusSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(venusOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (venusRotationPeriod*(((holisticyearLength/venusSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/venusSolarYearCount)*meansolaryearlengthinDays)*24)+venusRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => venusRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => venusOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Venus distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(venusSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => venusOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Venus distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(venusSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(venusOrbitDistance, venusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(venusOrbitDistance, venusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(venusOrbitDistance, venusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => venus.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Venus's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(venusOrbitDistance, venusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(venusOrbitDistance, venusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-VENUS Distance`,
       value : [ { v: () => venusPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => venusSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Venus mean speed around the sun is calculated as (${fmtNum(venusOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/venusSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(venus.sunDistAU * o.lengthofAU, venusOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity, o.venusTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity, o.venusTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(venusOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(venus.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(venus.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(venus.sunDistAU * o.lengthofAU, venusOrbitDistance * o.lengthofAU), venus.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(venusOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.venusPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.venusArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.venusAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.venusDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},

    {header : '—  Orbital Orientation to Invariable Plane —' },
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.venusAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.venusAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => venusInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Venus's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.venusAscendingNodeInvPlane - venusInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current phase in the inclination oscillation cycle: Ω(t) - offset. When phase = 0°, inclination is at maximum. When phase = 180°, inclination is at minimum.`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.venusHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.venusAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether planet is currently north (above) or south (below) of the invariable plane`]},
    null,
      {label : () => `Venus Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.venusInvPlaneInclinationDynamic * Math.PI / 180) * venusOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × a. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Venus Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.venusInvPlaneInclinationDynamic * Math.PI / 180) * venusOrbitDistance * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × a × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.venusMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.venusEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.venusTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.venusTrueAnomaly-o.venusMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.venusMeanAnomaly, o.venusPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.venusTrueAnomaly, o.venusPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.venusArgumentOfPeriapsis, o.venusTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(venusOrbitalEccentricity, o.venusTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.venusInvPlaneInclinationDynamic, o.venusArgumentOfPeriapsis, o.venusTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.venusTrueAnomaly, o.venusPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(venusSolarYearCount-13))*meansolaryearlengthinDays), venusOrbitalEccentricity, o.venusTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(venusSolarYearCount-13))*meansolaryearlengthinDays), venusOrbitalEccentricity, o.venusEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(venusOrbitDistance * o.lengthofAU, venusOrbitalEccentricity, o.venusTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(venusSolarYearInput, o.venusMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(venusSolarYearInput, o.venusMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => venusPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(venusPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(venusPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(venusPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(venusPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(venusPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('venus'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('venus'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],

    mars: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (marsSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Mars orbits the Sun ${fmtNum(marsSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.marsDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/mars',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_MARS, 12) },{ small: 'kg' }],
       hover : [`Mass derived from Sun/Mars mass ratio (1:${fmtNum(MASS_RATIO_SUN_MARS,2,',')}), measured from Phobos/Deimos orbits and spacecraft`],
       info  : 'https://en.wikipedia.org/wiki/Mars',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_MARS, dec:2, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM = GM_SUN / mass_ratio ≈ 42,828 km³/s². Derived from moon orbits (Phobos, Deimos) and spacecraft tracking`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => marsTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '2' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => marsOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,  
      {label : () => `Ecliptic Inclination (i) (J2000: ${marsEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.marsEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.marsEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${marsInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.marsInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => marsInvPlaneInclinationMean, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => marsInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(marsOrbitDistance * o.lengthofAU, M_MARS, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Mars's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 1,080,000 km`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(marsOrbitDistance * o.lengthofAU, M_MARS, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 577,000 km`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_MARS) * 1000000, dec:4, sep:',' },{ small: 'mm' }],
       hover : [`r_s = 2GM/c² ≈ 0.95 mm. If Mars compressed to this size, it would become a black hole`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_MARS, diameters.marsDiameter/2), dec:4, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 3.71 m/s². About 38% of Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_MARS, diameters.marsDiameter/2), dec:3, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 5.03 km/s. About 45% of Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_MARS, diameters.marsDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 3,933 kg/m³. About 71% of Earth's density`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/marsSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Mars's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(marsSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/marsSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Mars's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(marsSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(marsSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Mars's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(marsSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => -(holisticyearLength/(marsSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Mars's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(marsSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(marsSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(marsOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (marsRotationPeriod*(((holisticyearLength/marsSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/marsSolarYearCount)*meansolaryearlengthinDays)*24)-marsRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => marsRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => marsOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mars distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(marsSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => marsOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Mars distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(marsSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(marsOrbitDistance, marsOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(marsOrbitDistance, marsOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(marsOrbitDistance, marsOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => mars.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mars's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(marsOrbitDistance, marsOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(marsOrbitDistance, marsOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-MARS Distance`,
       value : [ { v: () => marsPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => marsSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Mars mean speed around the sun is calculated as (${fmtNum(marsOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/marsSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(mars.sunDistAU * o.lengthofAU, marsOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity, o.marsTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity, o.marsTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(marsOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(mars.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(mars.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(mars.sunDistAU * o.lengthofAU, marsOrbitDistance * o.lengthofAU), mars.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(marsOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.marsPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.marsArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.marsAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.marsDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},
  
    {header : '—  Orbital Orientation to Invariable Plane —' },
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.marsAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.marsAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => marsInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Mars's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.marsAscendingNodeInvPlane - marsInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current phase in the inclination oscillation cycle: Ω(t) - offset. When phase = 0°, inclination is at maximum. When phase = 180°, inclination is at minimum.`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.marsHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.marsAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether planet is currently north (above) or south (below) of the invariable plane`]},
    null,
      {label : () => `Mars Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.marsInvPlaneInclinationDynamic * Math.PI / 180) * marsOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × a. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Mars Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.marsInvPlaneInclinationDynamic * Math.PI / 180) * marsOrbitDistance * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × a × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.marsMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.marsEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.marsTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.marsTrueAnomaly-o.marsMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.marsMeanAnomaly, o.marsPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.marsTrueAnomaly, o.marsPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.marsArgumentOfPeriapsis, o.marsTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(marsOrbitalEccentricity, o.marsTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.marsInvPlaneInclinationDynamic, o.marsArgumentOfPeriapsis, o.marsTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.marsTrueAnomaly, o.marsPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(marsSolarYearCount+13))*meansolaryearlengthinDays), marsOrbitalEccentricity, o.marsTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(marsSolarYearCount+13))*meansolaryearlengthinDays), marsOrbitalEccentricity, o.marsEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(marsOrbitDistance * o.lengthofAU, marsOrbitalEccentricity, o.marsTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(marsSolarYearInput, o.marsMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(marsSolarYearInput, o.marsMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => marsPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(marsPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(marsPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(marsPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(marsPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(marsPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('mars'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('mars'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],

    jupiter: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (jupiterSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Jupiter orbits the Sun ${fmtNum(jupiterSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.jupiterDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/jupiter',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_JUPITER, 12) },{ small: 'kg' }],
       hover : [`Mass derived from Sun/Jupiter mass ratio (1:${fmtNum(MASS_RATIO_SUN_JUPITER,4,',')}), measured from Galilean moon orbits`],
       info  : 'https://en.wikipedia.org/wiki/Jupiter',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_JUPITER, dec:0, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM = GM_SUN / mass_ratio ≈ 126,686,534 km³/s². Derived from Io, Europa, Ganymede, Callisto orbits`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => jupiterTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '95' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => jupiterOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,
      {label : () => `Ecliptic Inclination (i) (J2000: ${jupiterEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.jupiterEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.jupiterEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${jupiterInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.jupiterInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => jupiterInvPlaneInclinationMean, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => jupiterInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(jupiterOrbitDistance * o.lengthofAU, M_JUPITER, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Jupiter's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 53,000,000 km`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(jupiterOrbitDistance * o.lengthofAU, M_JUPITER, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 48,200,000 km`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_JUPITER), dec:3, sep:',' },{ small: 'm' }],
       hover : [`r_s = 2GM/c² ≈ 2.82 m. If Jupiter compressed to this size, it would become a black hole`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_JUPITER, diameters.jupiterDiameter/2), dec:2, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 24.79 m/s². About 2.53 times Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_JUPITER, diameters.jupiterDiameter/2), dec:2, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 59.5 km/s. About 5.3 times Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_JUPITER, diameters.jupiterDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 1,326 kg/m³. Only about 24% of Earth's density`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/jupiterSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Jupiter's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(jupiterSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/jupiterSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Jupiter's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(jupiterSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(jupiterSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Jupiter's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(jupiterSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => -(holisticyearLength/(jupiterSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Jupiter's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(jupiterSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(jupiterSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(jupiterOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (jupiterRotationPeriod*(((holisticyearLength/jupiterSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/jupiterSolarYearCount)*meansolaryearlengthinDays)*24)-jupiterRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => jupiterRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => jupiterOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Jupiter distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(jupiterSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => jupiterOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Jupiter distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(jupiterSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(jupiterOrbitDistance, jupiterOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(jupiterOrbitDistance, jupiterOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(jupiterOrbitDistance, jupiterOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => jupiter.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Jupiter's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(jupiterOrbitDistance, jupiterOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(jupiterOrbitDistance, jupiterOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-JUPITER Distance`,
       value : [ { v: () => jupiterPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => jupiterSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Jupiter mean speed around the sun is calculated as (${fmtNum(jupiterOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/jupiterSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(jupiter.sunDistAU * o.lengthofAU, jupiterOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity, o.jupiterTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity, o.jupiterTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(jupiterOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(jupiter.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(jupiter.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(jupiter.sunDistAU * o.lengthofAU, jupiterOrbitDistance * o.lengthofAU), jupiter.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(jupiterOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.jupiterPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.jupiterArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.jupiterAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.jupiterDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }]},

    {header : '—  Orbital Orientation to Invariable Plane —' },
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.jupiterAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.jupiterAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => jupiterInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Jupiter's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.jupiterAscendingNodeInvPlane - jupiterInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current phase in the inclination oscillation cycle: Ω(t) - offset. When phase = 0°, inclination is at maximum. When phase = 180°, inclination is at minimum.`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.jupiterHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.jupiterAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }]},
    null,
      {label : () => `Jupiter Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.jupiterInvPlaneInclinationDynamic * Math.PI / 180) * jupiterOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × a. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Jupiter Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.jupiterInvPlaneInclinationDynamic * Math.PI / 180) * jupiterOrbitDistance * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × a × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.jupiterMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.jupiterEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.jupiterTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.jupiterTrueAnomaly-o.jupiterMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.jupiterMeanAnomaly, o.jupiterPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.jupiterTrueAnomaly, o.jupiterPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.jupiterArgumentOfPeriapsis, o.jupiterTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(jupiterOrbitalEccentricity, o.jupiterTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.jupiterInvPlaneInclinationDynamic, o.jupiterArgumentOfPeriapsis, o.jupiterTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.jupiterTrueAnomaly, o.jupiterPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(jupiterSolarYearCount+13))*meansolaryearlengthinDays), jupiterOrbitalEccentricity, o.jupiterTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(jupiterSolarYearCount+13))*meansolaryearlengthinDays), jupiterOrbitalEccentricity, o.jupiterEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(jupiterOrbitDistance * o.lengthofAU, jupiterOrbitalEccentricity, o.jupiterTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(jupiterSolarYearInput, o.jupiterMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(jupiterSolarYearInput, o.jupiterMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => jupiterPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(jupiterPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(jupiterPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(jupiterPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(jupiterPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(jupiterPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('jupiter'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('jupiter'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],

    saturn: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (saturnSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Saturn orbits the Sun ${fmtNum(saturnSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.saturnDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/saturn',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_SATURN, 12) },{ small: 'kg' }],
       hover : [`Mass derived from Sun/Saturn mass ratio (1:${fmtNum(MASS_RATIO_SUN_SATURN,3,',')}), measured from Titan and other moon orbits`],
       info  : 'https://en.wikipedia.org/wiki/Saturn',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_SATURN, dec:0, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM = GM_SUN / mass_ratio ≈ 37,931,187 km³/s². Derived from Titan and other moon orbits`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => saturnTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '274' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => saturnOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,
      {label : () => `Ecliptic Inclination (i) (J2000: ${saturnEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.saturnEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.saturnEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${saturnInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.saturnInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => saturnInvPlaneInclinationMean, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => saturnInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(saturnOrbitDistance * o.lengthofAU, M_SATURN, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Saturn's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 65,000,000 km`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(saturnOrbitDistance * o.lengthofAU, M_SATURN, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 54,500,000 km`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_SATURN) * 1000, dec:0, sep:',' },{ small: 'mm' }],
       hover : [`r_s = 2GM/c² ≈ 843 mm. If Saturn compressed to this size, it would become a black hole`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_SATURN, diameters.saturnDiameter/2), dec:2, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 10.44 m/s². About 1.07 times Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_SATURN, diameters.saturnDiameter/2), dec:2, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 35.5 km/s. About 3.2 times Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_SATURN, diameters.saturnDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 687 kg/m³. Least dense planet - would float in water!`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/saturnSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Saturn's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(saturnSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/saturnSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Saturn's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(saturnSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(saturnSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Saturn's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(saturnSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => -(holisticyearLength/(saturnSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Saturn's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(saturnSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(saturnSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(saturnOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (saturnRotationPeriod*(((holisticyearLength/saturnSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/saturnSolarYearCount)*meansolaryearlengthinDays)*24)-saturnRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => saturnRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => saturnOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Saturn distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(saturnSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => saturnOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Saturn distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(saturnSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(saturnOrbitDistance, saturnOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(saturnOrbitDistance, saturnOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(saturnOrbitDistance, saturnOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => saturn.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Saturn's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(saturnOrbitDistance, saturnOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(saturnOrbitDistance, saturnOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-SATURN Distance`,
       value : [ { v: () => saturnPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => saturnSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Saturn mean speed around the sun is calculated as (${fmtNum(saturnOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/saturnSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(saturn.sunDistAU * o.lengthofAU, saturnOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity, o.saturnTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity, o.saturnTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(saturnOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(saturn.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(saturn.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(saturn.sunDistAU * o.lengthofAU, saturnOrbitDistance * o.lengthofAU), saturn.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(saturnOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.saturnPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.saturnArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.saturnAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.saturnDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},
   
    {header : '—  Orbital Orientation to Invariable Plane —' },
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.saturnAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.saturnAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => saturnInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Saturn's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.saturnAscendingNodeInvPlane - saturnInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current phase in the inclination oscillation cycle: Ω(t) - offset. When phase = 0°, inclination is at maximum. When phase = 180°, inclination is at minimum.`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.saturnHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.saturnAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether planet is currently north (above) or south (below) of the invariable plane`]},
    null,
      {label : () => `Saturn Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.saturnInvPlaneInclinationDynamic * Math.PI / 180) * saturnOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × a. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Saturn Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.saturnInvPlaneInclinationDynamic * Math.PI / 180) * saturnOrbitDistance * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × a × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.saturnMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.saturnEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.saturnTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.saturnTrueAnomaly-o.saturnMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.saturnMeanAnomaly, o.saturnPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.saturnTrueAnomaly, o.saturnPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.saturnArgumentOfPeriapsis, o.saturnTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(saturnOrbitalEccentricity, o.saturnTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.saturnInvPlaneInclinationDynamic, o.saturnArgumentOfPeriapsis, o.saturnTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.saturnTrueAnomaly, o.saturnPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(saturnSolarYearCount+13))*meansolaryearlengthinDays), saturnOrbitalEccentricity, o.saturnTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(saturnSolarYearCount+13))*meansolaryearlengthinDays), saturnOrbitalEccentricity, o.saturnEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(saturnOrbitDistance * o.lengthofAU, saturnOrbitalEccentricity, o.saturnTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(saturnSolarYearInput, o.saturnMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(saturnSolarYearInput, o.saturnMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => saturnPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(saturnPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(saturnPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(saturnPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(saturnPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(saturnPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('saturn'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('saturn'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],

    uranus: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (uranusSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Uranus orbits the Sun ${fmtNum(uranusSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.uranusDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/uranus',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_URANUS, 12) },{ small: 'kg' }],
       hover : [`Mass derived from Sun/Uranus mass ratio (1:${fmtNum(MASS_RATIO_SUN_URANUS,2,',')}), measured from moon orbits (Titania, Oberon, etc.)`],
       info  : 'https://en.wikipedia.org/wiki/Uranus',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_URANUS, dec:0, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM = GM_SUN / mass_ratio ≈ 5,793,939 km³/s². Derived from Uranian moon orbits`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => uranusTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '28' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => uranusOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,
      {label : () => `Ecliptic Inclination (i) (J2000: ${uranusEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.uranusEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.uranusEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${uranusInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.uranusInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => uranusInvPlaneInclinationMean, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => uranusInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(uranusOrbitDistance * o.lengthofAU, M_URANUS, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Uranus's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 70,000,000 km`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(uranusOrbitDistance * o.lengthofAU, M_URANUS, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 51,800,000 km`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_URANUS) * 1000, dec:0, sep:',' },{ small: 'mm' }],
       hover : [`r_s = 2GM/c² ≈ 129 mm. If Uranus compressed to this size, it would become a black hole`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_URANUS, diameters.uranusDiameter/2), dec:2, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 8.87 m/s². About 90% of Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_URANUS, diameters.uranusDiameter/2), dec:2, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 21.3 km/s. About 1.9 times Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_URANUS, diameters.uranusDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 1,271 kg/m³. About 23% of Earth's density`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/uranusSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Uranus's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(uranusSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/uranusSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Uranus's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(uranusSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(uranusSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Uranus's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(uranusSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => -(holisticyearLength/(uranusSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Uranus's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(uranusSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,'),')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(uranusSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(uranusOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (uranusRotationPeriod*(((holisticyearLength/uranusSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/uranusSolarYearCount)*meansolaryearlengthinDays)*24)+uranusRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => uranusRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => uranusOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Uranus distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(uranusSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => uranusOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Uranus distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(uranusSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(uranusOrbitDistance, uranusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(uranusOrbitDistance, uranusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(uranusOrbitDistance, uranusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => uranus.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Uranus's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(uranusOrbitDistance, uranusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(uranusOrbitDistance, uranusOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-URANUS Distance`,
       value : [ { v: () => uranusPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => uranusSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Uranus mean speed around the sun is calculated as (${fmtNum(uranusOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/uranusSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(uranus.sunDistAU * o.lengthofAU, uranusOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity, o.uranusTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity, o.uranusTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(uranusOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(uranus.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(uranus.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(uranus.sunDistAU * o.lengthofAU, uranusOrbitDistance * o.lengthofAU), uranus.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(uranusOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.uranusPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.uranusArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.uranusAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.uranusDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},
  
   {header : '—  Orbital Orientation to Invariable Plane —' },
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.uranusAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.uranusAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => uranusInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Uranus's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.uranusAscendingNodeInvPlane - uranusInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current phase in the inclination oscillation cycle: Ω(t) - offset. When phase = 0°, inclination is at maximum. When phase = 180°, inclination is at minimum.`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.uranusHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.uranusAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether planet is currently north (above) or south (below) of the invariable plane`]},
    null,
      {label : () => `Uranus Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.uranusInvPlaneInclinationDynamic * Math.PI / 180) * uranusOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × a. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Uranus Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.uranusInvPlaneInclinationDynamic * Math.PI / 180) * uranusOrbitDistance * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × a × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.uranusMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.uranusEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.uranusTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.uranusTrueAnomaly-o.uranusMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.uranusMeanAnomaly, o.uranusPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.uranusTrueAnomaly, o.uranusPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.uranusArgumentOfPeriapsis, o.uranusTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(uranusOrbitalEccentricity, o.uranusTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.uranusInvPlaneInclinationDynamic, o.uranusArgumentOfPeriapsis, o.uranusTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.uranusTrueAnomaly, o.uranusPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(uranusSolarYearCount+13))*meansolaryearlengthinDays), uranusOrbitalEccentricity, o.uranusTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(uranusSolarYearCount+13))*meansolaryearlengthinDays), uranusOrbitalEccentricity, o.uranusEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(uranusOrbitDistance * o.lengthofAU, uranusOrbitalEccentricity, o.uranusTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(uranusSolarYearInput, o.uranusMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(uranusSolarYearInput, o.uranusMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => uranusPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(uranusPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(uranusPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(uranusPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(uranusPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(uranusPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('uranus'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('uranus'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],

    neptune: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (neptuneSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Neptune orbits the Sun ${fmtNum(neptuneSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.neptuneDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/neptune',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_NEPTUNE, 12) },{ small: 'kg' }],
       hover : [`Mass derived from Sun/Neptune mass ratio (1:${fmtNum(MASS_RATIO_SUN_NEPTUNE,2,',')}), measured from Triton orbit and Voyager 2`],
       info  : 'https://en.wikipedia.org/wiki/Neptune',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_NEPTUNE, dec:0, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM = GM_SUN / mass_ratio ≈ 6,836,529 km³/s². Derived from Triton orbit and Voyager 2 flyby`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => neptuneTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '16' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => neptuneOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,
      {label : () => `Ecliptic Inclination (i) (J2000: ${neptuneEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.neptuneEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.neptuneEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${neptuneInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.neptuneInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => neptuneInvPlaneInclinationMean, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => neptuneInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(neptuneOrbitDistance * o.lengthofAU, M_NEPTUNE, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Neptune's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 116,000,000 km`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(neptuneOrbitDistance * o.lengthofAU, M_NEPTUNE, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 86,800,000 km`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_NEPTUNE) * 1000, dec:0, sep:',' },{ small: 'mm' }],
       hover : [`r_s = 2GM/c² ≈ 152 mm. If Neptune compressed to this size, it would become a black hole`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_NEPTUNE, diameters.neptuneDiameter/2), dec:2, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 11.15 m/s². About 1.14 times Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_NEPTUNE, diameters.neptuneDiameter/2), dec:2, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 23.5 km/s. About 2.1 times Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_NEPTUNE, diameters.neptuneDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 1,638 kg/m³. About 30% of Earth's density`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/neptuneSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Neptune's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(neptuneSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/neptuneSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Neptune's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(neptuneSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(neptuneSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Neptune's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(neptuneSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => -(holisticyearLength/(neptuneSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Neptune's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(neptuneSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(neptuneSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(neptuneOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (neptuneRotationPeriod*(((holisticyearLength/neptuneSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/neptuneSolarYearCount)*meansolaryearlengthinDays)*24)-neptuneRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => neptuneRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => neptuneOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Neptune distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(neptuneSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => neptuneOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Neptune distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(neptuneSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(neptuneOrbitDistance, neptuneOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(neptuneOrbitDistance, neptuneOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(neptuneOrbitDistance, neptuneOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => neptune.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Neptune's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(neptuneOrbitDistance, neptuneOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(neptuneOrbitDistance, neptuneOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-NEPTUNE Distance`,
       value : [ { v: () => neptunePerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => neptuneSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Neptune mean speed around the sun is calculated as (${fmtNum(neptuneOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/neptuneSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(neptune.sunDistAU * o.lengthofAU, neptuneOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity, o.neptuneTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity, o.neptuneTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(neptuneOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(neptune.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(neptune.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(neptune.sunDistAU * o.lengthofAU, neptuneOrbitDistance * o.lengthofAU), neptune.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(neptuneOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.neptunePerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.neptuneArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.neptuneAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.neptuneDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},
 
    {header : '—  Orbital Orientation to Invariable Plane —' },
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.neptuneAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.neptuneAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => neptuneInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Neptune's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.neptuneAscendingNodeInvPlane - neptuneInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current phase in the inclination oscillation cycle: Ω(t) - offset. When phase = 0°, inclination is at maximum. When phase = 180°, inclination is at minimum.`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.neptuneHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.neptuneAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether planet is currently north (above) or south (below) of the invariable plane`]},
    null,
      {label : () => `Neptune Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.neptuneInvPlaneInclinationDynamic * Math.PI / 180) * neptuneOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × a. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Neptune Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.neptuneInvPlaneInclinationDynamic * Math.PI / 180) * neptuneOrbitDistance * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × a × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.neptuneMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.neptuneEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.neptuneTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.neptuneTrueAnomaly-o.neptuneMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.neptuneMeanAnomaly, o.neptunePerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.neptuneTrueAnomaly, o.neptunePerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.neptuneArgumentOfPeriapsis, o.neptuneTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(neptuneOrbitalEccentricity, o.neptuneTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.neptuneInvPlaneInclinationDynamic, o.neptuneArgumentOfPeriapsis, o.neptuneTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.neptuneTrueAnomaly, o.neptunePerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(neptuneSolarYearCount+13))*meansolaryearlengthinDays), neptuneOrbitalEccentricity, o.neptuneTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(neptuneSolarYearCount+13))*meansolaryearlengthinDays), neptuneOrbitalEccentricity, o.neptuneEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(neptuneOrbitDistance * o.lengthofAU, neptuneOrbitalEccentricity, o.neptuneTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(neptuneSolarYearInput, o.neptuneMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(neptuneSolarYearInput, o.neptuneMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => neptunePerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(neptunePerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(neptunePerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(neptunePerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(neptunePerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(neptunePerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('neptune'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('neptune'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],
    pluto: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (plutoSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Pluto orbits the Sun ${fmtNum(plutoSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.plutoDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/pluto',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_PLUTO, 12) },{ small: 'kg' }],
       hover : [`Mass derived from Sun/Pluto mass ratio (1:${fmtNum(MASS_RATIO_SUN_PLUTO,0,',')}), measured from Charon's orbit (binary system)`],
       info  : 'https://en.wikipedia.org/wiki/Pluto',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => GM_PLUTO, dec:2, sep:',' },{ small: 'km³/s²' }],
       hover : [`GM = GM_SUN / mass_ratio ≈ 982 km³/s². Derived from Charon's orbit - Pluto-Charon is a binary system`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => plutoTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '5' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => plutoOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,
      {label : () => `Ecliptic Inclination (i) (J2000: ${plutoEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.plutoEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.plutoEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${plutoInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.plutoInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `Inclination to Inv. plane (mean)`,
       value : [ { v: () => plutoInvPlaneInclinationMean, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Inclination to Inv. plane (amplitude)`,
       value : [ { v: () => plutoInvPlaneInclinationAmplitude, dec:6, sep:',' },{ small: '± degrees (°)' }],
       static: true},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(plutoOrbitDistance * o.lengthofAU, M_PLUTO, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Region where Pluto's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 6,000,000 km`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(plutoOrbitDistance * o.lengthofAU, M_PLUTO, M_SUN), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 3,100,000 km`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_PLUTO) * 1e9, dec:3, sep:',' },{ small: 'nm' }],
       hover : [`r_s = 2GM/c² ≈ 22 nm. Pluto is so small its Schwarzschild radius is measured in nanometers`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_PLUTO, diameters.plutoDiameter/2), dec:4, sep:',' },{ small: 'm/s²' }],
      hover : [`g = GM/R² ≈ 0.62 m/s². Only about 6.3% of Earth's surface gravity`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_PLUTO, diameters.plutoDiameter/2), dec:3, sep:',' },{ small: 'km/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 1.21 km/s. Only about 11% of Earth's escape velocity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_PLUTO, diameters.plutoDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ = 3M/(4πR³) ≈ 1,854 kg/m³. About 34% of Earth's density`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/plutoSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Pluto's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(plutoSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/plutoSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Pluto's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(plutoSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(plutoSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Pluto's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(plutoSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => -(holisticyearLength/(plutoSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Pluto's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(plutoSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(plutoSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(plutoOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (plutoRotationPeriod*(((holisticyearLength/plutoSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/plutoSolarYearCount)*meansolaryearlengthinDays)*24)-plutoRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => plutoRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => plutoOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Pluto distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(plutoSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => plutoOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Pluto distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(plutoSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(plutoOrbitDistance, plutoOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(plutoOrbitDistance, plutoOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(plutoOrbitDistance, plutoOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => pluto.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Pluto's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(plutoOrbitDistance, plutoOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(plutoOrbitDistance, plutoOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-PLUTO Distance`,
       value : [ { v: () => plutoPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => plutoSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Pluto mean speed around the sun is calculated as (${fmtNum(plutoOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/plutoSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(pluto.sunDistAU * o.lengthofAU, plutoOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity, o.plutoTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity, o.plutoTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(plutoOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(pluto.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(pluto.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(pluto.sunDistAU * o.lengthofAU, plutoOrbitDistance * o.lengthofAU), pluto.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(plutoOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.plutoPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.plutoArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.plutoAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.plutoDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},
  
   {header : '—  Orbital Orientation to Invariable Plane —' }, 
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.plutoAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
      {label : () => `Descending Node on Inv. Plane`,
       value : [ { v: () => (o.plutoAscendingNodeInvPlane + 180) % 360, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`ICRF longitude where orbit crosses the invariable plane going south: Ω + 180°`]},
      {label : () => `Ω at Max Inclination`,
       value : [ { v: () => plutoInclinationPhaseAngle, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Fixed ICRF longitude where Pluto's inclination to the invariable plane reaches maximum.`]},
      {label : () => `Current Oscillation Phase`,
       value : [ { v: () => ((o.plutoAscendingNodeInvPlane - plutoInclinationPhaseAngle + 360) % 360), dec:1, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Current phase in the inclination oscillation cycle: Ω(t) - offset. When phase = 0°, inclination is at maximum. When phase = 180°, inclination is at minimum.`]},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.plutoHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.plutoAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether dwarf planet is currently north (above) or south (below) of the invariable plane`]},
    null,
      {label : () => `Pluto Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.plutoInvPlaneInclinationDynamic * Math.PI / 180) * plutoOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Mean maximum height above/below the invariable plane: ±sin(i) × a. Actual values vary slightly with orbital position due to eccentricity.`]},
      {label : () => `Pluto Mean Max Height above Inv. Plane`,
       value : [ { v: () => Math.sin(o.plutoInvPlaneInclinationDynamic * Math.PI / 180) * plutoOrbitDistance * o.lengthofAU, dec:0, sep:',' },{ small: 'km' }],
       hover : [`Mean maximum height in km: ±sin(i) × a × 149,597,870.7 km. Actual values vary slightly with orbital position due to eccentricity.`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.plutoMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.plutoEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.plutoTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.plutoTrueAnomaly-o.plutoMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.plutoMeanAnomaly, o.plutoPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.plutoTrueAnomaly, o.plutoPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.plutoArgumentOfPeriapsis, o.plutoTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to planet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(plutoOrbitalEccentricity, o.plutoTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.plutoInvPlaneInclinationDynamic, o.plutoArgumentOfPeriapsis, o.plutoTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.plutoTrueAnomaly, o.plutoPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(plutoSolarYearCount+13))*meansolaryearlengthinDays), plutoOrbitalEccentricity, o.plutoTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(plutoSolarYearCount+13))*meansolaryearlengthinDays), plutoOrbitalEccentricity, o.plutoEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(plutoOrbitDistance * o.lengthofAU, plutoOrbitalEccentricity, o.plutoTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(plutoSolarYearInput, o.plutoMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(plutoSolarYearInput, o.plutoMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => plutoPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(plutoPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(plutoPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(plutoPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(plutoPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(plutoPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('pluto'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('pluto'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],
    halleys: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (halleysSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Halleys orbits the Sun ${fmtNum(halleysSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.halleysDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/Halley%27s_Comet',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_HALLEYS, 12) },{ small: 'kg' }],
       hover : [`Mass estimated from size (~11×8×8 km) and assumed density (~0.6 g/cm³). No spacecraft has orbited Halley's`],
       info  : 'https://en.wikipedia.org/wiki/Halley%27s_Comet',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => fmtScientific(GM_HALLEYS, 6) },{ small: 'km³/s²' }],
       hover : [`GM ≈ 1.47 × 10⁻⁵ km³/s². Estimated - no spacecraft has orbited to measure directly`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => halleysTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '0' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => halleysOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,
      {label : () => `Ecliptic Inclination (i) (J2000: ${halleysEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.halleysEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.halleysEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${halleysInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.halleysInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(halleysOrbitDistance * o.lengthofAU, M_HALLEYS, M_SUN), dec:0, sep:',' },{ small: 'm' }],
       hover : [`Region where Halley's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 360 m. Comet's gravity is extremely weak`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(halleysOrbitDistance * o.lengthofAU, M_HALLEYS, M_SUN), dec:0, sep:',' },{ small: 'm' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 320 m`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_HALLEYS) * 1e15, dec:3, sep:',' },{ small: 'fm' }],
       hover : [`r_s = 2GM/c² ≈ 0.33 femtometers. Halley's is so small its Schwarzschild radius is subatomic`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_HALLEYS, diameters.halleysDiameter/2) * 1000, dec:4, sep:',' },{ small: 'mm/s²' }],
      hover : [`g = GM/R² ≈ 0.5 mm/s². Negligible gravity - you could jump off the comet`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_HALLEYS, diameters.halleysDiameter/2) * 1000, dec:3, sep:',' },{ small: 'm/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 2 m/s. Walking speed would escape Halley's gravity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_HALLEYS, diameters.halleysDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ ≈ 600 kg/m³. Very porous - less dense than water (ice and dust)`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/halleysSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Halleys's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(halleysSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/halleysSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Halleys's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(halleysSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(halleysSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Halleys's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(halleysSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => -(holisticyearLength/(halleysSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Halleys's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(halleysSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(halleysSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(halleysOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (halleysRotationPeriod*(((holisticyearLength/halleysSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/halleysSolarYearCount)*meansolaryearlengthinDays)*24)-halleysRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => halleysRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => halleysOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Halleys distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(halleysSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => halleysOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Halleys distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(halleysSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(halleysOrbitDistance, halleysOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(halleysOrbitDistance, halleysOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(halleysOrbitDistance, halleysOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => halleys.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Halley's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(halleysOrbitDistance, halleysOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(halleysOrbitDistance, halleysOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-HALLEYS Distance`,
       value : [ { v: () => halleysPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => halleysSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Halleys mean speed around the sun is calculated as (${fmtNum(halleysOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/halleysSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(halleys.sunDistAU * o.lengthofAU, halleysOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity, o.halleysTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity, o.halleysTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(halleysOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(halleys.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(halleys.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(halleys.sunDistAU * o.lengthofAU, halleysOrbitDistance * o.lengthofAU), halleys.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(halleysOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.halleysPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.halleysArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.halleysAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.halleysDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},
   
   {header : '—  Orbital Orientation to Invariable Plane —' },
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.halleysAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.halleysHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.halleysAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether comet is currently north (above) or south (below) of the invariable plane`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.halleysMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.halleysEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.halleysTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.halleysTrueAnomaly-o.halleysMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.halleysMeanAnomaly, o.halleysPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.halleysTrueAnomaly, o.halleysPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.halleysArgumentOfPeriapsis, o.halleysTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to comet: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(halleysOrbitalEccentricity, o.halleysTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.halleysInvPlaneInclinationDynamic, o.halleysArgumentOfPeriapsis, o.halleysTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.halleysTrueAnomaly, o.halleysPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(halleysSolarYearCount+13))*meansolaryearlengthinDays), halleysOrbitalEccentricity, o.halleysTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(halleysSolarYearCount+13))*meansolaryearlengthinDays), halleysOrbitalEccentricity, o.halleysEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(halleysOrbitDistance * o.lengthofAU, halleysOrbitalEccentricity, o.halleysTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(halleysSolarYearInput, o.halleysMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(halleysSolarYearInput, o.halleysMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => halleysPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(halleysPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(halleysPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(halleysPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(halleysPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(halleysPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('halleys'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('halleys'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],
    eros: [
    {header : '—  General Characteristics —' },
      {label : () => `Length of Holistic-Year`,
       value : [ { v: () => (holisticyearLength), dec:0, sep:',' },{ small: 'years' }],
       hover : [`The length of the Holistic-Year is ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
      {label : () => `Number of orbits in a Holistic-Year`,
       value : [ { v: () => (erosSolarYearCount), dec:0, sep:',' },{ small: 'orbits' }],
       hover : [`Eros orbits the Sun ${fmtNum(erosSolarYearCount,0,',')} times in ${fmtNum(holisticyearLength,0,',')} Earth solar years`],
       static: true},
    null,
      {label : () => `Size diameter`,
       value : [ { v: () => diameters.erosDiameter, dec:2, sep:',' },{ small: 'km' }],
       info  : 'https://en.wikipedia.org/wiki/433_Eros',
       static: true},
      {label : () => `Mass (M)`,
       value : [ { v: () => fmtScientific(M_EROS, 12) },{ small: 'kg' }],
       hover : [`Mass precisely measured by NEAR Shoemaker spacecraft which orbited Eros in 2000-2001`],
       info  : 'https://en.wikipedia.org/wiki/433_Eros',
       static: true},
      {label : () => `Gravitational parameter (GM)`,
       value : [ { v: () => fmtScientific(GM_EROS, 6) },{ small: 'km³/s²' }],
       hover : [`GM ≈ 4.46 × 10⁻⁴ km³/s². Precisely measured by NEAR Shoemaker spacecraft`],
       static: true},
      {label : () => `Axial tilt`,
       value : [ { v: () => erosTilt, dec:6, sep:',' },{ small: 'degrees (°)' }],
       static: true},
      {label : () => `Number of Moons`,
       value : [ '',{ small: '0' }],
       static: true},
    null,
      {label : () => `Orbital Eccentricity (e)`,
       value : [ { v: () => erosOrbitalEccentricity, dec:6, sep:',' },{ small: '' }],
       static: true},
    null,
      {label : () => `Ecliptic Inclination (i) (J2000: ${erosEclipticInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.erosEclipticInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},
      {label : () => `<small>Ecliptic Inclination (i) Souami&Souchay</small>`,
       value : [ { small: { v: () => o.erosEclipticInclinationSouamiSouchayDynamic, dec:6, sep:',' } },{ small: 'degrees (°)' }]},
    null,
      {label : () => `Inclination to Inv. plane (I) (J2000: ${erosInvPlaneInclinationJ2000.toFixed(6)}°)`,
       value : [ { v: () => o.erosInvPlaneInclinationDynamic, dec:6, sep:',' },{ small: 'degrees (°)' }]},

    {header : '—  Gravitational Influence Zones —' },
      {label : () => `Hill Sphere (r_Hill)`,
       value : [ { v: () => OrbitalFormulas.hillSphereRadius(erosOrbitDistance * o.lengthofAU, M_EROS, M_SUN), dec:0, sep:',' },{ small: 'm' }],
       hover : [`Region where Eros's gravity dominates: r_Hill = a × (m/3M)^(1/3) ≈ 1,000 m. Asteroid's gravity is very weak`]},
      {label : () => `Sphere of Influence (r_SOI)`,
       value : [ { v: () => OrbitalFormulas.sphereOfInfluence(erosOrbitDistance * o.lengthofAU, M_EROS, M_SUN), dec:0, sep:',' },{ small: 'm' }],
       hover : [`Laplace SOI: r_SOI = a × (m/M)^(2/5) ≈ 500 m`]},
      {label : () => `Schwarzschild Radius (r_s)`,
       value : [ { v: () => OrbitalFormulas.schwarzschildRadius(GM_EROS) * 1e15, dec:3, sep:',' },{ small: 'fm' }],
       hover : [`r_s = 2GM/c² ≈ 9.9 femtometers. Precisely measured by NEAR Shoemaker spacecraft`],
       static: true},

    {header : '—  Surface & Physical Properties —' },
     {label : () => `Surface Gravity (g)`,
      value : [ { v: () => OrbitalFormulas.surfaceGravity(GM_EROS, diameters.erosDiameter/2) * 1000, dec:4, sep:',' },{ small: 'mm/s²' }],
      hover : [`g = GM/R² ≈ 6 mm/s². Precisely measured by NEAR Shoemaker - you could easily jump off Eros`],
      static: true},
     {label : () => `Surface Escape Velocity`,
      value : [ { v: () => OrbitalFormulas.surfaceEscapeVelocity(GM_EROS, diameters.erosDiameter/2) * 1000, dec:3, sep:',' },{ small: 'm/s' }],
      hover : [`v_esc = √(2GM/R) ≈ 10 m/s. A good throw would escape Eros's gravity`],
      static: true},
     {label : () => `Mean Density (ρ)`,
      value : [ { v: () => OrbitalFormulas.meanDensity(M_EROS, diameters.erosDiameter/2), dec:0, sep:',' },{ small: 'kg/m³' }],
      hover : [`ρ ≈ 2,670 kg/m³. About half of Earth's density - typical for S-type asteroids`],
      static: true},

    {header : '—  Orbital Period & Motion —' },
      {label : () => `Orbital period (P)`,
       value : [ { v: () => (holisticyearLength/erosSolarYearCount), dec:6, sep:',' },{ small: 'years' }],
       hover : [`Eros's Solar orbit period in years is calculated as ${fmtNum(holisticyearLength,0,',')}/${fmtNum(erosSolarYearCount,0,',')}`],
       static: true},
      {label : () => `Orbit Period Solar`,
       value : [ { v: () => (holisticyearLength/erosSolarYearCount)*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Eros's Solar orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/${fmtNum(erosSolarYearCount,0,',')})*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Sidereal`,
       value : [ { v: () => (holisticyearLength/(erosSolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Eros's Sidereal orbit period in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(erosSolarYearCount,0,',')}-13))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Orbit Period Synodic`,
       value : [ { v: () => -(holisticyearLength/(erosSolarYearCount-holisticyearLength))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }],
       hover : [`Eros's synodic period with Earth in days is calculated as (${fmtNum(holisticyearLength,0,',')}/(${fmtNum(erosSolarYearCount,0,',')}-${fmtNum(holisticyearLength,0,',')}))*${fmtNum(meansolaryearlengthinDays,6,',')}`],
       static: true},
      {label : () => `Mean Motion (n)`,
       value : [ { v: () => OrbitalFormulas.meanMotion((holisticyearLength/(erosSolarYearCount-13))*meansolaryearlengthinDays), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Mean angular motion: n = 360°/P. Rate at which mean anomaly increases`],
       static: true},
      {label : () => `Period (Kepler verification)`,
       value : [ { v: () => OrbitalFormulas.keplerPeriod(erosOrbitDistance * o.lengthofAU), dec:6, sep:',' },{ small: 'days' }],
       hover : [`Kepler's 3rd Law: P = 2π√(a³/GM). Should match sidereal period`]},
    null,
      {label : () => `Length of Day`,
       value : [ { v: () => (erosRotationPeriod*(((holisticyearLength/erosSolarYearCount)*meansolaryearlengthinDays)*24))/((((holisticyearLength/erosSolarYearCount)*meansolaryearlengthinDays)*24)-erosRotationPeriod), dec:6, sep:',' }, { small : 'hours' }]},
      {label : () => `Length of Sidereal Day`,
       value : [ { v: () => erosRotationPeriod, dec:6, sep:',' },{ small: 'hours' }],
       static: true},

    {header : '—  Orbital Shape & Geometry —' },
      {label : () => `Semi-major axis (a)`,
       value : [ { v: () => erosOrbitDistance, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Eros distance to Sun in AU is calculated as ((${fmtNum(holisticyearLength,0,',')}/${fmtNum(erosSolarYearCount,0,',')})^2)^(1/3)`],
       static: true},
      {label : () => `Semi-major axis`,
       value : [ { v: () => erosOrbitDistance*o.lengthofAU, dec:2, sep:',' },{ small: 'km' }],
       hover : [`Eros distance to Sun in km is calculated as (((${fmtNum(holisticyearLength,0,',')}/${fmtNum(erosSolarYearCount,0,',')})^2)^(1/3))*${fmtNum(o.lengthofAU,6,',')}`]},
      {label : () => `Semi-minor axis (b)`,
       value : [ { v: () => OrbitalFormulas.semiMinorAxis(erosOrbitDistance, erosOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Half-width of orbital ellipse: b = a × √(1-e²)`],
       static: true},
    null,
      {label : () => `Perihelion distance (q)`,
       value : [ { v: () => OrbitalFormulas.perihelionDist(erosOrbitDistance, erosOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Closest approach to Sun: q = a(1-e)`],
       static: true},
      {label : () => `Aphelion distance (Q)`,
       value : [ { v: () => OrbitalFormulas.aphelionDist(erosOrbitDistance, erosOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Farthest distance from Sun: Q = a(1+e)`],
       static: true},
      {label : () => `Current distance from Sun (r)`,
       value : [ { v: () => eros.sunDistAU, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Eros's current heliocentric distance`]},
    null,
      {label : () => `Semi-latus rectum (p)`,
       value : [ { v: () => OrbitalFormulas.semiLatusRectum(erosOrbitDistance, erosOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Orbital radius at true anomaly = 90°: p = a × (1-e²)`],
       static: true},
      {label : () => `Focal distance (c)`,
       value : [ { v: () => OrbitalFormulas.focalDistance(erosOrbitDistance, erosOrbitalEccentricity), dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Distance from ellipse center to focus (Sun): c = a × e`],
       static: true},
      {label : () => `PERIHELION-OF-EROS Distance`,
       value : [ { v: () => erosPerihelionDistance/100, dec:6, sep:',' },{ small: 'AU' }],
       static: true},

    {header : '—  Velocities —' },
      {label : () => `Mean orbital speed`,
       value : [ { v: () => erosSpeed, dec:6, sep:',' },{ small: 'km/h' }],
       hover : [`Eros mean speed around the sun is calculated as (${fmtNum(erosOrbitDistance*o.lengthofAU,0,',')}*2*PI)/(${fmtNum(meansolaryearlengthinDays,6,',')}*${fmtNum((holisticyearLength/erosSolarYearCount),6,',')})/24`],
       static: true},
      {label : () => `Current orbital velocity`,
       value : [ { v: () => OrbitalFormulas.orbitalVelocity(eros.sunDistAU * o.lengthofAU, erosOrbitDistance * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Instantaneous velocity from vis-viva equation: v = √(GM(2/r - 1/a)). Varies from ${fmtNum(OrbitalFormulas.perihelionVelocity(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity) * 3600, 0, ',')} km/h at perihelion to ${fmtNum(OrbitalFormulas.aphelionVelocity(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity) * 3600, 0, ',')} km/h at aphelion`]},
    null,
      {label : () => `Radial velocity (vᵣ)`,
       value : [ { v: () => OrbitalFormulas.radialVelocity(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity, o.erosTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component toward/away from Sun: vᵣ = √(GM/p) × e × sin(ν). Positive = moving away, negative = approaching`]},
      {label : () => `Transverse velocity (vₜ)`,
       value : [ { v: () => OrbitalFormulas.transverseVelocity(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity, o.erosTrueAnomaly) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity component perpendicular to radius: vₜ = √(GM/p) × (1 + e × cos(ν)). Always positive`]},
    null,
      {label : () => `Perihelion velocity (vₚ)`,
       value : [ { v: () => OrbitalFormulas.perihelionVelocity(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Maximum orbital velocity at perihelion: vₚ = √(GM/a) × √((1+e)/(1-e))`]},
      {label : () => `Aphelion velocity (vₐ)`,
       value : [ { v: () => OrbitalFormulas.aphelionVelocity(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum orbital velocity at aphelion: vₐ = √(GM/a) × √((1-e)/(1+e))`]},
      {label : () => `Velocity ratio (vₚ/vₐ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatioPeriApo(erosOrbitalEccentricity), dec:4, sep:',' },{ small: '' }],
       hover : [`Perihelion vs aphelion velocity ratio: (1+e)/(1-e). Shows how much faster at perihelion`],
       static: true},
    null,
      {label : () => `Escape velocity (v_esc)`,
       value : [ { v: () => OrbitalFormulas.escapeVelocity(eros.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Minimum velocity to escape Sun's gravity from current position: v_esc = √(2GM/r)`]},
      {label : () => `Circular velocity (v_circ)`,
       value : [ { v: () => OrbitalFormulas.circularVelocity(eros.sunDistAU * o.lengthofAU) * 3600, dec:2, sep:',' },{ small: 'km/h' }],
       hover : [`Velocity needed for circular orbit at current distance: v_circ = √(GM/r)`]},
      {label : () => `Velocity ratio (v/v_circ)`,
       value : [ { v: () => OrbitalFormulas.velocityRatio(OrbitalFormulas.orbitalVelocity(eros.sunDistAU * o.lengthofAU, erosOrbitDistance * o.lengthofAU), eros.sunDistAU * o.lengthofAU), dec:4, sep:',' },{ small: '' }],
       hover : [`Current velocity vs circular: >1 near perihelion, <1 near aphelion, =√2 at escape`]},

    {header : '—  Energy & Momentum —' },
      {label : () => `Specific Orbital Energy (ε)`,
       value : [ { v: () => OrbitalFormulas.specificEnergy(erosOrbitDistance * o.lengthofAU), dec:4, sep:',' },{ small: 'km²/s²' }],
       hover : [`Total mechanical energy per unit mass: ε = -GM/(2a). Negative for bound orbits`]},
      {label : () => `Specific Angular Momentum (h)`,
       value : [ { v: () => OrbitalFormulas.specificAngularMomentum(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity), dec:2, sep:',' },{ small: 'km²/s' }],
       hover : [`Angular momentum per unit mass: h = √(GM × a × (1-e²)). Constant throughout orbit`]},
      {label : () => `Area Sweep Rate (dA/dt)`,
       value : [ { v: () => OrbitalFormulas.areaSweepRate(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity), dec:0, sep:',' },{ small: 'km²/s' }],
       hover : [`Kepler's 2nd Law: dA/dt = h/2. Constant rate - equal areas in equal times`]},

    {header : '—  Orbital Orientation to Ecliptic —' },
      {label : () => `Longitude of perihelion (ϖ)`,
       value : [ { v: () => o.erosPerihelion, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Sum of longitude of ascending node (Ω) and argument of periapsis (ω): ϖ = Ω + ω`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_periapsis'},
      {label : () => `Argument of periapsis (ω)`,
       value : [ { v: () => o.erosArgumentOfPeriapsis, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from ascending node to perihelion, measured in orbital plane: ω = ϖ - Ω`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_periapsis'},
    null,
      {label : () => `Longitude of ascending node (Ω)`,
       value : [ { v: () => o.erosAscendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle from vernal equinox to ascending node, measured in ecliptic plane`],
       info  : 'https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node'},
      {label : () => `Longitude of descending node`,
       value : [ { v: () => o.erosDescendingNode, dec:8, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Point where orbit crosses ecliptic going south: descending node = Ω + 180°`]},
   
   {header : '—  Orbital Orientation to Invariable Plane —' }, 
      {label : () => `Ascending Node on Inv. Plane (Ω)`,
       value : [ { v: () => o.erosAscendingNodeInvPlane, dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Longitude where orbit crosses the invariable plane going north`],
       info  : 'https://en.wikipedia.org/wiki/Invariable_plane'},
    null,
      {label : () => `Height above Invariable Plane`,
       value : [ { v: () => o.erosHeightAboveInvPlane, dec:6, sep:',' },{ small: 'AU' }],
       hover : [`Current vertical distance from the solar system's invariable plane: z = r × sin(i) × sin(u)`]},
      {label : () => `Position relative to Inv. Plane`,
       value : [ { v: () => o.erosAboveInvPlane ? 'ABOVE' : 'BELOW' },{ small: '' }],
       hover : [`Whether asteroid is currently north (above) or south (below) of the invariable plane`]},

    {header : '—  Position & Anomalies —' },
      {label : () => `Mean Anomaly (M)`,
       value : [ { v: () => o.erosMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular position assuming uniform circular motion from perihelion: M = n × t`],
       info  : 'https://en.wikipedia.org/wiki/Mean_anomaly'},
      {label : () => `Eccentric Anomaly (E)`,
       value : [ { v: () => o.erosEccentricAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle at ellipse center from Kepler's equation: M = E - e×sin(E)`],
       info  : 'https://en.wikipedia.org/wiki/Eccentric_anomaly'},
      {label : () => `True Anomaly (ν)`,
       value : [ { v: () => o.erosTrueAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Actual angular position from perihelion as seen from Sun`],
       info  : 'https://en.wikipedia.org/wiki/True_anomaly'},
      {label : () => `Equation of the Center`,
       value : [ { v: () => o.erosTrueAnomaly-o.erosMeanAnomaly, dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Difference between true and mean anomaly: ν - M. Maximum at quadrature points`],
       info  : 'https://en.wikipedia.org/wiki/Equation_of_the_center'},
    null,
      {label : () => `Mean Longitude (L)`,
       value : [ { v: () => OrbitalFormulas.meanLongitude(o.erosMeanAnomaly, o.erosPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Mean ecliptic longitude: L = M + ϖ (mean anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/Mean_longitude'},
      {label : () => `True Longitude (λ)`,
       value : [ { v: () => OrbitalFormulas.trueLongitude(o.erosTrueAnomaly, o.erosPerihelion), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Ecliptic longitude: λ = ν + ϖ (true anomaly + longitude of perihelion)`],
       info  : 'https://en.wikipedia.org/wiki/True_longitude'},
      {label : () => `Argument of Latitude (u)`,
       value : [ { v: () => OrbitalFormulas.argumentOfLatitude(o.erosArgumentOfPeriapsis, o.erosTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle in orbital plane from ascending node to asteroid: u = ω + ν`],
       info  : 'https://en.wikipedia.org/wiki/Argument_of_latitude'},
    null,
      {label : () => `Flight Path Angle (γ)`,
       value : [ { v: () => OrbitalFormulas.flightPathAngle(erosOrbitalEccentricity, o.erosTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angle between velocity vector and local horizontal: tan(γ) = e·sin(ν) / (1 + e·cos(ν))`],
       info  : 'https://en.wikipedia.org/wiki/Flight_path_angle'},
      {label : () => `Heliocentric Latitude (β)`,
       value : [ { v: () => OrbitalFormulas.heliocentricLatitude(o.erosInvPlaneInclinationDynamic, o.erosArgumentOfPeriapsis, o.erosTrueAnomaly), dec:4, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular distance above/below invariable plane: sin(β) = sin(i) × sin(u). Uses dynamic inclination.`]},
      {label : () => `Phase Angle to Earth (α)`,
       value : [ { v: () => OrbitalFormulas.phaseAngle(OrbitalFormulas.trueLongitude(o.erosTrueAnomaly, o.erosPerihelion), OrbitalFormulas.trueLongitude(o.earthTrueAnomaly, o.earthPerihelion)), dec:2, sep:',' },{ small: 'degrees (°)' }],
       hover : [`Angular separation from Earth as seen from Sun: 0° = conjunction, 180° = opposition`],
       info  : 'https://en.wikipedia.org/wiki/Phase_angle_(astronomy)'},
    null,
      {label : () => `True Anomaly Rate (dν/dt)`,
       value : [ { v: () => OrbitalFormulas.trueAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(erosSolarYearCount-13))*meansolaryearlengthinDays), erosOrbitalEccentricity, o.erosTrueAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of true anomaly: dν/dt = n(1+e·cos(ν))²/(1-e²)^1.5. Fastest at perihelion`]},
      {label : () => `Eccentric Anomaly Rate (dE/dt)`,
       value : [ { v: () => OrbitalFormulas.eccentricAnomalyRate(OrbitalFormulas.meanMotion((holisticyearLength/(erosSolarYearCount-13))*meansolaryearlengthinDays), erosOrbitalEccentricity, o.erosEccentricAnomaly), dec:6, sep:',' },{ small: '°/day' }],
       hover : [`Rate of change of eccentric anomaly: dE/dt = n / (1 - e×cos(E))`]},
      {label : () => `Radius of Curvature (ρ)`,
       value : [ { v: () => OrbitalFormulas.radiusOfCurvature(erosOrbitDistance * o.lengthofAU, erosOrbitalEccentricity, o.erosTrueAnomaly), dec:0, sep:',' },{ small: 'km' }],
       hover : [`Radius of osculating circle at current position: smallest at perihelion, largest at aphelion`]},

    {header : '—  Time Calculations —' },
      {label : () => `Time since perihelion`,
       value : [ { v: () => OrbitalFormulas.timeSincePerihelion(erosSolarYearInput, o.erosMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days elapsed since last perihelion passage: t = P × M / 360°`]},
      {label : () => `Time to next perihelion`,
       value : [ { v: () => OrbitalFormulas.timeToNextPerihelion(erosSolarYearInput, o.erosMeanAnomaly), dec:2, sep:',' },{ small: 'days' }],
       hover : [`Days until next perihelion passage: t = P × (360° - M) / 360°`]},

    {header : '—  Perihelion Precession —' },
      {label : () => `Perihelion Precession Duration against ICRF`,
       value : [ { v: () => erosPerihelionICRFYears, dec:2, sep:',', infinity: 1e9 },{ small: 'years' }],
       hover : [`Period for perihelion to complete one full revolution in the inertial ICRF frame`],
       static: true},
      {label : () => `Perihelion Precession Duration against Ecliptic`,
       value : [ { v: () => OrbitalFormulas.precessionEclipticToICRF(erosPerihelionICRFYears, holisticyearLength/13), dec:2, sep:',' },{ small: 'years' }],
       hover : [`Period relative to the ecliptic plane: T_ecl = (T_ICRF × T_ref) / (T_ICRF + T_ref)`],
       static: true},
      {label : () => `Precession Angular Velocity`,
       value : [ { v: () => OrbitalFormulas.precessionAngularVelocity(OrbitalFormulas.precessionRateFromPeriod(erosPerihelionICRFYears)) * 1e9, dec:6, sep:',' },{ small: '×10⁻⁹ rad/yr' }],
       hover : [`Angular velocity: ω = (arcsec/century / 100) × (π / 648000) rad/yr`],
       static: true},
    null,
      {label : () => `┌ Perihelion precession (Ecliptic)`,
       value : [ { v: () => OrbitalFormulas.precessionRateFromPeriod(erosPerihelionICRFYears), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`1,296,000 / ${fmtNum(erosPerihelionICRFYears,2,',')} = ${fmtNum(OrbitalFormulas.precessionRateFromPeriod(erosPerihelionICRFYears),2,',')} arcsec/century`],
       static: true},
      {label : () => `├ Missing advance of perihelion`,
       value : [ { v: () => calculateMissingPerihelionAdvance('eros'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Difference between Earth-frame and Ecliptic-frame perihelion advance from 1900 to 2000`]},
      {label : () => `└ Perihelion precession (Earth)`,
       value : [ { v: () => calculateEarthFramePrecession('eros'), dec:2, sep:',' },{ small: 'arcsec/century' }],
       hover : [`Earth-frame perihelion advance from 1900 to 2000 (sum of ecliptic precession + missing advance)`]},
    null,

    ],
};

/**
 * ──────────────────────────────────────────────────────────────────────────
 *  updateDomLabel()
 *  ------------------------------------------------------------------------
 *  • Fixed left-hand drawer (1/3 viewport wide, 100 vh tall)
 *  • Per-planet colour theme
 *  • Intro paragraph + picture
 *  • Flexible header / dynamic keys
 *  • Per-field number formatting via renderVal()
 *  • Usage:
 *  • planetStats.mars = [
 *  •   {
 *  •     label : 'Aphelion distance',
 *  •     value : fmtNum(249.2, 1) + ' million km',
 *  •     hover : 'Maximum distance from the Sun'
 *  •   },
 *  •  {
 *  •    label : 'Sidereal day ${fmtNum(mercurySolarYearCount,0,',')}',
 *  •    value : [{ v: () => (holisticyearLength/(mercurySolarYearCount-13))*meansolaryearlengthinDays, dec:6, sep:',' },{ small: 'days' }]
 *  •    hover : [
 *  •      ${fmtNum(5.972168e24, 0, ' ')} kg (exact)`,  // tooltip for primary
 *  •      'Earth-day ratio'                            // tooltip for alt
 *  •    ]
 *  •  },
 *  •  ];
 *  • Column widths frozen per-planet just like before
 * ──────────────────────────────────────────────────────────────────────────
 */
function updateDomLabel () {

  /* ———————————————————————————————————————————————
     escape &, ", <, > for safe use in title=""
     ——————————————————————————————————————————————— */
  const escapeAttr = str =>
    String(str)
      .replace(/&/g,  '&amp;')
      .replace(/"/g,  '&quot;')
      .replace(/</g,  '&lt;')
      .replace(/>/g,  '&gt;');

  /* ———————————————————————————————————————————————
     helper: compute max-height for <img> given drawer width
     ——————————————————————————————————————————————— */
  const maxImgHeight = (drawerWidth, ratio) =>
    Math.round(drawerWidth / ratio);          // px

  /* 0 — gather the DOM wrapper ------------------------------------------------ */
  const label = document.getElementById('planetLabel');
  if (!label) { console.error('#planetLabel element missing'); return; }

  /* 0a — build the static DOM only once --------------------------------------- */
  if (!label.dataset.init) {
    /* outer container that never changes */
    const content   = document.createElement('div');
    content.className = 'labelContent';

    /* **dynamic** part we will overwrite each frame */
    const body      = document.createElement('div');
    body.className  = 'labelBody';

    /* close button (static) */
    const closeBtn  = document.createElement('span');
    closeBtn.className  = 'closeBtn';
    closeBtn.textContent = '×';
    closeBtn.addEventListener('click', e => {
      e.stopPropagation();
      label.style.display = 'none';
      labelDismissed = true;
      
      /* -- turn off the helper of the planet that was being looked at */
      if (o.lookAtObj && o.lookAtObj.orbitPlaneHelper) {
      o.lookAtObj.orbitPlaneHelper.visible = false;
      }
    });

    /* assemble */
    content.appendChild(closeBtn);  // static
    content.appendChild(body);      // dynamic
    label.appendChild(content);

    /* keep a reference so we can reach it later */
    label._body = body;

    /* — keep image heights in sync on resize — */
    window.addEventListener('resize', () => {
      const w = label.clientWidth || (innerWidth / 3);
      content.querySelectorAll('.pl-img[data-ar]')
        .forEach(img => {
          const ar = +img.dataset.ar || (16 / 9);
          img.style.maxHeight = Math.round(w / ar) + 'px';
        });
    });

    label.dataset.init = '1';
  }
  
  const body    = label._body;          // <div class="labelBody">
  const content = label.querySelector('.labelContent');

  /* 1 — what planet are we looking at?  -------------------------------------- */
  const selObj   = o.lookAtObj;
  const selName  = selObj?.name?.toLowerCase() || '';
  const stats    = planetStats[selName];
  const meta     = planetMeta [selName];

  const showCard = !!stats;

  /* 2 — apply / clean colour theme ------------------------------------------- */
  if (showCard) {
    const themeCls = `theme-${selName}`;
    for (const c of [...label.classList]) {
      if (c.startsWith('theme-') && c !== themeCls) label.classList.remove(c);
    }
    if (!label.classList.contains(themeCls)) label.classList.add(themeCls);
  }

  /* 3 — early exit if nothing to show / user closed it ----------------------- */
  if (!showCard) {
    label.style.display = 'none';
    labelDismissed      = false;
    prevPlanetName      = '';
    return;
  }
  if (selName !== prevPlanetName) {
    labelDismissed = false;
    prevPlanetName = selName;
    // Clear static cache for fresh evaluation on planet change
    staticValueCache[selName] = {};
  }
  if (labelDismissed) { label.style.display = 'none'; return; }

  // Ensure cache exists for current planet
  if (!staticValueCache[selName]) staticValueCache[selName] = {};

  /* 4 — HEADER block (title • intro • image) --------------------------------- */
  const { intro = '', img = '', imgRatio = 16 / 9 } = meta ?? {};
  const drawerW  = label.clientWidth || (innerWidth / 3);
  const imgMaxH  = maxImgHeight(drawerW, imgRatio);

  let nextHTML = /* html */`
    <div class="pl-title">
      ${PLANET_SYMBOL[selName] ? `<span class="pl-symbol">${PLANET_SYMBOL[selName]}</span>` : ''}
      <span class="pl-name">${niceName(selName)}</span>
    </div>
    ${intro ? `<p class="pl-intro">${intro}</p>` : ''}
    ${img   ? `<img class="pl-img"
                   src="${img}"
                   alt="${selName}"
                   data-ar="${imgRatio}"
                   style="width:100%;height:auto;max-height:${imgMaxH}px">` : ''}
    <div class="scrollBox"><div class="pl-grid">
  `;

  /* 5 — DATA GRID ------------------------------------------------------------ */
  const cache = staticValueCache[selName];
  let _debugCacheHits = 0, _debugCacheMisses = 0, _debugDynamic = 0;
  for (let rowIdx = 0; rowIdx < stats.length; rowIdx++) {
    const row = stats[rowIdx];

    /* section header --------------------------------------------------------- */
    if (row?.header) {
      // Resolve hover text for header if present
      let headerHover = '';
      if (row.hover !== undefined) {
        const hv = (typeof row.hover === 'function') ? row.hover() : row.hover;
        headerHover = Array.isArray(hv) ? hv[0] : hv;
      }
      const headerTitleAttr = headerHover ? ` title="${escapeAttr(headerHover)}"` : '';

      // Headers with dynamic dates are not cached
      if (row.date) {
        const rawDate = (typeof row.date === 'function') ? row.date() : row.date;
        let dateStr   = '';
        if (rawDate !== undefined && rawDate !== null) {
          const d = (rawDate instanceof Date)      ? rawDate :
                    (typeof rawDate === 'number')  ? new Date(rawDate) :
                    (typeof rawDate === 'string' && /[/-]/.test(rawDate))
                                                    ? new Date(...rawDate.split(/[/-]/).map((p,i)=> i === 1 ? p-1 : p))
                                                    : new Date(rawDate);
          dateStr = (!isNaN(d)) ? d.toLocaleDateString('en-GB') : String(rawDate);
        }
        nextHTML += `<span class="pl-head"${headerTitleAttr}>${row.header}${dateStr ? ` <span class="date">${dateStr}</span>` : ''}</span>`;
      } else {
        // Static header - use cache (but only if no hover, since hover may need escaping)
        if (row.hover === undefined && cache[rowIdx] === undefined) {
          cache[rowIdx] = `<span class="pl-head">${row.header}</span>`;
        }
        if (row.hover === undefined) {
          nextHTML += cache[rowIdx];
        } else {
          nextHTML += `<span class="pl-head"${headerTitleAttr}>${row.header}</span>`;
        }
      }
      continue;
    }

    /* blank line ------------------------------------------------------------- */
    if (row === null) {
      nextHTML += '<span class="pl-blank"></span><span class="pl-blank"></span><span class="pl-blank"></span>';
      continue;
    }

    /* Check if this row is marked as static and we have a cached value */
    if (row.static && cache[rowIdx] !== undefined) {
      nextHTML += cache[rowIdx];
      _debugCacheHits++;
      continue;
    }
    if (row.static) _debugCacheMisses++; else _debugDynamic++;

    /* regular data row ------------------------------------------------------- */
    let labelTxt, rawVal, rawHover;
    if ('label' in row && 'value' in row) {        // helper format
      labelTxt = (typeof row.label === 'function') ? row.label() : row.label;
      rawVal   = row.value;
      rawHover = row.hover;
    } else {
      const pair = Object.entries(row).find(([k]) => k !== 'info');
      [labelTxt, rawVal] = pair ?? ['?', ''];
      rawHover = undefined;
    }

    /* resolve hover text(s) -------------------------------------------------- */
    let h1 = '', h2 = '';
    if (rawHover !== undefined) {
      const hv = (typeof rawHover === 'function') ? rawHover() : rawHover;
      if (Array.isArray(hv)) [h1, h2] = hv;
      else                    h1 = h2 = hv;
    }
    const keyTitle  = h1 || h2;
    const keyAttr   = keyTitle ? ` title="${escapeAttr(keyTitle)}"` : '';
    const valAttr   = h1       ? ` title="${escapeAttr(h1)}"`       : '';
    const altAttr   = h2       ? ` title="${escapeAttr(h2)}"`       : '';

    const keyHTML = row.info
      ? `${labelTxt} <a class="pl-info" target="_blank" href="${row.info}">ⓘ</a>`
      : labelTxt;

    /* split value + alt like before */
    let v1 = rawVal, v2 = '';
    if (Array.isArray(rawVal)) [v1, v2] = rawVal;

    const rowHTML =
      `<span class="pl-key"${keyAttr}>${keyHTML}</span>` +
      `<span class="pl-val"${valAttr}>${renderVal(v1)}</span>` +
      `<span class="pl-alt"${altAttr}>${renderVal(v2)}</span>`;

    /* Cache static rows for future updates */
    if (row.static) {
      cache[rowIdx] = rowHTML;
    }

    nextHTML += rowHTML;
  }

  nextHTML += '</div></div>';   // close .pl-grid and .scrollBox

  // DEBUG: Log cache performance (uncomment to enable)
  // console.log(`[${selName}] Cache hits: ${_debugCacheHits}, Misses: ${_debugCacheMisses}, Dynamic: ${_debugDynamic}`);

  /* 6 — inject only if changed ---------------------------------------------- */
  if (nextHTML !== labelPrevHTML) {
    // Preserve scroll position before updating innerHTML
    const scrollBox = body.querySelector('.scrollBox');
    const savedScrollTop = scrollBox ? scrollBox.scrollTop : 0;

    body.innerHTML = nextHTML;
    labelPrevHTML     = nextHTML;

    /* freeze column widths the first time we show this planet ---------------- */
    if (!columnCache[selName]) {
      const grid  = content.querySelector('.pl-grid');
      const vals  = [...grid.querySelectorAll('.pl-val')];
      const alts  = [...grid.querySelectorAll('.pl-alt')];

      const maxValCh = Math.max(...vals.map(s => s.textContent.length)) + 1;
      const maxAltCh = Math.max(...alts.map(s => s.textContent.length)) + 1;

      columnCache[selName] = `max-content ${maxValCh}ch ${maxAltCh}ch`;
    }
    content.querySelector('.pl-grid').style.gridTemplateColumns =
      columnCache[selName];

    // Restore scroll position after updating innerHTML
    const newScrollBox = body.querySelector('.scrollBox');
    if (newScrollBox && savedScrollTop > 0) {
      newScrollBox.scrollTop = savedScrollTop;
    }
  }

  /* 7 — show the drawer ------------------------------------------------------ */
  label.style.display = 'block';
}

function updateSunGlow() {
  // 1a) Get the world position of the glow’s pivot into _tempVec
  sunGlow.getWorldPosition(_tempVec);

  // 1b) Compute distance camera→sunGlow
  const sunDistance = camera.position.distanceTo(_tempVec);

  // 1c) Scale the glow based on that distance
  const glowSize = sunDistance / 2;
  sunGlow.scale.set(glowSize, glowSize, 10);
}

function updateStarSizes() {
  sceneObjects.stars.children.forEach(function(starPos) {
    const star = starPos.children[0]; // First child = star Sprite

    if (star && star instanceof THREE.Sprite) {
      const magnitude = star.userData.magnitude; // Saved during creation
      let starsize;

      if (magnitude < 1) {
        starsize = o.starsizeBase * 1.5;
      } else if (magnitude >= 1 && magnitude < 3) {
        starsize = o.starsizeBase * 1.0;
      } else if (magnitude >= 3 && magnitude < 5) {
        starsize = o.starsizeBase * 0.6;
      } else {
        starsize = o.starsizeBase * 0.3;
      }

      star.scale.set(starsize, starsize, 1);
    }
  });
}

function updateFocusRing() {

  /* ── 1  Nothing is selected or hierarchy inspector is active → ring off and exit early ─────────── */
  if (!o.lookAtObj || hierarchyInspector._cameraControlActive) {
    focusRing.visible = false;
    return;
  }

  /* ── 2  Show the ring only when we are looking at the Sun ─────── */
  const isSun = o.lookAtObj.name === 'Sun';

  if (isSun && o.sun?.pivotObj) {
    o.sun.pivotObj.updateMatrixWorld();

    focusRing.position.copy(
      o.sun.pivotObj.getWorldPosition(tmpVec)
    );
    focusRing.scale.set(5, 5, 0);   // whatever size you need
    focusRing.visible = true;
    } else {
    focusRing.visible = false;
  }
}

function createFlare(color, scale) {
  const material = new THREE.SpriteMaterial({
    map: flareTexture || null,
    color: color,
    blending: THREE.AdditiveBlending,
    transparent: true,
    depthWrite: false,
    opacity: 0.5,
  });
  const sprite = new THREE.Sprite(material);
  sprite.scale.set(scale, scale, 1);
  scene.add(sprite);
  return sprite;
}

// The flares need to be added to the position of the Sun
function updateFlares() {
  sunGlow.getWorldPosition(_flareSunPos);
  camera.getWorldPosition(_flareCamPos);
  camera.getWorldDirection(_flareCamDir);

  _flareToSun.subVectors(_flareSunPos, _flareCamPos).normalize();

  const dot = _flareCamDir.dot(_flareToSun);

  if (dot > 0.5) {
    _flareLineDir.subVectors(_flareCamPos, _flareSunPos).normalize();

    flares.forEach((flare, index) => {
      const factor = (index - 0.5) * (index - 2) * 15;

      _flarePos.copy(_flareSunPos);
      _flarePos.addScaledVector(_flareLineDir, factor);

      flare.position.copy(_flarePos);
      flare.visible = true;
      flare.material.opacity = 1.0 - Math.abs(index - 1) * 0.3;
    });
  } else {
    flares.forEach(flare => {
      flare.visible = false;
    });
  }
}

/**
 * Call once per frame *after* you have moved the Sun & planets,
 * but *before* renderer.render().
 *
 * @param {THREE.Mesh} planetMesh  – the mesh that receives the shadow
 * @param {number}      pad        – padding multiplier (> 1) for safety
 */
function updateSunlightForPlanet(planetMesh, pad = 1.1) {

  if (!planetMesh) return;

  /* 1. Sun & planet world positions ------------------------------ */
  sun.planetObj.getWorldPosition(_sunWS);
  planetMesh   .getWorldPosition(_planetWS);

  /* 2. move the light to the Sun & aim at planet ----------------- */
  sunLight.position.copy(_sunWS);
  sunLight.target.position.copy(_planetWS);
  sunLight.target.updateMatrixWorld(true);

  /* 3. force Three to rebuild the shadow camera                    *
   *    (this fixes the “camera pointing down” problem)            */
  sunLight.shadow.updateMatrices(sunLight);        // <- KEY LINE
  sunLight.updateMatrixWorld(true);                // also refresh self

  /* 4. world-space AABB of the planet mesh ----------------------- */
  _wsBox.setFromObject(planetMesh);

  /* 5. bring the 8 corners into *light* space -------------------- */
  _invMat.copy(sunLight.shadow.camera.matrixWorldInverse);

  let i = 0;
  for (const x of [_wsBox.min.x, _wsBox.max.x])
  for (const y of [_wsBox.min.y, _wsBox.max.y])
  for (const z of [_wsBox.min.z, _wsBox.max.z]) {
    _cornersLS[i++].set(x, y, z).applyMatrix4(_invMat);
  }

  /* 6. light-space AABB + padding -------------------------------- */
  _lsBox.setFromPoints(_cornersLS);
  _lsBox.min.multiplyScalar(pad);
  _lsBox.max.multiplyScalar(pad);

  /* 7. write extents to the orthographic camera ------------------ */
  const cam = sunLight.shadow.camera;
  cam.left   = _lsBox.min.x;
  cam.right  = _lsBox.max.x;
  cam.bottom = _lsBox.min.y;
  cam.top    = _lsBox.max.y;

  /* --- key change: keep near tiny, far big ---------------------- */
  cam.near = 0.1;                 // a fixed, small value near the Sun
  cam.far  = -_lsBox.min.z;       // always positive and > near
  cam.updateProjectionMatrix();

  /* 8. helper (for debugging) ------------------------------------ */
  if (typeof shadowCameraHelper !== 'undefined') {
    shadowCameraHelper.update();
  }
}

function updateLightingForFocus() {

  /* — 1 ────────────────────────────────────────────────────────────
     If no planet is selected, restore the default lighting state
  */
  if (!o.lookAtObj) {
    sunLight.visible      = true;   // normal directional sunlight
    fallbackLight.visible = false;  // camera-following point light off
    return;                         // nothing more to do
  }

  /* — 2 ────────────────────────────────────────────────────────────
     A planet *is* selected → decide what to do with the lights
  */
  const isSun = o.lookAtObj.name === 'Sun';

  if (isSun) {
    // Looking directly at the Sun: switch to the point light on camera
    sunLight.visible      = false;
    fallbackLight.visible = true;
    fallbackLight.position.copy(camera.position);
  }
  else if (o.lookAtObj.pivotObj) {
    // Any other body: keep the directional light and aim it correctly
    sunLight.visible      = true;
    fallbackLight.visible = false;

    updateSunlightForPlanet(o.lookAtObj.planetObj);
  }
}

// Animation (pulsing) - only updates when zodiac is visible
function animateGlow() {
    if (!zodiac.visible) return;
    glowMaterial.opacity = 0.2 + 0.1 * Math.sin(Date.now() * 0.002);
}

function createEarthPolarLine() {
  const material = new THREE.LineBasicMaterial({ color: 0xffffff });

  let geometry;

  // Use BufferGeometry (THREE.Geometry was removed in Three.js r125+)
  geometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, -100, 0),
    new THREE.Vector3(0, 100, 0)
  ]);

  const line = new THREE.Line(geometry, material);
  line.visible = o['Polar line'];
  return line;
}

function changeSphereScale() {
      celestialSphere.scale.set(o.cSphereSize, o.cSphereSize, o.cSphereSize);    
}
  
function changeZodiacScale() {
      zodiac.scale.set(o.zodiacSize, o.zodiacSize, o.zodiacSize);  
}

function updatePosition() {
  o.pos = sDay * dateToDays(o.Date) + timeToPos(o.Time);
  const p = dayToDateNew(o.julianDay,'julianday','perihelion-calendar');
  o.perihelionDate = `${p.date}`;
  positionChanged = true; // Signal animation loop to update scene
}

function changeTraceScale(){
    tracePlanets.forEach(obj => {
    if (obj.traceLine) {
        obj.traceLine.material.size = obj.size*10 * o.traceSize
    }
  });  
}

function changePlanetScale(){
    planetObjects.forEach(obj => {
      obj.planetObj.scale.x = o.Size
      obj.planetObj.scale.y = o.Size
      obj.planetObj.scale.z = o.Size
  });  
}

function auToKm(au) { return au * o.lengthofAU; }  // live conversion

/*──────────────────────────────────────────────────────────────────────────╮
│  updatePositions – reference sheet                                        │
│                                                                           │
│  What each output means and precisely how it is derived                   │
╞═══════════════════════════════════════════════════════════════════════════╡
│  SYMBOLS                                                                  │
│    EARTH_POS   world-space centre of the Earth            (Vector3)       │
│    SUN_POS     world-space centre of the Sun              (Vector3)       │
│    PLANET_POS  world-space centre of current planet       (Vector3)       │
│    LOCAL       PLANET_POS expressed in Earth-equatorial   (Vector3)       │
│                coordinates – i.e. the local space of                      │
│                earth.rotationAxis (includes axial tilt                    │
│                and 21-June spin)                                          │
│    DELTA       reusable difference vector                                 │
│    SPHERICAL   THREE.Spherical used to extract θ (RA), φ (Dec), r         │
│                                                                           │
│───────────────────────────────────────────────────────────────────────────│
│ 1. EARTH → planet  (distance)                                             │
│      DELTA     = PLANET_POS − EARTH_POS      // world coords              │
│      AU        = |DELTA| / 100               // scene-units → AU          │
│      km        = AU × currentAUDistance                                   │
│                                                                           │
│ 2. EARTH → planet  (RA / Dec)                                             │
│      LOCAL     = worldToLocal( PLANET_POS, earth.rotationAxis )           │
│      SPHERICAL.setFromVector3( LOCAL )                                    │
│      RA(rad)  = θ  = SPHERICAL.theta                                      │
│      Dec(rad) = φ  = SPHERICAL.phi                                        │
│                                                                           │
│      • LOCAL is expressed in the Earth-equatorial frame,                  │
│        so θ already measures from 0 h at the                              │
│        intersection of the equator & ecliptic *including* the             │
│        90° spin you applied for 21 June.                                  │
│                                                                           │
│ 3. SUN  → planet  (distance)                                              │
│      DELTA     = PLANET_POS − SUN_POS       // world coords               │
│      AU / km   computed exactly as in step 1                              │
│                                                                           │
│ 4. EARTH → camera (GUI read-out)                                          │
│      Same recipe as steps 1 & 2, but                                      │
│      PLANET_POS → CAMERA_POS.                                             │
│                                                                           │
│───────────────────────────────────────────────────────────────────────────│
│  Notes                                                                    │
│  • Switching o.distanceUnit between “AU”, "km" and “km” picks which       │
│    formatted string is exposed to dat.GUI (distDisplay, sunDistDisplay).  │
│  • Any future changes to axial tilt, solstice offsets,                    │
│    or precession automatically propagate, because we                      │
│    always convert world vectors into earth.rotationAxis local space       │
│    *before* reading θ / φ from THREE.Spherical.                           │
╰───────────────────────────────────────────────────────────────────────────*/
// Validation helper for matrix update optimization (remove once confident)
const _matrixValidationPos1 = new THREE.Vector3();
const _matrixValidationPos2 = new THREE.Vector3();
let _matrixValidationWarned = false;

// Reusable vectors for calculateRAFromWobbleCenter (avoid allocation in hot path)
const _wobbleRA_PLANET_POS = new THREE.Vector3();
const _wobbleRA_WOBBLE_POS = new THREE.Vector3();
const _wobbleRA_DIRECTION = new THREE.Vector3();
const _wobbleRA_ROT_MATRIX = new THREE.Matrix4();
const _wobbleRA_SPHERICAL = new THREE.Spherical();

/**
 * Calculate RA from the wobble center (origin) instead of Earth's position.
 * This eliminates the ~44ms/day parallax artifact caused by Earth's
 * precession wobble motion. Use for precise solar day calculations.
 *
 * The standard RA calculation uses Earth's actual position as the origin,
 * which includes the wobble offset from precession. For solar day timing,
 * we need RA calculated from the stable wobble center (origin) to avoid
 * the parallax artifact.
 *
 * @param {Object} obj - Planet object with planetObj property
 * @returns {number} - RA in radians from wobble center perspective
 */
function calculateRAFromWobbleCenter(obj) {
  obj.planetObj.getWorldPosition(_wobbleRA_PLANET_POS);
  earthWobbleCenter.planetObj.getWorldPosition(_wobbleRA_WOBBLE_POS);

  // Direction from wobble center (origin) to planet
  _wobbleRA_DIRECTION.copy(_wobbleRA_PLANET_POS).sub(_wobbleRA_WOBBLE_POS);

  // Extract just the rotation from earth.rotationAxis (ignore position)
  _wobbleRA_ROT_MATRIX.extractRotation(earth.rotationAxis.matrixWorld);
  _wobbleRA_ROT_MATRIX.invert();

  // Apply rotation to get direction in Earth's equatorial frame
  _wobbleRA_DIRECTION.applyMatrix4(_wobbleRA_ROT_MATRIX);

  _wobbleRA_SPHERICAL.setFromVector3(_wobbleRA_DIRECTION);
  return _wobbleRA_SPHERICAL.theta;
}

// Reusable objects for calculateRAFromEarthPerihelion
const _periRA_PLANET_POS = new THREE.Vector3();
const _periRA_PERI_POS = new THREE.Vector3();
const _periRA_DIRECTION = new THREE.Vector3();
const _periRA_ROT_MATRIX = new THREE.Matrix4();
const _periRA_SPHERICAL = new THREE.Spherical();

/**
 * Calculate RA from the earthPerihelionFromEarth point instead of Earth's position.
 * This uses the perihelion point as the origin for RA calculation, which may
 * provide different results compared to Earth-based or wobble-center-based RA.
 *
 * @param {Object} obj - Planet object with planetObj property
 * @returns {number} - RA in radians from perihelion point perspective
 */
function calculateRAFromEarthPerihelion(obj) {
  obj.planetObj.getWorldPosition(_periRA_PLANET_POS);
  earthPerihelionFromEarth.planetObj.getWorldPosition(_periRA_PERI_POS);

  // Direction from perihelion point to planet
  _periRA_DIRECTION.copy(_periRA_PLANET_POS).sub(_periRA_PERI_POS);

  // Extract just the rotation from earth.rotationAxis (ignore position)
  _periRA_ROT_MATRIX.extractRotation(earth.rotationAxis.matrixWorld);
  _periRA_ROT_MATRIX.invert();

  // Apply rotation to get direction in Earth's equatorial frame
  _periRA_DIRECTION.applyMatrix4(_periRA_ROT_MATRIX);

  _periRA_SPHERICAL.setFromVector3(_periRA_DIRECTION);
  return _periRA_SPHERICAL.theta;
}

function updatePositions() {
  // 0.  Update world matrices for objects we need (optimized)
  //     Instead of scene.updateMatrixWorld(true) which traverses ALL objects,
  //     we only update the specific branches we actually use:
  //     - startingPoint.pivotObj covers: earth, sun, barycenter, all planets, moon
  //     - earthWobbleCenter.pivotObj covers: the wobble center (separate branch)
  //     - camera: needed for worldToLocal calculations
  startingPoint.pivotObj.updateMatrixWorld(true);
  earthWobbleCenter.pivotObj.updateMatrixWorld(true);
  camera.updateMatrixWorld(true);

  // VALIDATION CHECK: Compare against full scene update (remove once confident)
  // This runs once per session to verify the optimization is correct
  if (!_matrixValidationWarned) {
    // Capture position after optimized update
    sun.planetObj.getWorldPosition(_matrixValidationPos1);

    // Do full scene update
    scene.updateMatrixWorld(true);

    // Compare
    sun.planetObj.getWorldPosition(_matrixValidationPos2);

    if (!_matrixValidationPos1.equals(_matrixValidationPos2)) {
      console.warn('Matrix optimization mismatch detected!',
        'Optimized:', _matrixValidationPos1.toArray(),
        'Full:', _matrixValidationPos2.toArray());
      _matrixValidationWarned = true; // Only warn once
    } else {
      console.log('Matrix optimization validated successfully');
      _matrixValidationWarned = true; // Only check once
    }
  }

  // 1.  anchor points in world space
  earth.rotationAxis.getWorldPosition(EARTH_POS);  // Earth centre
  sun.planetObj.getWorldPosition(SUN_POS);         // Sun   centre
  earthWobbleCenter.planetObj.getWorldPosition(WOBBLE_POS);         // Sun   centre
  barycenterEarthAndSun.planetObj.getWorldPosition(PERIHELION_OF_EARTH_POS);         // PERIHELION-OF-EARTH   centre

  // ───────────────────────── each planet ───────────────────────────
  for (let i = 0, L = tracePlanets.length; i < L; i++) {
    const obj = tracePlanets[i];
    obj.planetObj.getWorldPosition(PLANET_POS);

    /*  EARTH → PLANET  (distance)  */
    DELTA.subVectors(PLANET_POS, EARTH_POS);         // world coords
    obj.distAU = DELTA.length() / 100;               // scene → AU
    obj.distKm = auToKm(obj.distAU);                 // AU → km (live)
    obj.distMi = obj.distKm * KM_TO_MI;

    /*  EARTH → PLANET  (direction for RA/Dec)
        We need the vector expressed in the Earth-equatorial frame, which
        already includes axial tilt *and* the 90° spin you applied on
        21 June (earth.containerObj.rotation.y = π/2).  The quickest way
        is to transform the planet's world position into the local
        coordinates of earth.rotationAxis.                                  */
    LOCAL.copy(PLANET_POS);
    earth.rotationAxis.worldToLocal(LOCAL);          // in-place

    SPHERICAL.setFromVector3(LOCAL);                 // Earth local frame
    obj.ra  = SPHERICAL.theta;                       // radians
    obj.dec = SPHERICAL.phi;                         // radians

    /*  SUN → PLANET (distance)  */
    DELTA.subVectors(PLANET_POS, SUN_POS);           // reuse DELTA
    const sunRadius   = DELTA.length();
    obj.sunDistAU     = sunRadius / 100;
    obj.sunDistKm     = auToKm(obj.sunDistAU);
    obj.sunDistMi     = obj.sunDistKm * KM_TO_MI;

      /*  PERIHELION-OF-EARTH → PERIHELION of planet (distance)  */
    DELTA.subVectors(PLANET_POS, WOBBLE_POS);           // reuse DELTA
    const perihelionRadius   = DELTA.length();
    obj.perihelionDistAU     = perihelionRadius / 100;
  }

  // ─────────────────────── camera read-out ─────────────────────────
  camera.getWorldPosition(CAMERA_POS);

  /*  Earth → Camera (distance & RA/Dec)  */
  CAM_LOCAL.copy(CAMERA_POS);
  earth.rotationAxis.worldToLocal(CAM_LOCAL);        // into Earth frame
  SPHERICAL.setFromVector3(CAM_LOCAL);

  o.worldCamRa  = SPHERICAL.theta;
  o.worldCamDec = SPHERICAL.phi;
  o._camDistAU  = SPHERICAL.radius / 100;            // store for display update
}

/** Updates display strings for UI - call at throttled rate (20 Hz) */
function updatePositionDisplayStrings() {
  // Update planet display strings
  for (let i = 0, L = tracePlanets.length; i < L; i++) {
    const obj = tracePlanets[i];

    // Skip if values not yet initialized
    if (obj.distAU == null) continue;

    // Distance display
    obj.distDisplay =
      (o.distanceUnit === 'AU') ? obj.distAU.toFixed(8) + ' AU' :
      (o.distanceUnit === 'km') ? obj.distKm.toFixed(2) + ' km'  :
                                  obj.distMi.toFixed(2) + ' mi';

    // RA/Dec display
    if (o.displayFormat === 'decimal') {
      obj.raDisplay  = ((obj.ra * 180 / Math.PI + 360) % 360).toFixed(4) + '°';
      obj.decDisplay = radiansToDecDecimal(obj.dec) + '°';
    } else {
      obj.raDisplay  = radiansToRa(obj.ra);
      obj.decDisplay = radiansToDec(obj.dec);
    }

    // Sun distance display
    obj.sunDistDisplay =
      (o.distanceUnit === 'AU') ? obj.sunDistAU.toFixed(8) + ' AU' :
      (o.distanceUnit === 'km') ? obj.sunDistKm.toFixed(2) + ' km'  :
                                  obj.sunDistMi.toFixed(2) + ' mi';
  }

  // Camera distance display
  if (o._camDistAU != null) {
    const camDistKm = auToKm(o._camDistAU);
    const camDistMi = camDistKm * KM_TO_MI;
    o.worldCamDistDisplay =
      (o.distanceUnit === 'AU') ? o._camDistAU.toFixed(8) + ' AU' :
      (o.distanceUnit === 'km') ? camDistKm.toFixed(2) + ' km'  :
                                  camDistMi.toFixed(2) + ' mi';
  }
}

function trace(pos) {
    tracePlanets.forEach(obj => {
      tracePlanet(obj, pos)
    });        
}

function resetAllTraces() {
  tracePlanets.forEach(obj => {
    // Remove existing trace line from scene
    if (obj.traceLine && obj.traceLine instanceof THREE.Object3D) {
      scene.remove(obj.traceLine);
    }

    // Clear all trace-related state
    obj.traceLine = undefined;
    obj.traceArrIndex = 0;
    obj.traceStartPos = o.pos;
    obj.traceCurrPos = o.pos;

    // Optionally reinitialize if enabled
    if (obj.traceOn && o.traceBtn) {
      setTraceMaterial(obj);
    }
  });
}

function setTraceMaterial(obj) {
  // 1) Compute how many segments we need
  const vertexCount = Math.round(obj.traceLength / obj.traceStep);

  // 2) If there’s an existing traceLine, remove & dispose it
  if (obj.traceLine && obj.traceLine instanceof THREE.Line) {
    scene.remove(obj.traceLine);

    // dispose old geometry & material to free GPU/JS memory
    obj.traceLine.geometry.dispose();
    obj.traceLine.material.dispose();

    obj.traceLine = null;
  }

  // 3) Build the new geometry and fill its position attribute
  const positions = new Float32Array(vertexCount * 3);
  const lineGeometry = new THREE.BufferGeometry();
  lineGeometry.setAttribute(
    'position',
    new THREE.BufferAttribute(positions, 3)
  );

  // 4) Create a simple line material (no texture)
  const lineMaterial = new THREE.LineBasicMaterial({
    color:       obj.color,
    linewidth:   obj.size,    // note: many platforms ignore linewidth > 1
    transparent: true,
    opacity:     0.7
  });

  // 5) Create the Line mesh, hide it, and add to scene
  obj.traceLine = new THREE.Line(lineGeometry, lineMaterial);
  obj.traceLine.visible = false;
  scene.add(obj.traceLine);
}

// Modified function with adaptive step for high-speed performance
function tracePlanet(obj, pos) {
  let update = false;

  if (!obj.traceOn || !o.traceBtn) {
    if (obj.traceLine && obj.traceLine instanceof THREE.Object3D) {
      obj.traceLine.visible = false;
    }
    return;
  }

  if (pos < obj.traceStartPos) {
    resetAllTraces(obj);
    update = true;
  }

  if (pos < obj.traceCurrPos) {
    obj.traceCurrPos = obj.traceStartPos;
    obj.traceArrIndex = 0;
    update = true;
  }

  if (obj.traceCurrPos + obj.traceStep > pos && !update) return;

  if (!obj.traceLine || !(obj.traceLine instanceof THREE.Object3D)) {
    setTraceMaterial(obj);
  }

  let nextPos = obj.traceCurrPos;
  const positionAttr = obj.traceLine.geometry.attributes.position;
  const vertArray = positionAttr.array;
  const pointCount = vertArray.length / 3;

  // Adaptive step: at high speeds, increase step size to reduce iterations
  // Calculate how many iterations would be needed with base step
  const gap = pos - nextPos;
  const baseIterations = gap / obj.traceStep;

  // Target max ~50 iterations per frame for smooth performance
  const TARGET_ITERATIONS = 50;
  let effectiveStep = obj.traceStep;

  if (baseIterations > TARGET_ITERATIONS) {
    // Scale up the step to limit iterations
    const stepMultiplier = Math.ceil(baseIterations / TARGET_ITERATIONS);
    effectiveStep = obj.traceStep * stepMultiplier;
  }

  // Safety limit in case calculation is off
  const MAX_ITERATIONS = 100;
  let iterations = 0;

  while (nextPos < pos && iterations < MAX_ITERATIONS) {
    iterations++;
    moveModel(nextPos);
    earth.containerObj.updateMatrixWorld();
    obj.planetObj.getWorldPosition(_tracePos);

    const writeIndex = (obj.traceArrIndex % pointCount) * 3;
    vertArray[writeIndex + 0] = _tracePos.x;
    vertArray[writeIndex + 1] = _tracePos.y;
    vertArray[writeIndex + 2] = _tracePos.z;

    obj.traceArrIndex++;
    nextPos += effectiveStep;
  }

  positionAttr.needsUpdate = true;
  obj.traceCurrPos = nextPos - effectiveStep;
  obj.traceLine.visible = true;
}

function getZodiacRotationSpeed() {
  const earth = planetObjects.find(obj => obj.name === "Earth");
  return earth ? -earth.speed : 0;
}

function moveModel(pos) {

  let earthTheta = 0;                     // we need this afterwards

  planetObjects.forEach(obj => {

    // current mean (or true) anomaly, same formula you already used
    const θ = obj.speed * pos - obj.startPos * (Math.PI / 180);

    const a = obj.a ?? obj.orbitRadius;   // semi-major (or radius)
    const b = obj.b ?? obj.orbitRadius;   // semi-minor (or radius)
    const isEllipse = a !== b;            // true only when the axes differ

    if (isEllipse) {
      // -------- analytic curve --------
      const x = Math.cos(θ) * a;
      const z = Math.sin(θ) * b;

      obj.pivotObj.position.set(x, 0, z);
      obj.rotationAxis.position.set(x, 0, z);   // planet + rings

      obj.orbitObj.rotation.y = 0;              // keep the path still
    } else {
      // -------- orbitradius circular logic ----
      obj.orbitObj.rotation.y = θ; 
    }

    // planet’s own day-night spin
    if (obj.rotationSpeed) {
      obj.planetObj.rotation.y = obj.rotationSpeed * pos;
    }

    // remember Earth’s anomaly for the zodiac strip
    if (obj.name === 'Earth') earthTheta = θ;
  });

  // zodiac band keeps its old behaviour
  zodiac.rotation.y = -Math.PI / 3 - earthTheta;

  // Inclination path rotates with zodiac to stay aligned (but is independent object)
  if (typeof inclinationPathGroup !== 'undefined') {
    inclinationPathGroup.rotation.y = -Math.PI / 3 - earthTheta;
  }
  // Invariable plane also rotates with zodiac
  if (typeof invariablePlaneGroup !== 'undefined') {
    invariablePlaneGroup.rotation.y = -Math.PI / 3 - earthTheta;
  }
}

function getOptimizedPixelRatio() {
  const dpr = window.devicePixelRatio || 1;
  const smallScreen = Math.min(window.innerWidth, window.innerHeight) < 768;

  if (smallScreen && dpr > 1.5) {
    return 1.2; // Lower pixel ratio for small mobile devices
  } else {
    return Math.min(dpr, 2); // Keep max 2 for normal desktop/tablet
  }
}

// resize function:
function onWindowResize() {
  /* ---------- safe viewport ---------- */
  const width  = Math.max(MIN_SIZE, window.innerWidth);
  const height = Math.max(MIN_SIZE, window.innerHeight);
  const aspect = width / height;

  /* ---------- camera (fixed hFOV) ---- */
  const hFovRad = THREE.MathUtils.degToRad(DESIRED_HFOV);
  const vFovRad = 2 * Math.atan( Math.tan(hFovRad / 2) / aspect );
  camera.fov    = THREE.MathUtils.radToDeg(vFovRad);
  camera.aspect = aspect;
  camera.updateProjectionMatrix();

  /* ---------- renderer sizes --------- */
  renderer.setSize(width, height);
  renderer.setPixelRatio(getOptimizedPixelRatio());
  labelRenderer.setSize(width, height);

  /* ---------- star sprite size ------- */
  const dpr = renderer.getPixelRatio();      // 1, 2, 3, …
  starMaterial.size = 2 / dpr;               // stays ~2 CSS-px on any screen
}

function addPolarGridHelper(inplanet, planetSize = 10) {
  const polarGridHelper = new THREE.PolarGridHelper(
    planetSize * 1.1,  // slightly bigger than the planet
    12,                // 12 radial lines (for zodiac / months / seasons)
    6,                 // 6 circles
    32,                // fewer segments per circle (performance)
    0x0000ff,          // radial line color (blue)
    0x808080           // circle line color (gray)
  );
  polarGridHelper.material.opacity = 0.5;
  polarGridHelper.material.transparent = true;
  polarGridHelper.rotation.x = Math.PI / 2; // flat
  inplanet.add(polarGridHelper);
}

function posToDays(pos) {
  return Math.floor(pos / sDay);  // REMOVE +12h shift
}

function posToTime(pos) {
  let days = pos / sDay - Math.floor(pos / sDay);
  let hours = Math.floor(days * 24);
  let minutes = Math.floor((days * 24 - hours) * 60);
  let seconds = Math.round(((days * 24 - hours) * 60 - minutes) * 60);

  if (seconds === 60) {
    seconds = 0;
    minutes += 1;
  }

  if (minutes === 60) {
    minutes = 0;
    hours += 1;
  }
  
	let hh = ("0" + hours).slice(-2);
  let mm = ("0" + minutes).slice(-2);
  let ss = ("0" + seconds).slice(-2);

  return hh + ":" + mm +":" + ss
}

function timeToPos(value) {
  let aTime = value.split(":");
  let pos = aTime[0] * sHour + aTime[1] * sMinute + aTime[2] * sSecond;
  return pos;
}

/**
 * Computes the apparent RA of pdB as seen from pdA in Earth's equatorial frame,
 * then returns the 180°-opposite of that angle.
 *
 * COORDINATE SYSTEM: Earth's Equatorial Frame
 * The .ra values are computed by transforming world positions into earth.rotationAxis
 * local coordinates (see updatePositions). This is Earth's equatorial frame, which
 * includes axial tilt (~23.4°), axial precession, and other Earth orientation effects.
 *
 * 2D PROJECTION LIMITATION:
 * This function uses a 2D projection that ignores declination:
 *   x = r * cos(ra),  z = r * sin(ra)
 *
 * The correct 3D formula would be:
 *   x = r * cos(dec) * cos(ra),  z = r * cos(dec) * sin(ra)
 *
 * Impact of ignoring declination:
 * - For points at the same declination: No error (same scaling factor)
 * - For points at different declinations: Angular errors can occur
 * - Maximum error: ~8% radial compression at dec=±23.4° (ecliptic poles)
 * - For perihelion markers (near ecliptic, similar dec): Error is small
 *
 * For high-precision work with objects at significantly different declinations,
 * a full 3D approach should be used instead.
 *
 * @param {object} pdA - Reference object with .ra (radians) and .distKm
 * @param {object} pdB - Target object with .ra (radians) and .distKm
 * @returns {number} Opposite apparent RA in degrees [0, 360)
 * @throws {TypeError} If ra or distKm values are invalid
 * @throws {RangeError} If objects share identical coordinates
 */
function apparentRaFromPdA(pdA, pdB) {
  const RAD2DEG = 180 / Math.PI;
  const TWO_PI  = 2 * Math.PI;

  // 1) Pull raw RA in radians from each object (computed in Earth's equatorial frame)
  const ra1 = Number(pdA.ra);
  const ra2 = Number(pdB.ra);

  if (!Number.isFinite(ra1)) {
    throw new TypeError(`ra for ${pdA.name} is invalid: ${pdA.ra}`);
  }
  if (!Number.isFinite(ra2)) {
    throw new TypeError(`ra for ${pdB.name} is invalid: ${pdB.ra}`);
  }

  // 2) Normalize each input RA into [0, 2π)
  let θ1 = ra1 % TWO_PI;
  if (θ1 < 0) θ1 += TWO_PI;

  let θ2 = ra2 % TWO_PI;
  if (θ2 < 0) θ2 += TWO_PI;

  // 3) Pull & validate distances from Earth (km)
  const r1 = Number(pdA.distKm);
  const r2 = Number(pdB.distKm);

  if (!Number.isFinite(r1) || r1 < 0) {
    throw new TypeError(`distKm for ${pdA.name} is invalid: ${pdA.distKm}`);
  }
  if (!Number.isFinite(r2) || r2 < 0) {
    throw new TypeError(`distKm for ${pdB.name} is invalid: ${pdB.distKm}`);
  }

  // 4) Project each body's position onto the equatorial plane (2D approximation)
  //    NOTE: This ignores declination. Full 3D would use r * cos(dec) * cos/sin(ra)
  const x1 = r1 * Math.cos(θ1);
  const z1 = r1 * Math.sin(θ1);
  const x2 = r2 * Math.cos(θ2);
  const z2 = r2 * Math.sin(θ2);

  // 5) Vector from A → B in the equatorial plane
  const dx = x2 - x1;
  const dz = z2 - z1;

  // If they coincide exactly, the apparent RA is undefined
  if (dx === 0 && dz === 0) {
    throw new RangeError(
      `${pdA.name} and ${pdB.name} share identical equatorial coords`
    );
  }

  // 6) Apparent RA = atan2(dz, dx), normalized into [0, 2π)
  let aparRad = Math.atan2(dz, dx);
  if (aparRad < 0) {
    aparRad += TWO_PI;
  }

  // 7) Return the opposite direction (add π and re-wrap)
  let oppRad = aparRad + Math.PI;
  if (oppRad >= TWO_PI) {
    oppRad -= TWO_PI;
  }

  // 8) Convert to degrees [0, 360)
  return oppRad * RAD2DEG;
}

// ================================================================
// PERIHELION LONGITUDE CALCULATION METHODS
// ================================================================
//
// There are TWO different ways to measure perihelion longitude:
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ METHOD 1: EARTH-FRAME (apparentRaFromPdA)                                   │
// ├─────────────────────────────────────────────────────────────────────────────┤
// │ Reference frame: Earth's equatorial coordinate system                       │
// │ Measures: Apparent RA of perihelion as seen from Earth                      │
// │ Includes: Earth's axial tilt, precession, nutation, daily rotation          │
// │ Use case: What an observer on Earth would measure in RA coordinates         │
// │ Expected rate: ~532 arcsec/century mean (fluctuating ±100 around mean)      │
// │ Fluctuation period: ~6,500 years (harmonic of Earth precession cycles)      │
// │ Note: Over long periods (~300,000 years), averages to the Ecliptic value    │
// └─────────────────────────────────────────────────────────────────────────────┘
//
// ┌─────────────────────────────────────────────────────────────────────────────┐
// │ METHOD 2: ECLIPTIC (perihelionLongitudeEcliptic)                            │
// ├─────────────────────────────────────────────────────────────────────────────┤
// │ Reference frame: J2000 Ecliptic plane (heliocentric)                        │
// │ Measures: Pure precession angle from the model's precession layer           │
// │ Includes: Only the configured precession rate, nothing else                 │
// │ Use case: The "true" heliocentric precession rate                           │
// │ Expected rate: Exactly 534.94 arcsec/century for Mercury (stable)           │
// │ Fluctuation: NONE - perfectly stable by definition                          │
// └─────────────────────────────────────────────────────────────────────────────┘
//
// COMPARISON:
// - Ecliptic: Reads directly from precession layer rotation (perfectly stable)
// - Earth-frame: Uses equatorial RA transformation (fluctuates due to Earth)
//
// ================================================================

/**
 * ECLIPTIC-FRAME Perihelion Longitude
 * Computes the perihelion longitude in J2000 ecliptic coordinates.
 *
 * Reads directly from the precession layer's rotation.y, which represents
 * the precession angle in the ecliptic plane (rotation around world Y-axis).
 * This gives the "true" heliocentric precession, unaffected by Earth's
 * reference frame transformations.
 *
 * @param {object} precessionLayer - The precession duration layer (e.g., mercuryPerihelionDurationEcliptic1)
 * @param {number} longitudePerihelion - The J2000 longitude of perihelion in degrees
 * @returns {number} Perihelion longitude in degrees [0, 360)
 */
function perihelionLongitudeEcliptic(precessionLayer, longitudePerihelion) {
  const RAD2DEG = 180 / Math.PI;
  const TWO_PI = 2 * Math.PI;

  // Get the precession angle directly from the layer's orbitObj rotation
  // The rotation.y represents precession in the ecliptic plane
  let precessionAngle = precessionLayer.orbitObj.rotation.y;

  // Add the base longitude of perihelion (J2000 starting position)
  let totalAngle = precessionAngle + (longitudePerihelion * Math.PI / 180);

  // Normalize to [0, 2π)
  totalAngle = totalAngle % TWO_PI;
  if (totalAngle < 0) totalAngle += TWO_PI;

  return totalAngle * RAD2DEG;
}

// ================================================================
// MISSING PERIHELION ADVANCE CALCULATION (Generic Implementation)
//
// Calculates the "missing advance" of perihelion by comparing:
// - Earth-frame perihelion advance (o.mercuryPerihelion, etc.)
// - Ecliptic-frame perihelion advance (o.mercuryPerihelionEcliptic, etc.)
//
// The difference reveals the portion of observed precession that cannot
// be explained by the model's ecliptic-frame calculations.
//
// Key dates:
// - JD 2415191.5 = ~January 1, 1900
// - JD 2451716.5 = June 21, 2000 (model start)
// - JD 2488069.5 = ~January 1, 2100
//
// ================================================================

const JD_1800 = 2378496.5;  // ~January 1, 1800
const JD_1900 = 2415191.5;  // ~January 1, 1900
const JD_2000 = 2451716.5;  // June 21, 2000 (model start)
const JD_2100 = 2488069.5;  // ~January 1, 2100

// Cache for perihelion values by Julian Day (calculated once on demand per JD)
const perihelionCache = {};

/**
 * Fetch perihelion values at a specific Julian Day for all planets.
 * Uses save/jump/restore pattern like generatePlanetReport.
 * Results are cached by JD since values at a specific date never change.
 *
 * @param {number} jd - Julian Day to fetch values for
 * @returns {Object} Object with planet names as keys, each containing {earth, ecliptic} values
 */
function getPerihelionValuesAtDate(jd) {
  // Return cached values if available
  if (perihelionCache[jd]) return perihelionCache[jd];

  // Save current state
  const savedState = {
    run: o.Run,
    julianDay: o.julianDay,
    time: o.Time,
    pos: o.pos
  };
  o.Run = false;

  // Jump to requested Julian Day
  jumpToJulianDay(jd);
  forceSceneUpdate();

  // Read values for all planets
  perihelionCache[jd] = {
    mercury: { earth: o.mercuryPerihelion, ecliptic: o.mercuryPerihelionEcliptic },
    venus:   { earth: o.venusPerihelion,   ecliptic: o.venusPerihelionEcliptic },
    mars:    { earth: o.marsPerihelion,    ecliptic: o.marsPerihelionEcliptic },
    jupiter: { earth: o.jupiterPerihelion, ecliptic: o.jupiterPerihelionEcliptic },
    saturn:  { earth: o.saturnPerihelion,  ecliptic: o.saturnPerihelionEcliptic },
    uranus:  { earth: o.uranusPerihelion,  ecliptic: o.uranusPerihelionEcliptic },
    neptune: { earth: o.neptunePerihelion, ecliptic: o.neptunePerihelionEcliptic },
    pluto:   { earth: o.plutoPerihelion,   ecliptic: o.plutoPerihelionEcliptic },
    halleys: { earth: o.halleysPerihelion, ecliptic: o.halleysPerihelionEcliptic },
    eros:    { earth: o.erosPerihelion,    ecliptic: o.erosPerihelionEcliptic }
  };

  // Restore state
  o.Run = savedState.run;
  jumpToJulianDay(savedState.julianDay);
  o.Time = savedState.time;
  o.pos = savedState.pos;
  forceSceneUpdate();

  return perihelionCache[jd];
}

// Wrapper functions for backwards compatibility
function getPerihelion1900Values() { return getPerihelionValuesAtDate(JD_1900); }
function getPerihelion2000Values() { return getPerihelionValuesAtDate(JD_2000); }
function getPerihelion2100Values() { return getPerihelionValuesAtDate(JD_2100); }

/**
 * Calculate the "missing advance" of perihelion for a planet between two dates.
 * Compares Earth-frame advance vs Ecliptic-frame advance.
 *
 * Missing advance = (Earth-frame advance) - (Ecliptic-frame advance)
 *
 * @param {string} planetName - Planet key (mercury, venus, mars, etc.)
 * @param {number} jdStart - Starting Julian Day
 * @param {number} jdEnd - Ending Julian Day
 * @returns {number} Missing advance in arcseconds
 */
function calculateMissingPerihelionAdvanceBetween(planetName, jdStart, jdEnd) {
  const valStart = getPerihelionValuesAtDate(jdStart)[planetName];
  const valEnd = getPerihelionValuesAtDate(jdEnd)[planetName];

  if (!valStart || !valEnd) return 0;

  // Calculate advances in degrees
  const advanceEarthDeg = valEnd.earth - valStart.earth;
  const advanceEclipticDeg = valEnd.ecliptic - valStart.ecliptic;

  // Convert to arcseconds: degrees / 360 * 1296000
  const advanceEarthArcsec = advanceEarthDeg / 360 * 1296000;
  const advanceEclipticArcsec = advanceEclipticDeg / 360 * 1296000;

  // Missing advance = Earth-frame advance - Ecliptic-frame advance
  return advanceEarthArcsec - advanceEclipticArcsec;
}

/**
 * Calculate the "missing advance" of perihelion for a planet (1900 to 2000).
 * Wrapper for backwards compatibility.
 *
 * @param {string} planetName - Planet key (mercury, venus, mars, etc.)
 * @returns {number} Missing advance in arcseconds
 */
function calculateMissingPerihelionAdvance(planetName) {
  return calculateMissingPerihelionAdvanceBetween(planetName, JD_1900, JD_2000);
}

/**
 * Calculate the predicted "missing advance" of perihelion for Mercury (2000 to 2100).
 *
 * @returns {number} Predicted missing advance in arcseconds
 */
function calculatePredictedMissingAdvance() {
  return calculateMissingPerihelionAdvanceBetween('mercury', JD_2000, JD_2100);
}

/**
 * Calculate the "missing advance" of perihelion for Mercury during Einstein's century (1800 to 1900).
 *
 * @returns {number} Missing advance in arcseconds
 */
function calculateEinsteinCenturyMissingAdvance() {
  return calculateMissingPerihelionAdvanceBetween('mercury', JD_1800, JD_1900);
}

/**
 * Calculate the perihelion precession as seen from Earth for a planet.
 * This is the Earth-frame advance from 1900 to 2000.
 *
 * @param {string} planetName - Planet key (mercury, venus, mars, etc.)
 * @returns {number} Earth-frame precession in arcseconds
 */
function calculateEarthFramePrecession(planetName) {
  const val1900 = getPerihelion1900Values()[planetName];
  const val2000 = getPerihelion2000Values()[planetName];

  if (!val1900 || !val2000) return 0;

  // Calculate advance in degrees (2000 - 1900)
  const advanceEarthDeg = val2000.earth - val1900.earth;

  // Convert to arcseconds: degrees / 360 * 1296000
  return advanceEarthDeg / 360 * 1296000;
}

function updatePerihelion() {
  // ═══════════════════════════════════════════════════════════════════════════
  // EARTH-FRAME (Equatorial RA)
  // What an observer on Earth measures in Right Ascension coordinates
  // Includes Earth's axial tilt, precession cycles, and equatorial transformation
  // Shows fluctuations due to Earth's reference frame - averages to Ecliptic value
  // ═══════════════════════════════════════════════════════════════════════════
  o["mercuryPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, mercuryPerihelionFromEarth);
  o["venusPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, venusPerihelionFromEarth) % 360;
  o["earthPerihelion"] = (earthPerihelionFromEarth.ra * 180 / Math.PI + 360) % 360;
  o["marsPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, marsPerihelionFromEarth);
  o["jupiterPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, jupiterPerihelionFromEarth);
  o["saturnPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, saturnPerihelionFromEarth);
  o["uranusPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, uranusPerihelionFromEarth);
  o["neptunePerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, neptunePerihelionFromEarth);
  o["plutoPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, plutoPerihelionFromEarth);
  o["halleysPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, halleysPerihelionFromEarth);
  o["erosPerihelion"] = apparentRaFromPdA(earthPerihelionFromEarth, erosPerihelionFromEarth);

  // ═══════════════════════════════════════════════════════════════════════════
  // ECLIPTIC-FRAME (J2000 Ecliptic Coordinates)
  // Reads directly from precession layer rotation - the "true" heliocentric value
  // Stable precession rate, unaffected by Earth's reference frame
  // ═══════════════════════════════════════════════════════════════════════════
  o["mercuryPerihelionEcliptic"] = perihelionLongitudeEcliptic(mercuryPerihelionDurationEcliptic1, mercuryLongitudePerihelion);
  o["venusPerihelionEcliptic"] = perihelionLongitudeEcliptic(venusPerihelionDurationEcliptic1, venusLongitudePerihelion);
  o["marsPerihelionEcliptic"] = perihelionLongitudeEcliptic(marsPerihelionDurationEcliptic1, marsLongitudePerihelion);
  o["jupiterPerihelionEcliptic"] = perihelionLongitudeEcliptic(jupiterPerihelionDurationEcliptic1, jupiterLongitudePerihelion);
  o["saturnPerihelionEcliptic"] = perihelionLongitudeEcliptic(saturnPerihelionDurationEcliptic1, saturnLongitudePerihelion);
  o["uranusPerihelionEcliptic"] = perihelionLongitudeEcliptic(uranusPerihelionDurationEcliptic1, uranusLongitudePerihelion);
  o["neptunePerihelionEcliptic"] = perihelionLongitudeEcliptic(neptunePerihelionDurationEcliptic1, neptuneLongitudePerihelion);
  o["plutoPerihelionEcliptic"] = perihelionLongitudeEcliptic(plutoPerihelionDurationEcliptic1, plutoLongitudePerihelion);
  o["halleysPerihelionEcliptic"] = perihelionLongitudeEcliptic(halleysPerihelionDurationEcliptic1, halleysLongitudePerihelion);
  o["erosPerihelionEcliptic"] = perihelionLongitudeEcliptic(erosPerihelionDurationEcliptic1, erosLongitudePerihelion);
};

// ================================================================
// DYNAMIC ASCENDING NODE CALCULATION
// ================================================================
//
// The ascending node longitude shifts when Earth's obliquity changes.
// This is a RATE-BASED calculation that integrates the effect over time,
// properly handling:
//   1. Obliquity direction changes (when obliquity starts increasing/decreasing)
//   2. Inclination crossovers (when Earth's inclination crosses a planet's)
//
// The effect depends on:
//   - The RATE of obliquity change (dε/dt), not total deviation from mean
//   - The relative inclination between Earth and the planet at each moment
//
// Earth inclination range: ~0.93° to ~2.06° (mean 1.495°, amplitude 0.564°)
// Planets affected by inclination crossover: Jupiter (1.30°), Mars (1.85°)
// ================================================================

/**
 * Compute the integrated obliquity change from the mean obliquity point,
 * accounting for direction changes in the obliquity cycle.
 *
 * Obliquity formula: ε = mean - A*cos(phase3) + A*cos(phase8)
 * where phase3 = 2π*t/cycle3, phase8 = 2π*t/cycle8
 *
 * The integral of the RATE of change gives us the accumulated effect,
 * but we need to account for sign changes based on inclination relationship.
 *
 * @param {number} currentYear - Current year
 * @returns {object} { obliquityIntegral3, obliquityIntegral8 } - Integrated components
 */
function computeObliquityIntegrals(currentYear) {
  const t = currentYear - balancedYear;
  const cycle3 = holisticyearLength / 3;
  const cycle8 = holisticyearLength / 8;

  const phase3 = (t / cycle3) * 2 * Math.PI;
  const phase8 = (t / cycle8) * 2 * Math.PI;

  // The obliquity is: mean - A*cos(phase3) + A*cos(phase8)
  // The integral of cos from 0 to phase is sin(phase)
  // So the "accumulated obliquity change" from balanced year is:
  //   -A*sin(phase3) + A*sin(phase8)  (but we need the actual deviation)
  //
  // Actually, for the ascending node effect, what matters is the
  // obliquity VALUE relative to the mean, not the integral of rate.
  // The formula dΩ = (dΩ/dε) * dε integrates to Ω = (dΩ/dε) * (ε - ε_mean)
  //
  // So we return the obliquity deviation from mean, split by component
  // for potential future use in handling direction changes per component.

  return {
    component3: -earthInvPlaneInclinationAmplitude * Math.cos(phase3),  // Deviation from mean due to cycle3
    component8: earthInvPlaneInclinationAmplitude * Math.cos(phase8),   // Deviation from mean due to cycle8
    sin3: Math.sin(phase3),  // For determining direction of cycle3 contribution
    sin8: Math.sin(phase8)   // For determining direction of cycle8 contribution
  };
}

/**
 * Compute Earth's inclination at a specific year.
 * Inclination formula: i = mean - A*cos(phase3)
 *
 * @param {number} year - Year to compute for
 * @returns {number} Earth inclination in degrees
 */
function getEarthInclinationAtYear(year) {
  const t = year - balancedYear;
  const cycle3 = holisticyearLength / 3;
  const phase3 = (t / cycle3) * 2 * Math.PI;
  return earthInvPlaneInclinationMean - earthInvPlaneInclinationAmplitude * Math.cos(phase3);
}

/**
 * Compute Earth's obliquity at a specific year.
 *
 * @param {number} year - Year to compute for
 * @returns {number} Earth obliquity in degrees
 */
function getObliquityAtYear(year) {
  const t = year - balancedYear;
  const cycle3 = holisticyearLength / 3;
  const cycle8 = holisticyearLength / 8;
  const phase3 = (t / cycle3) * 2 * Math.PI;
  const phase8 = (t / cycle8) * 2 * Math.PI;
  return earthtiltMean - earthInvPlaneInclinationAmplitude * Math.cos(phase3) + earthInvPlaneInclinationAmplitude * Math.cos(phase8);
}

/**
 * Find the year when Earth's inclination equals a target value.
 * Solves: earthInvPlaneInclinationMean - A*cos(phase3) = targetInclination
 *
 * @param {number} targetInclination - Target inclination in degrees
 * @param {number} startYear - Start of search range
 * @param {number} endYear - End of search range
 * @param {boolean} findFirst - If true, find first crossing; if false, find last
 * @returns {number|null} Year of crossing, or null if not found
 */
function findInclinationCrossingYear(targetInclination, startYear, endYear, findFirst = true) {
  // Check if target is within Earth's inclination range
  const minIncl = earthInvPlaneInclinationMean - earthInvPlaneInclinationAmplitude;
  const maxIncl = earthInvPlaneInclinationMean + earthInvPlaneInclinationAmplitude;

  if (targetInclination < minIncl || targetInclination > maxIncl) {
    return null; // Target outside Earth's range
  }

  // Binary search for crossing
  const steps = 1000;
  const stepSize = (endYear - startYear) / steps;

  let prevIncl = getEarthInclinationAtYear(startYear);
  let crossings = [];

  for (let i = 1; i <= steps; i++) {
    const year = startYear + i * stepSize;
    const incl = getEarthInclinationAtYear(year);

    // Check if we crossed the target
    if ((prevIncl < targetInclination && incl >= targetInclination) ||
        (prevIncl > targetInclination && incl <= targetInclination)) {
      // Refine with interpolation
      const fraction = (targetInclination - prevIncl) / (incl - prevIncl);
      crossings.push(year - stepSize + fraction * stepSize);
    }
    prevIncl = incl;
  }

  if (crossings.length === 0) return null;
  return findFirst ? crossings[0] : crossings[crossings.length - 1];
}

/**
 * Find ALL years when Earth's inclination equals a target value within a range.
 * Used for proper segment handling in ascending node calculation.
 *
 * @param {number} targetInclination - Target inclination in degrees
 * @param {number} startYear - Start of search range
 * @param {number} endYear - End of search range
 * @returns {number[]} Array of years where crossings occur
 */
function findAllInclinationCrossings(targetInclination, startYear, endYear) {
  // Check if target is within Earth's inclination range
  const minIncl = earthInvPlaneInclinationMean - earthInvPlaneInclinationAmplitude;
  const maxIncl = earthInvPlaneInclinationMean + earthInvPlaneInclinationAmplitude;

  if (targetInclination < minIncl || targetInclination > maxIncl) {
    return []; // Target outside Earth's range
  }

  // Use enough steps to catch all crossings
  // There are 2 crossings per holisticyearLength/3 cycle, so ensure we have enough resolution
  const yearSpan = Math.abs(endYear - startYear);
  const cycleLength = holisticyearLength / 3;  // Inclination precession cycle
  const expectedCrossings = Math.ceil(yearSpan / cycleLength) * 2 + 4;
  const steps = Math.max(1000, expectedCrossings * 50);  // At least 50 samples per expected crossing
  const stepSize = (endYear - startYear) / steps;

  let prevIncl = getEarthInclinationAtYear(startYear);
  let crossings = [];

  for (let i = 1; i <= steps; i++) {
    const year = startYear + i * stepSize;
    const incl = getEarthInclinationAtYear(year);

    // Check if we crossed the target
    if ((prevIncl < targetInclination && incl >= targetInclination) ||
        (prevIncl > targetInclination && incl <= targetInclination)) {
      // Refine with interpolation
      const fraction = (targetInclination - prevIncl) / (incl - prevIncl);
      crossings.push(year - stepSize + fraction * stepSize);
    }
    prevIncl = incl;
  }

  return crossings;
}

/**
 * Calculate the dynamic ascending node longitude using a RATE-BASED approach.
 *
 * This properly handles:
 *   1. Obliquity direction changes (effect reverses when obliquity changes direction)
 *   2. Inclination crossovers (effect reverses when Earth incl crosses planet incl)
 *
 * The effect on ascending node depends on:
 *   - dΩ/dε = -sin(Ω) / tan(i)  (base perturbation rate)
 *   - Sign depends on whether Earth incl > or < planet incl
 *   - Effect accumulates based on obliquity CHANGE, respecting direction reversals
 *
 * @param {number} orbitTilta - Encodes sin(Ω)*i in degrees
 * @param {number} orbitTiltb - Encodes cos(Ω)*i in degrees
 * @param {number} currentObliquity - Current Earth obliquity (degrees)
 * @param {number} earthInclination - Current Earth ecliptic inclination (degrees)
 * @param {number} currentYear - Current year (needed for rate-based calculation)
 * @returns {number} Dynamic ascending node longitude (degrees, 0-360)
 */
function calculateDynamicAscendingNodeFromTilts(orbitTilta, orbitTiltb, currentObliquity, earthInclination, currentYear) {
  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  // Extract the static ascending node and inclination from tilts
  const staticOmegaDeg = Math.atan2(orbitTilta, orbitTiltb) * RAD2DEG;
  const staticOmega = ((staticOmegaDeg % 360) + 360) % 360;
  const planetInclination = Math.sqrt(orbitTilta * orbitTilta + orbitTiltb * orbitTiltb);

  // If inclination is essentially zero, ascending node is undefined
  if (planetInclination < 1e-6) {
    return staticOmega;
  }

  const i = planetInclination * DEG2RAD;
  const OmegaRad = staticOmega * DEG2RAD;

  const tanI = Math.tan(i);
  if (Math.abs(tanI) < 1e-10) {
    return staticOmega;
  }

  // Base perturbation rate: dΩ/dε = -sin(Ω) / tan(i)
  const sinOmega = Math.sin(OmegaRad);
  const baseDOmegaDeps = -sinOmega / tanI;

  // ================================================================
  // RATE-BASED INTEGRATION WITH SEGMENT HANDLING
  // ================================================================
  //
  // We integrate the ascending node change from the "balanced year" (where
  // obliquity and inclination are at their mean values) to the current year.
  //
  // IMPORTANT: The staticOmega values are calibrated for EPOCH year 2000.
  // To use balanced year as the reference, we need to:
  //   1. Calculate the effect from balanced year to epoch (2000)
  //   2. Subtract that from staticOmega to get the "balanced year baseline"
  //   3. Then add the effect from balanced year to current year
  //
  // This simplifies to: just calculate the effect from EPOCH to currentYear,
  // since the balanced year portions cancel out:
  //   result = staticOmega - effect(balanced→epoch) + effect(balanced→current)
  //          = staticOmega + effect(epoch→current)
  //
  // But we WANT to use balanced year as reference for proper cycle handling.
  // So we compute effect(balanced→current) - effect(balanced→epoch).
  //
  // The integration must account for:
  // 1. Obliquity direction changes (extrema in the obliquity cycle)
  // 2. Inclination crossovers (when Earth incl = planet incl)
  //
  // At each segment boundary, the direction of the effect may reverse.
  // ================================================================

  const EPOCH_YEAR = 2000; // Year when staticOmega values are calibrated

  // Helper function to integrate effect between two years
  const integrateEffect = (fromYear, toYear) => {
    if (Math.abs(toYear - fromYear) < 0.1) return 0;

    const yearMin = Math.min(fromYear, toYear);
    const yearMax = Math.max(fromYear, toYear);
    const dir = toYear >= fromYear ? 1 : -1;

    // Collect critical points: obliquity extrema and inclination crossings
    let criticalYears = [yearMin, yearMax];

    // Sample to find obliquity direction changes
    const sampleStep = Math.min(1000, (yearMax - yearMin) / 100);
    if (sampleStep > 0) {
      let prevObl = getObliquityAtYear(yearMin);
      let prevDir = 0;

      for (let y = yearMin + sampleStep; y <= yearMax; y += sampleStep) {
        const obl = getObliquityAtYear(y);
        const curDir = obl > prevObl ? 1 : (obl < prevObl ? -1 : 0);

        if (prevDir !== 0 && curDir !== 0 && prevDir !== curDir) {
          // Direction changed - refine to find extremum
          let lo = y - sampleStep;
          let hi = y;
          for (let iter = 0; iter < 20; iter++) {
            const mid = (lo + hi) / 2;
            const oblLo = getObliquityAtYear(lo);
            const oblMid = getObliquityAtYear(mid);
            const oblHi = getObliquityAtYear(hi);

            if ((oblMid > oblLo && oblMid > oblHi) || (oblMid < oblLo && oblMid < oblHi)) {
              criticalYears.push(mid);
              break;
            } else if ((oblMid - oblLo) * prevDir > 0) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
        }

        if (curDir !== 0) prevDir = curDir;
        prevObl = obl;
      }
    }

    // Find ALL inclination crossings (only if planet is within Earth's inclination range)
    // This is critical for long time spans where there may be many crossings
    const minEarthIncl = earthInvPlaneInclinationMean - earthInvPlaneInclinationAmplitude;
    const maxEarthIncl = earthInvPlaneInclinationMean + earthInvPlaneInclinationAmplitude;

    if (planetInclination >= minEarthIncl && planetInclination <= maxEarthIncl) {
      const allCrossings = findAllInclinationCrossings(planetInclination, yearMin, yearMax);
      criticalYears.push(...allCrossings);
    }

    // Sort critical years and remove duplicates
    criticalYears = [...new Set(criticalYears)].sort((a, b) => a - b);

    // Integrate over segments
    let effect = 0;
    for (let idx = 0; idx < criticalYears.length - 1; idx++) {
      const segStart = criticalYears[idx];
      const segEnd = criticalYears[idx + 1];

      const oblStart = getObliquityAtYear(segStart);
      const oblEnd = getObliquityAtYear(segEnd);
      const deltaObl = (oblEnd - oblStart) * DEG2RAD;

      const midYear = (segStart + segEnd) / 2;
      const earthInclAtMid = getEarthInclinationAtYear(midYear);
      const inclDirection = earthInclAtMid > planetInclination ? 1 : -1;

      effect += baseDOmegaDeps * inclDirection * deltaObl * RAD2DEG;
    }

    return effect * dir;
  };

  // Calculate the net effect: from epoch (2000) to current year
  // This properly handles all obliquity direction changes and inclination crossovers
  const effectFromEpoch = integrateEffect(EPOCH_YEAR, currentYear);

  // Apply accumulated effect to the static (epoch) value
  let newOmega = staticOmega + effectFromEpoch;

  // Normalize to 0-360
  newOmega = ((newOmega % 360) + 360) % 360;

  return newOmega;
}

/**
 * Legacy function - kept for reference but no longer used.
 * Use calculateDynamicAscendingNodeFromTilts instead.
 */
function calculateDynamicAscendingNode(staticOmega, staticInclination, currentObliquity, referenceObliquity = earthtiltMean) {
  // Convert static values to tilt format
  const DEG2RAD = Math.PI / 180;
  const OmegaRad = staticOmega * DEG2RAD;
  // orbitTilta = sin(Ω) * i, orbitTiltb = cos(Ω) * i
  const orbitTilta = Math.sin(OmegaRad) * staticInclination;
  const orbitTiltb = Math.cos(OmegaRad) * staticInclination;

  return calculateDynamicAscendingNodeFromTilts(orbitTilta, orbitTiltb, currentObliquity, referenceObliquity);
}


/**
 * Update all planet ascending nodes based on current obliquity.
 * Uses the ACTUAL orbitTilta and orbitTiltb values from the planet data objects,
 * which encode both inclination AND the direction of tilt.
 * Also calculates the Argument of Periapsis for each planet.
 * This function should be called each frame before updateHierarchyLiveData().
 *
 * The calculation uses a RATE-BASED approach that properly handles:
 *   1. Obliquity direction changes (effect reverses when obliquity changes direction)
 *   2. Inclination crossovers (effect reverses when Earth incl crosses planet incl)
 */
// Debug flag for ascending node logging - set to true to enable console output
let _debugAscendingNodeLogEnabled = false;
let _debugAscendingNodeLastLog = 0;
const _debugAscendingNodeInterval = 1000; // Log at most every 1 second

// Expose debug toggle globally for console access
// Usage in browser console: window.enableAscNodeDebug(true) or window.enableAscNodeDebug(false)
window.enableAscNodeDebug = (enabled) => {
  _debugAscendingNodeLogEnabled = enabled;
  o.debugAscendingNode = enabled;
  console.log(`🔍 Ascending Node debugging ${enabled ? 'ENABLED' : 'DISABLED'}`);
  if (enabled) {
    console.log('   Logs will appear every second showing:');
    console.log('   - Current year and obliquity');
    console.log('   - Static orbitTilt values');
    console.log('   - Calculated dynamic ascending node');
    console.log('   - Visual rotation values applied');
  }
};

function updateAscendingNodes() {
  const currentObliquity = o.obliquityEarth;
  const earthInclination = o.earthInvPlaneInclinationDynamic;
  const currentYear = o.currentYear;

  // Mercury - use actual tilt values from planet data
  o.mercuryAscendingNode = calculateDynamicAscendingNodeFromTilts(
    mercuryRealPerihelionAtSun.orbitTilta, mercuryRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.mercuryArgumentOfPeriapsis = ((o.mercuryPerihelion - o.mercuryAscendingNode) % 360 + 360) % 360;

  // DEBUG: Log ascending node calculation details (simplified)
  const now = Date.now();
  if (_debugAscendingNodeLogEnabled && (now - _debugAscendingNodeLastLog > _debugAscendingNodeInterval)) {
    _debugAscendingNodeLastLog = now;
    console.log(`🔍 Ascending Node: Year ${currentYear.toFixed(2)}, Mercury Ω = ${o.mercuryAscendingNode.toFixed(2)}° (static: ${mercuryAscendingNode}°, diff: ${(o.mercuryAscendingNode - mercuryAscendingNode).toFixed(2)}°)`);
    console.log(`🌍 DEBUG TEST v2 - code updated check`);

    // Earth Invariable Plane debug
    try {
      const sunLongDeg = (sun && sun.ra !== undefined) ? sun.ra * 180 / Math.PI : 0;
      const earthHelioLong = (sunLongDeg + 180 + 360) % 360;
      const yearsSinceJ2000 = currentYear - startmodelyearwithCorrection;
      const earthPrecRate = 360 / earthPerihelionICRFYears;
      const earthAscNodeDyn = (earthAscendingNodeInvPlaneVerified + earthPrecRate * yearsSinceJ2000 + 360) % 360;
      const angleFromAscNode = (earthHelioLong - earthAscNodeDyn + 360) % 360;
      console.log(`🌍 EARTH INV PLANE: sun.ra=${sunLongDeg.toFixed(2)}°, earthHelioLong=${earthHelioLong.toFixed(2)}°`);
      console.log(`   ascNodeJ2000=${earthAscendingNodeInvPlaneVerified}°, ascNodeDyn=${earthAscNodeDyn.toFixed(4)}°, angleFromNode=${angleFromAscNode.toFixed(2)}°`);
      console.log(`   o.earthAscendingNodeInvPlane=${o.earthAscendingNodeInvPlane?.toFixed(4)}°, height=${o.earthHeightAboveInvPlane?.toFixed(6)} AU`);
    } catch (e) {
      console.log(`🌍 EARTH INV PLANE DEBUG ERROR: ${e.message}`);
    }
  }

  // Venus
  o.venusAscendingNode = calculateDynamicAscendingNodeFromTilts(
    venusRealPerihelionAtSun.orbitTilta, venusRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.venusArgumentOfPeriapsis = ((o.venusPerihelion - o.venusAscendingNode) % 360 + 360) % 360;

  // Mars - NOTE: Mars (1.85°) is within Earth's inclination range and will experience crossover
  o.marsAscendingNode = calculateDynamicAscendingNodeFromTilts(
    marsRealPerihelionAtSun.orbitTilta, marsRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.marsArgumentOfPeriapsis = ((o.marsPerihelion - o.marsAscendingNode) % 360 + 360) % 360;

  // Jupiter - NOTE: Jupiter (1.30°) is within Earth's inclination range and will experience crossover
  o.jupiterAscendingNode = calculateDynamicAscendingNodeFromTilts(
    jupiterRealPerihelionAtSun.orbitTilta, jupiterRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.jupiterArgumentOfPeriapsis = ((o.jupiterPerihelion - o.jupiterAscendingNode) % 360 + 360) % 360;

  // Saturn
  o.saturnAscendingNode = calculateDynamicAscendingNodeFromTilts(
    saturnRealPerihelionAtSun.orbitTilta, saturnRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.saturnArgumentOfPeriapsis = ((o.saturnPerihelion - o.saturnAscendingNode) % 360 + 360) % 360;

  // Uranus
  o.uranusAscendingNode = calculateDynamicAscendingNodeFromTilts(
    uranusRealPerihelionAtSun.orbitTilta, uranusRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.uranusArgumentOfPeriapsis = ((o.uranusPerihelion - o.uranusAscendingNode) % 360 + 360) % 360;

  // Neptune
  o.neptuneAscendingNode = calculateDynamicAscendingNodeFromTilts(
    neptuneRealPerihelionAtSun.orbitTilta, neptuneRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.neptuneArgumentOfPeriapsis = ((o.neptunePerihelion - o.neptuneAscendingNode) % 360 + 360) % 360;

  // Pluto
  o.plutoAscendingNode = calculateDynamicAscendingNodeFromTilts(
    plutoRealPerihelionAtSun.orbitTilta, plutoRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.plutoArgumentOfPeriapsis = ((o.plutoPerihelion - o.plutoAscendingNode) % 360 + 360) % 360;

  // Halley's Comet
  o.halleysAscendingNode = calculateDynamicAscendingNodeFromTilts(
    halleysRealPerihelionAtSun.orbitTilta, halleysRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.halleysArgumentOfPeriapsis = ((o.halleysPerihelion - o.halleysAscendingNode) % 360 + 360) % 360;

  // Eros
  o.erosAscendingNode = calculateDynamicAscendingNodeFromTilts(
    erosRealPerihelionAtSun.orbitTilta, erosRealPerihelionAtSun.orbitTiltb, currentObliquity, earthInclination, currentYear
  );
  o.erosArgumentOfPeriapsis = ((o.erosPerihelion - o.erosAscendingNode) % 360 + 360) % 360;

  // Update the visual orbital plane markers to reflect the dynamic ascending nodes
  updateOrbitalPlaneRotations();
}

/**
 * Update the orbital plane container rotations based on dynamic ascending node values.
 * This ensures the visual markers (orbital plane, node markers) reflect the current
 * ascending node rather than the static epoch 2000 values.
 *
 * The formula to convert ascending node Ω and inclination i to tilt values:
 *   orbitTilta = cos((-90-Ω) * π/180) * -inclination
 *   orbitTiltb = sin((-90-Ω) * π/180) * -inclination
 *
 * The containerObj.rotation uses:
 *   rotation.x = orbitTilta * π/180
 *   rotation.z = orbitTiltb * π/180
 */
function updateOrbitalPlaneRotations() {
  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  // Helper to update a planet's orbital plane rotation
  const updatePlaneRotation = (planetData, ascendingNode, inclination, planetName) => {
    if (!planetData.containerObj) {
      if (_debugAscendingNodeLogEnabled && planetName === 'Mercury') {
        console.warn(`⚠️ DEBUG: ${planetName} containerObj is missing!`);
      }
      return;
    }

    // Calculate new tilt values from dynamic ascending node
    const angle = (-90 - ascendingNode) * DEG2RAD;
    const newTilta = Math.cos(angle) * -inclination;
    const newTiltb = Math.sin(angle) * -inclination;

    // DEBUG: Log what we're setting
    if (_debugAscendingNodeLogEnabled && planetName === 'Mercury') {
      const now = Date.now();
      if (now - _debugAscendingNodeLastLog < _debugAscendingNodeInterval + 100) {
        const oldX = planetData.containerObj.rotation.x;
        const newX = newTilta * DEG2RAD;
        console.log(`🔧 Mercury rotation: Ω=${ascendingNode.toFixed(2)}°, old.x=${oldX.toFixed(6)}, new.x=${newX.toFixed(6)}, diff=${(newX-oldX).toFixed(8)}`);
      }
    }

    // Update container rotation
    planetData.containerObj.rotation.x = newTilta * DEG2RAD;
    planetData.containerObj.rotation.z = newTiltb * DEG2RAD;
  };

  // Update each planet's orbital plane using dynamic ecliptic inclination
  updatePlaneRotation(mercuryRealPerihelionAtSun, o.mercuryAscendingNode, o.mercuryEclipticInclinationDynamic, 'Mercury');
  updatePlaneRotation(venusRealPerihelionAtSun, o.venusAscendingNode, o.venusEclipticInclinationDynamic, 'Venus');
  updatePlaneRotation(marsRealPerihelionAtSun, o.marsAscendingNode, o.marsEclipticInclinationDynamic, 'Mars');
  updatePlaneRotation(jupiterRealPerihelionAtSun, o.jupiterAscendingNode, o.jupiterEclipticInclinationDynamic, 'Jupiter');
  updatePlaneRotation(saturnRealPerihelionAtSun, o.saturnAscendingNode, o.saturnEclipticInclinationDynamic, 'Saturn');
  updatePlaneRotation(uranusRealPerihelionAtSun, o.uranusAscendingNode, o.uranusEclipticInclinationDynamic, 'Uranus');
  updatePlaneRotation(neptuneRealPerihelionAtSun, o.neptuneAscendingNode, o.neptuneEclipticInclinationDynamic, 'Neptune');
  updatePlaneRotation(plutoRealPerihelionAtSun, o.plutoAscendingNode, o.plutoEclipticInclinationDynamic, 'Pluto');
  updatePlaneRotation(halleysRealPerihelionAtSun, o.halleysAscendingNode, o.halleysEclipticInclinationDynamic, 'Halleys');
  updatePlaneRotation(erosRealPerihelionAtSun, o.erosAscendingNode, o.erosEclipticInclinationDynamic, 'Eros');
}

/**
 * Calculate Mean Anomaly and True Anomaly for all planets.
 *
 * Mean Anomaly (M): Angle measured at P (orbit center) from perihelion to planet
 * True Anomaly (ν): Angle measured at Sun (focus) from perihelion to planet
 *
 * This function calculates anomalies based on actual 3D positions in the model,
 * not time-based calculations. This ensures the displayed values match what
 * is visually shown in the simulation.
 *
 * Called each frame after updateAscendingNodes() and before updateHierarchyLiveData().
 */
function updatePlanetAnomalies() {
  // Get Sun position (common for all planets) - using pooled vector
  sun.pivotObj.getWorldPosition(_anomalySunPos);

  // Planet configuration: [planetObj, fixedPerihelionAtSun, propertyPrefix, eccentricity]
  const planets = [
    { planet: mercury, fixedPerihelion: mercuryFixedPerihelionAtSun, key: 'mercury', e: mercuryOrbitalEccentricity },
    { planet: venus, fixedPerihelion: venusFixedPerihelionAtSun, key: 'venus', e: venusOrbitalEccentricity },
    { planet: mars, fixedPerihelion: marsFixedPerihelionAtSun, key: 'mars', e: marsOrbitalEccentricity },
    { planet: jupiter, fixedPerihelion: jupiterFixedPerihelionAtSun, key: 'jupiter', e: jupiterOrbitalEccentricity },
    { planet: saturn, fixedPerihelion: saturnFixedPerihelionAtSun, key: 'saturn', e: saturnOrbitalEccentricity },
    { planet: uranus, fixedPerihelion: uranusFixedPerihelionAtSun, key: 'uranus', e: uranusOrbitalEccentricity },
    { planet: neptune, fixedPerihelion: neptuneFixedPerihelionAtSun, key: 'neptune', e: neptuneOrbitalEccentricity },
    { planet: pluto, fixedPerihelion: plutoFixedPerihelionAtSun, key: 'pluto', e: plutoOrbitalEccentricity },
    { planet: halleys, fixedPerihelion: halleysFixedPerihelionAtSun, key: 'halleys', e: halleysOrbitalEccentricity },
    { planet: eros, fixedPerihelion: erosFixedPerihelionAtSun, key: 'eros', e: erosOrbitalEccentricity }
  ];

  for (const { planet, fixedPerihelion, key, e } of planets) {
    // Skip if objects don't exist
    if (!planet?.pivotObj || !fixedPerihelion?.pivotObj || !fixedPerihelion?.planetObj) {
      continue;
    }

    // Get positions (using pooled vectors)
    fixedPerihelion.pivotObj.getWorldPosition(_anomalyPPos);           // P = orbit center
    planet.pivotObj.getWorldPosition(_anomalyPlanetPos);               // Planet position

    // Calculate direction vectors in XZ plane (ecliptic)
    // In an elliptical orbit:
    // - P (center) is at the geometric center of the ellipse
    // - Sun (focus) is between P and perihelion, at distance a*e from P
    // - Perihelion is in the direction from P toward Sun, beyond the Sun
    //
    // Layout: P -------- Sun ------- Perihelion
    //
    // So perihelion direction from both P and Sun is: P → Sun direction
    const periDirX = _anomalySunPos.x - _anomalyPPos.x;
    const periDirZ = _anomalySunPos.z - _anomalyPPos.z;

    // For both True Anomaly and Mean Anomaly, the perihelion reference is the same direction
    const periDirFromSunX = periDirX;
    const periDirFromSunZ = periDirZ;
    const periDirFromPX = periDirX;
    const periDirFromPZ = periDirZ;

    // Planet direction from Sun (for True Anomaly)
    const planetDirFromSunX = _anomalyPlanetPos.x - _anomalySunPos.x;
    const planetDirFromSunZ = _anomalyPlanetPos.z - _anomalySunPos.z;

    // Planet direction from P (for Mean Anomaly)
    const planetDirFromPX = _anomalyPlanetPos.x - _anomalyPPos.x;
    const planetDirFromPZ = _anomalyPlanetPos.z - _anomalyPPos.z;

    // Calculate angles using atan2 (negate Z for counter-clockwise measurement)
    const periAngleSun = Math.atan2(-periDirFromSunZ, periDirFromSunX);
    const planetAngleSun = Math.atan2(-planetDirFromSunZ, planetDirFromSunX);

    const periAngleP = Math.atan2(-periDirFromPZ, periDirFromPX);
    const planetAngleP = Math.atan2(-planetDirFromPZ, planetDirFromPX);

    // True Anomaly: angle at Sun from perihelion to planet
    let trueAnomalyRad = planetAngleSun - periAngleSun;

    // Mean Anomaly: angle at P from perihelion to planet
    let meanAnomalyRad = planetAngleP - periAngleP;

    // Normalize to 0 to 2*PI range
    trueAnomalyRad = ((trueAnomalyRad % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
    meanAnomalyRad = ((meanAnomalyRad % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);

    // Convert to degrees and store in o object
    o[key + 'TrueAnomaly'] = trueAnomalyRad * 180 / Math.PI;
    o[key + 'MeanAnomaly'] = meanAnomalyRad * 180 / Math.PI;

    // Calculate Eccentric Anomaly from Mean Anomaly using Newton-Raphson iteration
    o[key + 'EccentricAnomaly'] = OrbitalFormulas.eccentricAnomaly(o[key + 'MeanAnomaly'], e);
  }

  // Calculate Earth's anomalies
  // Earth is special: we derive position from the Sun's ecliptic longitude + 180°
  // sun.ra is in radians, represents Sun's position as seen from Earth
  if (sun && sun.ra !== undefined) {
    const sunLongDeg = sun.ra * 180 / Math.PI;
    const earthHelioLong = (sunLongDeg + 180 + 360) % 360;  // Earth's heliocentric longitude

    // Longitude of perihelion for Earth
    const earthLonPeri = o.earthPerihelion || ((earthPerihelionFromEarth.ra * 180 / Math.PI + 360) % 360);

    // True Anomaly = Heliocentric Longitude - Longitude of Perihelion
    let earthTrueAnom = (earthHelioLong - earthLonPeri + 360) % 360;
    o.earthTrueAnomaly = earthTrueAnom;

    // For Earth, the argument of periapsis equals the longitude of perihelion
    // (since Earth's ascending node on ecliptic is at 0° by definition)
    o.earthArgumentOfPeriapsis = earthLonPeri;

    // Get current eccentricity (dynamic)
    const earthE = o.eccentricityEarth || eccentricityMean;

    // Convert True Anomaly to Eccentric Anomaly using exact formula:
    // tan(E/2) = sqrt((1-e)/(1+e)) * tan(ν/2)
    const nuRad = earthTrueAnom * Math.PI / 180;
    const tanHalfNu = Math.tan(nuRad / 2);
    const tanHalfE = Math.sqrt((1 - earthE) / (1 + earthE)) * tanHalfNu;
    let earthEccAnom = 2 * Math.atan(tanHalfE) * 180 / Math.PI;
    earthEccAnom = ((earthEccAnom % 360) + 360) % 360;
    o.earthEccentricAnomaly = earthEccAnom;

    // Mean Anomaly from Eccentric Anomaly using Kepler's equation: M = E - e*sin(E)
    const E_rad = earthEccAnom * Math.PI / 180;
    let earthMeanAnom = (earthEccAnom - (earthE * Math.sin(E_rad) * 180 / Math.PI));
    earthMeanAnom = ((earthMeanAnom % 360) + 360) % 360;
    o.earthMeanAnomaly = earthMeanAnom;
  }
}

/**
 * Calculate each planet's height above/below the invariable plane.
 *
 * The invariable plane is the fundamental reference plane of the solar system,
 * perpendicular to the total angular momentum vector. Each planet crosses this
 * plane twice per orbit (at ascending and descending nodes).
 *
 * Height = sin(inclination_to_inv_plane) * sin(angle_from_ascending_node) * distance
 *
 * The ascending nodes on the invariable plane precess over time.
 * Precession rates use <planet>PerihelionICRFYears constants (earthPerihelionICRFYears for Earth).
 *
 * Called each frame after updatePlanetAnomalies().
 *
 * Reference: Souami & Souchay (2012), "The solar system's invariable plane"
 */
function updatePlanetInvariablePlaneHeights() {
  const DEG2RAD = Math.PI / 180;

  // Years since balancedYear - using balancedYear as epoch ensures perfect synchronization
  // over complete Holistic Year cycles (ascending nodes return to exact same values)
  // Calculate from JD directly using mean solar year length to avoid calendar-based drift
  const yearsSinceBalanced = (o.julianDay - balancedJD) / meansolaryearlengthinDays;

  // yearsFromBalancedToJ2000 is a pre-computed constant (defined near line 434)

  // Planet configuration for invariable plane calculations
  // Each entry includes: key, planetObj, inclToInvPlane, ascNodeAtJ2000 (Souami & Souchay), ascNodeJ2000Verified, precessionPeriodYears
  // Precession uses <planet>PerihelionICRFYears constants (earthPerihelionICRFYears for Earth)
  const planets = [
    { key: 'mercury', obj: mercury, getIncl: () => o.mercuryInvPlaneInclinationDynamic || mercuryInvPlaneInclinationJ2000, ascNodeJ2000: mercuryAscendingNodeInvPlaneSouamiSouchay, ascNodeJ2000Verified: mercuryAscendingNodeInvPlaneVerified, precessionYears: mercuryPerihelionICRFYears },
    { key: 'venus',   obj: venus,   getIncl: () => o.venusInvPlaneInclinationDynamic   || venusInvPlaneInclinationJ2000,   ascNodeJ2000: venusAscendingNodeInvPlaneSouamiSouchay,   ascNodeJ2000Verified: venusAscendingNodeInvPlaneVerified,   precessionYears: venusPerihelionICRFYears },
    { key: 'earth',   obj: null,    getIncl: () => o.earthInvPlaneInclinationDynamic   || earthInvPlaneInclinationJ2000,   ascNodeJ2000: earthAscendingNodeInvPlaneSouamiSouchay,   ascNodeJ2000Verified: earthAscendingNodeInvPlaneVerified,   precessionYears: earthPerihelionICRFYears },
    { key: 'mars',    obj: mars,    getIncl: () => o.marsInvPlaneInclinationDynamic    || marsInvPlaneInclinationJ2000,    ascNodeJ2000: marsAscendingNodeInvPlaneSouamiSouchay,    ascNodeJ2000Verified: marsAscendingNodeInvPlaneVerified,    precessionYears: marsPerihelionICRFYears },
    { key: 'jupiter', obj: jupiter, getIncl: () => o.jupiterInvPlaneInclinationDynamic || jupiterInvPlaneInclinationJ2000, ascNodeJ2000: jupiterAscendingNodeInvPlaneSouamiSouchay, ascNodeJ2000Verified: jupiterAscendingNodeInvPlaneVerified, precessionYears: jupiterPerihelionICRFYears },
    { key: 'saturn',  obj: saturn,  getIncl: () => o.saturnInvPlaneInclinationDynamic  || saturnInvPlaneInclinationJ2000,  ascNodeJ2000: saturnAscendingNodeInvPlaneSouamiSouchay,  ascNodeJ2000Verified: saturnAscendingNodeInvPlaneVerified,  precessionYears: saturnPerihelionICRFYears },
    { key: 'uranus',  obj: uranus,  getIncl: () => o.uranusInvPlaneInclinationDynamic  || uranusInvPlaneInclinationJ2000,  ascNodeJ2000: uranusAscendingNodeInvPlaneSouamiSouchay,  ascNodeJ2000Verified: uranusAscendingNodeInvPlaneVerified,  precessionYears: uranusPerihelionICRFYears },
    { key: 'neptune', obj: neptune, getIncl: () => o.neptuneInvPlaneInclinationDynamic || neptuneInvPlaneInclinationJ2000, ascNodeJ2000: neptuneAscendingNodeInvPlaneSouamiSouchay, ascNodeJ2000Verified: neptuneAscendingNodeInvPlaneVerified, precessionYears: neptunePerihelionICRFYears },
    { key: 'pluto',   obj: pluto,   getIncl: () => o.plutoInvPlaneInclinationDynamic   || plutoInvPlaneInclinationJ2000,   ascNodeJ2000: plutoAscendingNodeInvPlaneSouamiSouchay,   ascNodeJ2000Verified: plutoAscendingNodeInvPlaneVerified,   precessionYears: plutoPerihelionICRFYears },
    { key: 'halleys', obj: halleys, getIncl: () => o.halleysInvPlaneInclinationDynamic || halleysInvPlaneInclinationJ2000, ascNodeJ2000: halleysAscendingNodeInvPlaneSouamiSouchay, ascNodeJ2000Verified: halleysAscendingNodeInvPlaneVerified, precessionYears: halleysPerihelionICRFYears },
    { key: 'eros',    obj: eros,    getIncl: () => o.erosInvPlaneInclinationDynamic    || erosInvPlaneInclinationJ2000,    ascNodeJ2000: erosAscendingNodeInvPlaneSouamiSouchay,    ascNodeJ2000Verified: erosAscendingNodeInvPlaneVerified,    precessionYears: erosPerihelionICRFYears }
  ];

  for (const { key, obj, getIncl, ascNodeJ2000, ascNodeJ2000Verified, precessionYears } of planets) {
    let eclipticLongitude;
    let distanceAU;
    let inclToInvPlane;

    // Calculate dynamic ascending node on invariable plane in ICRF (precesses over time)
    // Precession rate = 360° / precessionYears (degrees per year) - this is the ICRF rate for visual markers
    const precessionRateICRF = 360 / precessionYears;

    // Back-calculate ascending node at balancedYear from J2000 values
    // Formula: ascNodeAtBalanced = ascNodeJ2000 - rate * yearsFromBalancedToJ2000
    const ascNodeAtBalancedSS = ascNodeJ2000 - precessionRateICRF * yearsFromBalancedToJ2000;
    const ascNodeAtBalancedVerified = ascNodeJ2000Verified - precessionRateICRF * yearsFromBalancedToJ2000;

    // Calculate current ascending node from balancedYear reference
    // This ensures perfect cycle synchronization over complete Holistic Years
    const rawSS = ascNodeAtBalancedSS + precessionRateICRF * yearsSinceBalanced;
    const rawVerified = ascNodeAtBalancedVerified + precessionRateICRF * yearsSinceBalanced;
    const ascNodeDynamicSS = ((rawSS % 360) + 360) % 360;
    const ascNodeDynamicVerified = ((rawVerified % 360) + 360) % 360;

    // Calculate ascending node in ECLIPTIC coords (for height calculation)
    // Each planet needs its own ecliptic rate, derived from:
    // - Planet's ICRF precession rate (precessionYears)
    // - General precession of ecliptic coordinate system (holisticyearLength/13)
    // Formula: 1/eclipticPeriod = 1/icrfPeriod + 1/generalPrecession
    // The rates ADD because both the orbital plane precession and ecliptic precession
    // contribute to the apparent motion of the ascending node in ecliptic coordinates.
    const generalPrecessionYears = holisticyearLength / 13;  // Axial precession cycle
    const icrfRate = 1 / precessionYears;  // rate in cycles/year
    const generalRate = 1 / generalPrecessionYears;  // rate in cycles/year
    const eclipticRate = icrfRate + generalRate;  // combined rate (rates add)
    const precessionRateEcliptic = eclipticRate * 360;  // convert to degrees/year

    // Back-calculate ecliptic ascending node at balancedYear
    const ascNodeAtBalancedEcliptic = ascNodeJ2000Verified - precessionRateEcliptic * yearsFromBalancedToJ2000;
    const rawEcliptic = ascNodeAtBalancedEcliptic + precessionRateEcliptic * yearsSinceBalanced;
    const ascNodeDynamicEcliptic = ((rawEcliptic % 360) + 360) % 360;

    // Store the dynamic ascending nodes for reference
    // Primary value uses J2000-verified ascending nodes (matches J2000 ecliptic inclinations) - ICRF rate for visuals
    o[key + 'AscendingNodeInvPlane'] = ascNodeDynamicVerified;
    // Also store Souami & Souchay value for comparison (including Earth)
    o[key + 'AscendingNodeInvPlaneSouamiSouchay'] = ascNodeDynamicSS;
    // Store ecliptic-rate ascending node for height calculations
    o[key + 'AscendingNodeInvPlaneEcliptic'] = ascNodeDynamicEcliptic;

    // Get dynamic inclination to invariable plane (with J2000 fallback)
    inclToInvPlane = getIncl();

    if (key === 'earth') {
      // Earth is special: we don't have o.earthTrueAnomaly etc.
      // Instead, use sun.ra (Sun's ecliptic longitude from Earth's view) + 180° to get Earth's heliocentric longitude
      // sun.ra is in radians
      const sunLongDeg = sun.ra * 180 / Math.PI;
      eclipticLongitude = (sunLongDeg + 180 + 360) % 360;
      distanceAU = earthWobbleCenter.sunDistAU || 1.0;

    } else {
      // Get planet's true anomaly (already calculated in updatePlanetAnomalies)
      const trueAnomaly = o[key + 'TrueAnomaly'] || 0;

      // Get argument of periapsis (already calculated in updateOrbitOrientations)
      const argPeriapsisEcliptic = o[key + 'ArgumentOfPeriapsis'] || 0;

      // Get ascending node on ecliptic (dynamic value)
      const ascNodeEcliptic = o[key + 'AscendingNode'] || 0;

      // Get distance from Sun (in AU)
      if (obj && obj.sunDistAU !== undefined) {
        distanceAU = obj.sunDistAU;
      } else {
        distanceAU = 1.0; // Fallback
      }

      // Calculate the planet's ecliptic longitude
      // Ecliptic longitude = Ascending node (ecliptic) + Argument of periapsis + True anomaly
      eclipticLongitude = (ascNodeEcliptic + argPeriapsisEcliptic + trueAnomaly) % 360;
    }

    // Calculate angle from the ascending node on the invariable plane
    // This is the ecliptic longitude minus the dynamic ascending node on invariable plane
    // Using ECLIPTIC-rate ascending node (matches the coordinate system of eclipticLongitude)
    let angleFromInvAscNode = (eclipticLongitude - ascNodeDynamicEcliptic + 360) % 360;

    // Convert to radians for sine calculation
    const angleRad = angleFromInvAscNode * DEG2RAD;
    const inclRad = inclToInvPlane * DEG2RAD;

    // Calculate height above invariable plane
    // Height = sin(inclination) * sin(angle from ascending node) * distance
    const height = Math.sin(inclRad) * Math.sin(angleRad) * distanceAU;

    // Store results in o object
    o[key + 'HeightAboveInvPlane'] = height;
    o[key + 'AboveInvPlane'] = height > 0;

  }
}

/**
 * Update the mass-weighted balance of planets relative to the invariable plane.
 *
 * Calculates:
 * - o.massWeightedBalance: Sum of (mass × height) / total mass (AU)
 * - o.planetsAboveInvPlane: Count of planets above the plane
 * - o.planetsBelowInvPlane: Count of planets below the plane
 *
 * The invariable plane is defined by the total angular momentum, so the mass-weighted
 * balance should oscillate around zero over long timescales.
 */
function updateInvariablePlaneBalance() {
  // Total mass of 8 major planets (in kg, from existing constants)
  const TOTAL_MASS = M_MERCURY + M_VENUS + M_EARTH + M_MARS + M_JUPITER + M_SATURN + M_URANUS + M_NEPTUNE;

  let weightedSum = 0;
  let aboveCount = 0;
  let belowCount = 0;

  const planets = [
    { key: 'mercury', mass: M_MERCURY },
    { key: 'venus',   mass: M_VENUS },
    { key: 'earth',   mass: M_EARTH },
    { key: 'mars',    mass: M_MARS },
    { key: 'jupiter', mass: M_JUPITER },
    { key: 'saturn',  mass: M_SATURN },
    { key: 'uranus',  mass: M_URANUS },
    { key: 'neptune', mass: M_NEPTUNE }
  ];

  for (const { key, mass } of planets) {
    const height = o[key + 'HeightAboveInvPlane'] || 0;
    const isAbove = o[key + 'AboveInvPlane'];

    weightedSum += mass * height;

    if (isAbove) {
      aboveCount++;
    } else {
      belowCount++;
    }
  }

  o.massWeightedBalance = weightedSum / TOTAL_MASS;
  o.planetsAboveInvPlane = aboveCount;
  o.planetsBelowInvPlane = belowCount;
}

// Track last sampled year for balance trend analysis (module-level to persist across calls)
let _lastBalanceSampleYear = null;

/**
 * Update balance trend analysis statistics.
 *
 * Only records samples when tracking is active (o.balanceTrackingActive = true).
 * Samples once per simulated year to avoid oversampling during fast simulation.
 *
 * Updates:
 * - o.balanceYearsTracked: Duration since tracking started
 * - o.balanceSampleCount: Number of yearly samples
 * - o.balanceCumulativeSum: Running sum of balance values
 * - o.balanceLifetimeAverage: Should converge to ~0 over 165+ years
 * - o.balanceMinSeen / o.balanceMaxSeen: Range of observed values
 */
function updateBalanceTrendAnalysis() {
  // Only record when tracking is active
  if (!o.balanceTrackingActive) return;

  const currentYear = Math.floor(o.currentYear);

  // Only sample once per simulated year
  if (currentYear === _lastBalanceSampleYear) return;
  _lastBalanceSampleYear = currentYear;

  // First sample initializes min/max
  if (o.balanceSampleCount === 0) {
    o.balanceMinSeen = o.massWeightedBalance;
    o.balanceMaxSeen = o.massWeightedBalance;
  }

  // Update statistics
  o.balanceSampleCount++;
  o.balanceCumulativeSum += o.massWeightedBalance;
  o.balanceYearsTracked = o.currentYear - o.balanceTrackingStartYear;
  o.balanceLifetimeAverage = o.balanceCumulativeSum / o.balanceSampleCount;

  // Track min/max (always update, even between yearly samples, to catch extremes)
  if (o.massWeightedBalance < o.balanceMinSeen) o.balanceMinSeen = o.massWeightedBalance;
  if (o.massWeightedBalance > o.balanceMaxSeen) o.balanceMaxSeen = o.massWeightedBalance;
}

/**
 * Update min/max tracking every frame (not just yearly samples).
 * This ensures we catch extreme values even with large time steps.
 */
function updateBalanceMinMax() {
  if (!o.balanceTrackingActive) return;

  // Always track min/max every frame to catch extremes
  if (o.balanceSampleCount === 0) {
    // Not yet initialized - will be set on first yearly sample
    return;
  }
  if (o.massWeightedBalance < o.balanceMinSeen) o.balanceMinSeen = o.massWeightedBalance;
  if (o.massWeightedBalance > o.balanceMaxSeen) o.balanceMaxSeen = o.massWeightedBalance;
}

/**
 * Start balance trend tracking from current simulation year.
 */
function startBalanceTracking() {
  o.balanceTrackingActive = true;
  o.balanceTrackingStartYear = o.currentYear;
  o.balanceYearsTracked = 0;
  o.balanceSampleCount = 0;
  o.balanceCumulativeSum = 0;
  o.balanceLifetimeAverage = 0;
  o.balanceMinSeen = 0;
  o.balanceMaxSeen = 0;
  _lastBalanceSampleYear = null;
}

/**
 * Stop balance trend tracking (preserves data for review).
 */
function stopBalanceTracking() {
  o.balanceTrackingActive = false;
}

/**
 * Reset balance trend tracking (clears all data).
 */
function resetBalanceTracking() {
  o.balanceTrackingActive = false;
  o.balanceTrackingStartYear = 0;
  o.balanceYearsTracked = 0;
  o.balanceSampleCount = 0;
  o.balanceCumulativeSum = 0;
  o.balanceLifetimeAverage = 0;
  o.balanceMinSeen = 0;
  o.balanceMaxSeen = 0;
  _lastBalanceSampleYear = null;
}

/**
 * Calculate the invariable plane orientation from angular momentum vectors.
 * This is "Option A" - dynamic calculation from orbital elements.
 *
 * Used to validate against "Option B" (Souami & Souchay 2012 published data).
 *
 * Updates:
 * - o.calculatedPlaneTilt: Angle from ecliptic (°)
 * - o.calculatedAscendingNode: Ascending node on ecliptic (°)
 * - o.jupiterAngularMomentumPercent: Jupiter's % of total L
 * - o.saturnAngularMomentumPercent: Saturn's % of total L
 * - o.optionABDifference: Difference between Option A and Option B (°)
 */
function calculateInvariablePlaneFromAngularMomentum() {
  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  // GM_SUN is in km³/s², lengthofAU is in km
  // Including Pluto as per Souami & Souchay (2012) who used N=10 body system
  const planets = [
    { key: 'mercury', mass: M_MERCURY, a: mercuryOrbitDistance, e: mercuryOrbitalEccentricity, i: mercuryEclipticInclinationJ2000, node: mercuryAscendingNode },
    { key: 'venus',   mass: M_VENUS,   a: venusOrbitDistance,   e: venusOrbitalEccentricity,   i: venusEclipticInclinationJ2000,   node: venusAscendingNode },
    { key: 'earth',   mass: M_EARTH,   a: 1.0,                  e: o.eccentricityEarth,        i: 0,                         node: 0 },
    { key: 'mars',    mass: M_MARS,    a: marsOrbitDistance,    e: marsOrbitalEccentricity,    i: marsEclipticInclinationJ2000,    node: marsAscendingNode },
    { key: 'jupiter', mass: M_JUPITER, a: jupiterOrbitDistance, e: jupiterOrbitalEccentricity, i: jupiterEclipticInclinationJ2000, node: jupiterAscendingNode },
    { key: 'saturn',  mass: M_SATURN,  a: saturnOrbitDistance,  e: saturnOrbitalEccentricity,  i: saturnEclipticInclinationJ2000,  node: saturnAscendingNode },
    { key: 'uranus',  mass: M_URANUS,  a: uranusOrbitDistance,  e: uranusOrbitalEccentricity,  i: uranusEclipticInclinationJ2000,  node: uranusAscendingNode },
    { key: 'neptune', mass: M_NEPTUNE, a: neptuneOrbitDistance, e: neptuneOrbitalEccentricity, i: neptuneEclipticInclinationJ2000, node: neptuneAscendingNode },
    { key: 'pluto',   mass: M_PLUTO,   a: plutoOrbitDistance,   e: plutoOrbitalEccentricity,   i: plutoEclipticInclinationJ2000,   node: plutoAscendingNode },
    // Including Ceres as per Souami & Souchay (2012) who used N=10 body system
    { key: 'ceres',   mass: M_CERES,   a: ceresOrbitDistance,   e: ceresOrbitalEccentricity,   i: ceresEclipticInclinationJ2000,   node: ceresAscendingNode }
  ];

  let L_total_x = 0;
  let L_total_y = 0;
  let L_total_z = 0;
  let totalL = 0;
  let jupiterL = 0;
  let saturnL = 0;

  for (const planet of planets) {
    // Specific angular momentum magnitude: h = sqrt(GM * a * (1 - e²))
    // a is in AU, convert to km for consistency with GM_SUN (km³/s²)
    const a_km = planet.a * o.lengthofAU;
    const h = Math.sqrt(GM_SUN * a_km * (1 - planet.e * planet.e));

    // Angular momentum magnitude: L = m * h
    const L_mag = planet.mass * h;

    // Orbital plane normal (perpendicular to orbit, in ecliptic coordinates)
    const i_rad = planet.i * DEG2RAD;
    const node_rad = planet.node * DEG2RAD;

    // Normal vector to orbital plane points in direction of angular momentum
    const nx = Math.sin(i_rad) * Math.sin(node_rad);
    const ny = Math.cos(i_rad);
    const nz = -Math.sin(i_rad) * Math.cos(node_rad);

    // Weight by angular momentum magnitude
    L_total_x += nx * L_mag;
    L_total_y += ny * L_mag;
    L_total_z += nz * L_mag;
    totalL += L_mag;

    // Track Jupiter and Saturn contributions
    if (planet.key === 'jupiter') jupiterL = L_mag;
    if (planet.key === 'saturn') saturnL = L_mag;
  }

  // Normalize to get invariable plane normal
  const L_mag_total = Math.sqrt(L_total_x * L_total_x + L_total_y * L_total_y + L_total_z * L_total_z);
  const nx = L_total_x / L_mag_total;
  const ny = L_total_y / L_mag_total;
  const nz = L_total_z / L_mag_total;

  // Calculate tilt from ecliptic (angle between L_total and Y-axis)
  // Y-axis is ecliptic normal in our coordinate system
  const tiltDeg = Math.acos(ny) * RAD2DEG;

  // Calculate ascending node on ecliptic
  // This is the longitude where the invariable plane crosses the ecliptic going north
  let ascNodeDeg = Math.atan2(nx, -nz) * RAD2DEG;
  if (ascNodeDeg < 0) ascNodeDeg += 360;

  // Store results
  o.calculatedPlaneTilt = tiltDeg;
  o.calculatedAscendingNode = ascNodeDeg;
  o.jupiterAngularMomentumPercent = (jupiterL / totalL) * 100;
  o.saturnAngularMomentumPercent = (saturnL / totalL) * 100;

  // Calculate difference between Option A and Option B
  // Option B reference: Souami & Souchay (2012) invariable plane tilt = 1.5787°
  // Note: This is constant - the invariable plane orientation doesn't change over human timescales
  const SOUAMI_SOUCHAY_TILT = 1.5787;  // From S&S 2012 paper
  o.optionABDifference = Math.abs(tiltDeg - SOUAMI_SOUCHAY_TILT);
}

/**
 * Calculate dynamic ecliptic inclinations for all planets.
 *
 * The ecliptic inclination of a planet relative to Earth's orbital plane (ecliptic)
 * changes over time because the ecliptic itself tilts relative to the invariable plane.
 *
 * Algorithm:
 * 1. Calculate ecliptic normal vector from Earth's inclination and ascending node on invariable plane
 * 2. For each planet, calculate its orbital plane normal from its inclination and ascending node
 * 3. The angle between the two normals is the ecliptic inclination
 *
 * Uses existing constants (<planet>Inclination) for fixed inclination to invariable plane,
 * and dynamic values (o.<planet>AscendingNodeInvPlane) for precessing ascending nodes.
 *
 * Output:
 * - o.<planet>EclipticInclinationDynamic: using J2000-verified ascending nodes (matches J2000 exactly)
 * - o.<planet>EclipticInclinationSouamiSouchayDynamic: using original Souami & Souchay (2012) ascending nodes
 */
function updateDynamicInclinations() {
  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  // First, compute dynamic inclinations for all planets
  // Uses J2000-calibrated oscillations with planet-specific phase offsets
  // At J2000, these return exactly the Souami & Souchay values
  o.mercuryInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('mercury', o.currentYear);
  o.venusInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('venus', o.currentYear);
  o.marsInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('mars', o.currentYear);
  o.jupiterInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('jupiter', o.currentYear);
  o.saturnInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('saturn', o.currentYear);
  o.uranusInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('uranus', o.currentYear);
  o.neptuneInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('neptune', o.currentYear);
  o.plutoInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('pluto', o.currentYear);
  o.halleysInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('halleys', o.currentYear);
  o.erosInvPlaneInclinationDynamic = computePlanetInvPlaneInclinationDynamic('eros', o.currentYear);


  // Get Earth's current orbital plane normals (ecliptic normals)
  // We need TWO ecliptic normals: one for S&S calculations, one for Verified calculations
  // Normal vector formula: n = (sin(i)*sin(Ω), sin(i)*cos(Ω), cos(i))
  const earthI = o.earthInvPlaneInclinationDynamic * DEG2RAD;

  // Ecliptic normal using S&S Earth ascending node (for EclipticInclinationSouamiSouchayDynamic)
  const earthOmegaSS = o.earthAscendingNodeInvPlaneSouamiSouchay * DEG2RAD;
  _eclipticNormalSS.set(
    Math.sin(earthI) * Math.sin(earthOmegaSS),
    Math.sin(earthI) * Math.cos(earthOmegaSS),
    Math.cos(earthI)
  );

  // Ecliptic normal using Verified Earth ascending node (for EclipticInclinationDynamic)
  const earthOmegaVerified = o.earthAscendingNodeInvPlane * DEG2RAD;
  _eclipticNormalVerified.set(
    Math.sin(earthI) * Math.sin(earthOmegaVerified),
    Math.sin(earthI) * Math.cos(earthOmegaVerified),
    Math.cos(earthI)
  );

  // Planet configuration
  // incl = DYNAMIC inclinations to invariable plane (now oscillating like Earth's)
  // ascNodeSS = Souami & Souchay (2012) ascending nodes (dynamic, precessing)
  // ascNodeVerified = J2000-verified ascending nodes (dynamic, precessing) - now the primary value
  const planets = [
    { key: 'mercury', incl: o.mercuryInvPlaneInclinationDynamic, ascNodeSS: o.mercuryAscendingNodeInvPlaneSouamiSouchay, ascNodeVerified: o.mercuryAscendingNodeInvPlane },
    { key: 'venus',   incl: o.venusInvPlaneInclinationDynamic,   ascNodeSS: o.venusAscendingNodeInvPlaneSouamiSouchay,   ascNodeVerified: o.venusAscendingNodeInvPlane },
    { key: 'mars',    incl: o.marsInvPlaneInclinationDynamic,    ascNodeSS: o.marsAscendingNodeInvPlaneSouamiSouchay,    ascNodeVerified: o.marsAscendingNodeInvPlane },
    { key: 'jupiter', incl: o.jupiterInvPlaneInclinationDynamic, ascNodeSS: o.jupiterAscendingNodeInvPlaneSouamiSouchay, ascNodeVerified: o.jupiterAscendingNodeInvPlane },
    { key: 'saturn',  incl: o.saturnInvPlaneInclinationDynamic,  ascNodeSS: o.saturnAscendingNodeInvPlaneSouamiSouchay,  ascNodeVerified: o.saturnAscendingNodeInvPlane },
    { key: 'uranus',  incl: o.uranusInvPlaneInclinationDynamic,  ascNodeSS: o.uranusAscendingNodeInvPlaneSouamiSouchay,  ascNodeVerified: o.uranusAscendingNodeInvPlane },
    { key: 'neptune', incl: o.neptuneInvPlaneInclinationDynamic, ascNodeSS: o.neptuneAscendingNodeInvPlaneSouamiSouchay, ascNodeVerified: o.neptuneAscendingNodeInvPlane },
    { key: 'pluto',   incl: o.plutoInvPlaneInclinationDynamic,   ascNodeSS: o.plutoAscendingNodeInvPlaneSouamiSouchay,   ascNodeVerified: o.plutoAscendingNodeInvPlane },
    { key: 'halleys', incl: o.halleysInvPlaneInclinationDynamic, ascNodeSS: o.halleysAscendingNodeInvPlaneSouamiSouchay, ascNodeVerified: o.halleysAscendingNodeInvPlane },
    { key: 'eros',    incl: o.erosInvPlaneInclinationDynamic,    ascNodeSS: o.erosAscendingNodeInvPlaneSouamiSouchay,    ascNodeVerified: o.erosAscendingNodeInvPlane }
  ];

  for (const { key, incl, ascNodeSS, ascNodeVerified } of planets) {
    const pI = incl * DEG2RAD;

    // Calculate using Souami & Souchay ascending node AND S&S ecliptic normal
    const pOmegaSS = ascNodeSS * DEG2RAD;
    _planetNormal.set(
      Math.sin(pI) * Math.sin(pOmegaSS),
      Math.sin(pI) * Math.cos(pOmegaSS),
      Math.cos(pI)
    );
    const cosAngleSS = _planetNormal.dot(_eclipticNormalSS);
    const apparentInclSS = Math.acos(Math.max(-1, Math.min(1, cosAngleSS))) * RAD2DEG;
    o[key + 'EclipticInclinationSouamiSouchayDynamic'] = apparentInclSS;

    // Calculate using J2000-verified ascending node AND Verified ecliptic normal
    const pOmegaVerified = ascNodeVerified * DEG2RAD;
    _planetNormal.set(
      Math.sin(pI) * Math.sin(pOmegaVerified),
      Math.sin(pI) * Math.cos(pOmegaVerified),
      Math.cos(pI)
    );
    const cosAngleVerified = _planetNormal.dot(_eclipticNormalVerified);
    const apparentInclVerified = Math.acos(Math.max(-1, Math.min(1, cosAngleVerified))) * RAD2DEG;
    o[key + 'EclipticInclinationDynamic'] = apparentInclVerified;
  }
}

/**
 * Derive ecliptic inclination i, ascending node Ω, descending node Ωd,
 * and argument of periapsis ω from the two stored tilt components plus
 * the already-known longitude of perihelion ϖ.
 *
 * @param {object} pd    – planet data with .name, .orbitTilta, .orbitTiltb
 * @param {number} peri  – ϖ, the ecliptic longitude of perihelion [0,360)
 * @returns {{inclination:number, ascending:number,
 *            descending:number, argument:number}}
 */
function orbitalAnglesFromTilts(pd, peri) {
  // Use dynamic container rotation if available (updated by updateOrbitalPlaneRotations),
  // otherwise fall back to static values
  let ax, az;
  if (pd.containerObj) {
    // Convert from radians back to degrees (container rotation is in radians)
    ax = pd.containerObj.rotation.x * 180 / Math.PI;
    az = pd.containerObj.rotation.z * 180 / Math.PI;
  } else {
    ax = pd.orbitTilta;   // degrees (static fallback)
    az = pd.orbitTiltb;   // degrees
  }

  /* ---- 1  inclination --------------------------------------------- */
  const i = Math.hypot(ax, az);       // √(ax² + az²)

  // if (i < 1e-6) {
  //   // Orbit lies exactly in the ecliptic: nodes & ω are undefined.
  //   throw new RangeError(`${pd.name}: i ≃ 0°, nodes undefined`);
  // }

  /* ---- 2  longitude of the ascending node ------------------------- */
  let Ω = Math.atan2(ax, az) * 180 / Math.PI;   // atan2(sinΩ, cosΩ)
  if (Ω < 0) Ω += 360;

  const Ωd = (Ω + 180) % 360;                   // descending node

  /* ---- 3  argument of periapsis ----------------------------------- */
  let ω = (peri - Ω) % 360;
  if (ω < 0) ω += 360;

  return { inclination: i, ascending: Ω, descending: Ωd, argument: ω };
}

function updateOrbitOrientations() {
  const planets = [
    ["mercury",  mercuryRealPerihelionAtSun,  o.mercuryPerihelion],
    ["venus",    venusRealPerihelionAtSun,    o.venusPerihelion],
//    ["mercury2",    mercuryRealPerihelionAtSun,    o.mercuryPerihelion2],    
    ["mars",     marsRealPerihelionAtSun,     o.marsPerihelion],
    ["jupiter",  jupiterRealPerihelionAtSun,  o.jupiterPerihelion],
    ["saturn",   saturnRealPerihelionAtSun,   o.saturnPerihelion],
    ["uranus",   uranusRealPerihelionAtSun,   o.uranusPerihelion],
    ["neptune",  neptuneRealPerihelionAtSun,  o.neptunePerihelion],
    ["pluto",    plutoRealPerihelionAtSun,    o.plutoPerihelion],
    ["halleys",  halleysRealPerihelionAtSun,  o.halleysPerihelion],
    ["eros",     erosRealPerihelionAtSun,     o.erosPerihelion]
  ];

  for (const [name, pd, peri] of planets) {
    const r = orbitalAnglesFromTilts(pd, peri);

    o[`${name}Inclination`]        = r.inclination;      // (optional)
    o[`${name}AscendingNode`]      = r.ascending;        // Ω
    o[`${name}DescendingNode`]     = r.descending;       // Ω + 180°
    o[`${name}ArgumentOfPeriapsis`] = r.argument;        // ω
  }
}

/**
 * Make a transparent GridHelper that lies exactly in the orbital plane
 * defined by pd.orbitTilta / pd.orbitTiltb and attach it to `parent`.
 *
 * @param {object}           pd           – planet-data object (needs .name,
 *                                          .orbitTilta, .orbitTiltb)
 * @param {THREE.Object3D}   parent       – usually the planet’s orbitContainer
 * @param {number}           size         – overall grid span
 * @param {number} [divs=90]              – grid divisions
 * @returns {THREE.GridHelper}
 */
function addOrbitPlaneHelper(pd, parent, size, divs = 90) {

  /* --- 1  colour picked from a name→hex map ------------------------ */
  const majorCol = planetColorHex[pd.name.toLowerCase()] ?? 0xffffff;
  const minorCol = brighten(majorCol, 0.55);   // a bit lighter

  /* --- 2  build and beautify the grid ------------------------------ */
  const grid = new THREE.GridHelper(size, divs, majorCol, minorCol);

  // visibility tweaks: brighter & always in front of the orbit line
  grid.material.opacity      = 0.65;
  grid.material.transparent  = true;
  grid.material.blending     = THREE.AdditiveBlending;
  grid.material.depthWrite   = false;      // never occlude itself
  grid.renderOrder = -1;                   // draw after solid meshes

  /* --- 3  rotate into orbital plane -------------------------------- */
  const DEG2RAD = Math.PI / 180;
  grid.rotation.x = pd.orbitTilta * DEG2RAD;
  grid.rotation.z = pd.orbitTiltb * DEG2RAD;

  parent.add(grid);
  return grid;
}

/**
 * goldenspiralPerihelionObjects
 * -----------------------------
 * Creates a golden-coloured THREE.Line that dynamically links every perihelion
 * helper that is visible in the camera frustum.
 *
 * @param {...THREE.Object3D} perihelionObjs  The perihelion helpers (must expose pivotObj).
 *        Pass them in the order you want them connected.
 *        👉  The last two arguments **must** be the camera and the scene.
 *
 * @returns {Function} update() – call this once per frame inside your render loop.
 *
 * Usage:
 * const updateLine = goldenspiralPerihelionObjects(
 *     earthPerihelionFromEarth,
 *     venusPerihelionFromEarth,
 *     marsPerihelionFromEarth,
 *     jupiterPerihelionFromEarth,
 *     saturnPerihelionFromEarth,
 *     uranusPerihelionFromEarth,
 *     neptunePerihelionFromEarth,   // 7th object? No problem – pass as many as you like.
 *     camera,
 *     scene
 * );
 *
 * function animate() {
 *   requestAnimationFrame( animate );
 *   updateLine();                   // refresh positions & visibility
 *   renderer.render( scene, camera );
 * }
 */
function goldenspiralPerihelionObjects(...args) {

  /* ---------- 0. unpack parameters ---------------------------------- */
  const camera = args[args.length - 2];
  const scene  = args[args.length - 1];
  const pds    = args.slice(0, -2);

  for (const pd of pds) (pd.planetObj ?? pd).visible = false;
  
  /* ---------- 1. constants ------------------------------------------ */
  const SMOOTH_SEGMENTS   = 32;   // Catmull-Rom samples / segment
  const TUBE_RADIUS       = 0.08; // 0.02-0.06 looks nice
  const TUBE_RADIAL_SEGS  = 24;

  /* ---------- 2. dummy geometry / material -------------------------- */
  const goldenTube = new THREE.Mesh(
    new THREE.BufferGeometry(),                       // placeholder
    new THREE.MeshBasicMaterial({
      color: 0xfff7b3,              // pale–gold – the brighter, the better
      transparent: true,
      opacity: 0.95,                // tiny transparency helps bloom later
      toneMapped: false,            // <-- crucial: bypass tone-mapping curve
      blending: THREE.AdditiveBlending,
      depthWrite: false,             // keeps the glow from killing depth buffer
    })
  );
  goldenTube.visible       = false;   // off by default
  goldenTube.frustumCulled = false;   // never culled
  scene.add(goldenTube);

  /* ---------- 3. updater -------------------------------------------- */
  const world = new THREE.Vector3();
  const ndc   = new THREE.Vector3();
  // Pre-allocate Vector3 array (one per perihelion point) - avoids clone() allocations
  const visiblePts = [];
  for (let i = 0; i < pds.length; i++) {
    visiblePts.push(new THREE.Vector3());
  }

  function updateGoldenSpiralLine() {

    /* 3-a. gather **all** perihelion helpers into pre-allocated vectors */
     for (let i = 0; i < pds.length; i++) {
       pds[i].pivotObj.getWorldPosition(visiblePts[i]);
     }

    /* 3-b. build Catmull-Rom curve & sample points ------------------ */
    const curve = new THREE.CatmullRomCurve3(visiblePts);
    const curvePts = curve.getPoints(
      (visiblePts.length - 1) * SMOOTH_SEGMENTS
    );

    /* 3-c. ---------- rebuild tube RIGHT HERE ----------------------- */
    if (goldenTube.visible) {                 // skip if user has it hidden
      const oldGeom = goldenTube.geometry;    // dispose afterwards

      const tubeGeom = new THREE.TubeGeometry(
        new THREE.CatmullRomCurve3(curvePts),
        curvePts.length * 2,                  // tubularSegments
        TUBE_RADIUS,
        TUBE_RADIAL_SEGS,
        false
      );

      goldenTube.geometry = tubeGeom;
      oldGeom.dispose();
    }
  }
 
  /* ---------- NEW utility: flip markers on/off ------------------- */
  function setHelpersVisible(v) {
    for (const pd of pds) (pd.planetObj ?? pd).visible = v;
  }
  
  /* ---------- 4. export -------------------------------------------- */
  return {
    goldenLine: goldenTube,         // public name stays goldenLine for GUI
    update: updateGoldenSpiralLine,
    setHelpersVisible                 // expose the helper toggler
  };
}

/* ------------------------------------------------------------------ */
/*  1.  LAST PERIHELION BEFORE A GIVEN JD                             */
/*      (≈ 1″ accuracy over ±150 000 yr)                              */
/* ------------------------------------------------------------------ */

/**
 * Return the Julian Day of the *last* perihelion preceding `JD`.
 * Uses the *current* sidereal-year length supplied in `o`.
 *
 * @param  {number} JD  – target epoch
 * @return {number} JD  of the most recent perihelion
 */
function lastPerihelionJD(JD) {
  const siderealDays = o.lengthofsiderealYear / o.lengthofDay;   // days
  const cycles       = Math.floor((JD - perihelionalignmentJD) / siderealDays);
  return perihelionalignmentJD + cycles * siderealDays;
}

/* ------------------------------------------------------------------ */
/*  2.  EQUATION–OF–CENTRE  (series, pre-compressed)                  */
/*      good to < 0.01″ for e ≤ 0.08                                  */
/* ------------------------------------------------------------------ */

/**
 * Fast series for C = ν − M  (rad) up to e⁵.
 * M must be in **radians**.
 */
function equationOfCentre(e, M) {

  const e2 =  e * e;
  const e3 =  e2 * e;
  const e4 =  e2 * e2;
  const e5 =  e4 * e;

  const sinM  = Math.sin(M);
  const sin2M = Math.sin(2*M);
  const sin3M = Math.sin(3*M);
  const sin4M = Math.sin(4*M);
  const sin5M = Math.sin(5*M);

  /* Laskar / Sterne series through e⁵, but written with
     numeric coefficients only – no iterations needed              */
  return (  (2*e      - 0.25*e3      + (5/96)*e5) * sinM
          + (1.25*e2  - (11/24)*e4 ) * sin2M
          + ((13/12)*e3 - (43/64)*e5) * sin3M
          +  (103/96)*e4             * sin4M
          + (1097/960)*e5            * sin5M     );
}

/* ------------------------------------------------------------------ */
/*  3.  MAIN ROUTINE – TRUE SOLAR LONGITUDE                           */
/* ------------------------------------------------------------------ */

/**
 * True ecliptic longitude of the Sun (deg, 0-360) in the **ecliptic of date**.
 *
 * Inputs taken from global `o`:
 *   • o.eccentricityEarth        (unitless, 0.0 … 0.1)
 *   • o.longitudePerihelion      (deg, ecliptic-of-date)
 *   • o.lengthofsiderealYear     (seconds)
 *   • o.lengthofDay              (seconds)
 *
 * The function is kepler-exact, but the mean anomaly is built from a single
 * anchor perihelion (14 Dec 1245) plus the *current* sidereal-year length.
 * Accuracy:  better than 1″ for |JD − current JD| ≲ 50 000 yr provided
 *            you keep `o.*` values self-consistent with that JD.
 *
 * @param  {number} JD  – barycentric dynamical time Julian Day
 * @return {number} λ   – true longitude (deg 0-360)
 */
function solarLongitudeDegLong(JD) {

  /* --- orbital elements for *this* JD ---------------------------- */
  const e     = o.eccentricityEarth;        // current eccentricity
  const omega = wrap360(o.longitudePerihelion);   // deg

  /* mean motion (deg/day) from the *sidereal* year ---------------- */
  const siderealDays = o.lengthofsiderealYear / o.lengthofDay;
  const nDegPerDay   = 360 / siderealDays;

  /* time since the last perihelion preceding JD ------------------- */
  const JDp  = lastPerihelionJD(JD);        // JD of most recent perihelion
  const dt   = JD - JDp;                    // days

  /* mean anomaly --------------------------------------------------- */
  const Mdeg = wrap360(nDegPerDay * dt);    // deg
  const Mrad = Mdeg * DEG;                  // rad

  /* equation of centre (rad) -------------------------------------- */
  const C    = equationOfCentre(e, Mrad);   // rad
  const Cdeg = C / DEG;                     // deg

  /* true longitude ------------------------------------------------- */
  const lambda = wrap360(omega + Mdeg + Cdeg);
  return lambda;
}

//Returns the angle from the sun to targetPlanet as viewed from earth using the cosine rule.
function getElongationFromSun(targetPlanet) {
  sun.planetObj.getWorldPosition(_elSunPos);
  earth.planetObj.getWorldPosition(_elEarthPos);
  targetPlanet.planetObj.getWorldPosition(_elTargetPos);

  const earthSunDistance = _elEarthPos.distanceTo(_elSunPos);
  const earthTargetPlanetDistance = _elEarthPos.distanceTo(_elTargetPos);
  const sunTargetPlanetDistance = _elSunPos.distanceTo(_elTargetPos);

  const numerator =
    Math.pow(earthSunDistance, 2) +
    Math.pow(earthTargetPlanetDistance, 2) -
    Math.pow(sunTargetPlanetDistance, 2);

  const denominator = 2.0 * earthSunDistance * earthTargetPlanetDistance;

  const elongationRadians = Math.acos(numerator / denominator);
  return (180.0 * elongationRadians) / Math.PI;
}

function updateElongations() {
  o["moonElongation"]=getElongationFromSun(moon);
  o["mercuryElongation"]=getElongationFromSun(mercury);
  o["venusElongation"]=getElongationFromSun(venus);
  o["marsElongation"]=getElongationFromSun(mars);
  o["jupiterElongation"]=getElongationFromSun(jupiter);
  o["saturnElongation"]=getElongationFromSun(saturn);
  o["uranusElongation"]=getElongationFromSun(uranus);
  o["neptuneElongation"]=getElongationFromSun(neptune);
  o["plutoElongation"]=getElongationFromSun(pluto);
  o["halleysElongation"]=getElongationFromSun(halleys);
  o["erosElongation"]=getElongationFromSun(eros);
};

function updatePredictions() {
  // 1. Auto-copy fields with same names
  for (let key in predictions) {
    if (o.hasOwnProperty(key)) {
      predictions[key] = o[key];
    }
  }
  
  predictions.lengthofDay = o.lengthofDay = computeLengthofDay(o.currentYear, balancedYear, perihelionCycleLength, o.perihelionprecessioncycleYear, meansolardayAmplitudeinSeconds, meanlengthofday);
  
  predictions.lengthofsolarYear = o.lengthofsolarYear = computeLengthofsolarYear(o.currentYear, balancedYear, perihelionCycleLength, o.perihelionprecessioncycleYear, meansolaryearAmplitudeinDays, meansolaryearlengthinDays);
  predictions.lengthofsiderealYear = o.lengthofsiderealYear = computeLengthofsiderealYear(o.currentYear, balancedYear, perihelionCycleLength, o.perihelionprecessioncycleYear, meansiderealyearAmplitudeinSeconds, meansiderealyearlengthinSeconds);

  // Compute these early - they are dependencies for calculations below
  predictions.lengthofsolarYearSecRealLOD = o.lengthofsolarYearSecRealLOD = o.lengthofsolarYear*o.lengthofDay;
  predictions.computeAxialPrecessionRealLOD = o.axialPrecessionRealLOD = computeAxialPrecessionRealLOD(o.lengthofsiderealYear, o.lengthofsolarYear, o.lengthofDay);
  predictions.perihelionPrecessionRealLOD = o.perihelionPrecessionRealLOD = o.axialPrecessionRealLOD*13/16;

  predictions.lengthofsolarYearinDays = o.lengthofsolarYearinDays = o.lengthofsolarYearSecRealLOD/o.lengthofDay;
  predictions.lengthofsiderealDay = o.lengthofsiderealDay = o.lengthofsolarYearSecRealLOD/(o.lengthofsolarYearinDays+1);
  predictions.lengthofstellarDay = o.lengthofstellarDay = (((o.lengthofsiderealYear-o.lengthofsolarYearSecRealLOD)/(1/eccentricityAmplitude/13*16))/(o.lengthofsolarYear+1))+o.lengthofsiderealDay;
  
  predictions.lengthofsiderealYearDays = o.lengthofsiderealYear/o.lengthofDay; 
  
  predictions.perihelionPrecession = o.perihelionPrecession = o.axialPrecession*13/16;
  predictions.axialPrecession = o.axialPrecession = computeAxialPrecession(o.lengthofsiderealYear, o.lengthofsolarYear);
  predictions.inclinationPrecession = o.inclinationPrecession = o.axialPrecession*13/3;
  predictions.obliquityPrecession = o.obliquityPrecession = o.axialPrecession*13/8;
  predictions.eclipticPrecession = o.eclipticPrecession = o.axialPrecession*13/5;
  
  predictions.lengthofsiderealDayRealLOD = o.lengthofsiderealDayRealLOD = (o.lengthofsolarYear*86400)/(o.lengthofsolarYear+1);
  predictions.lengthofstellarDayRealLOD = o.lengthofstellarDayRealLOD = (o.lengthofsiderealDay/(holisticyearLength/13))/(meansolaryearlengthinDays+1)+o.lengthofsiderealDay;
  
  //predictions.predictedDeltat = getDeltaT();
  predictions.predictedDeltatPerYear = o.predictedDeltatPerYear = getDeltaTChangePerYear();
  
  predictions.lengthofsiderealYearDaysRealLOD = o.lengthofsiderealYear/o.lengthofDay;
  predictions.lengthofanomalisticYearRealLOD = o.lengthofanomalisticYearRealLOD = computeLengthofanomalisticYearRealLOD(o.perihelionPrecessionRealLOD, o.lengthofsolarYear, o.lengthofDay);

  predictions.lengthofanomalisticYearinDays = o.lengthofanomalisticYearinDays = o.lengthofanomalisticYearRealLOD/o.lengthofDay;
  predictions.lengthofanomalisticDaysRealLOD = o.lengthofanomalisticDaysRealLOD = o.lengthofanomalisticYearRealLOD/o.lengthofDay;

  predictions.inclinationPrecessionRealLOD = o.inclinationPrecessionRealLOD = o.axialPrecessionRealLOD*13/3;
  predictions.obliquityPrecessionRealLOD = o.obliquityPrecessionRealLOD = o.axialPrecessionRealLOD*13/8;
  predictions.eclipticPrecessionRealLOD =o.eclipticPrecessionRealLOD = o.axialPrecessionRealLOD*13/5;
  
  predictions.eccentricityEarth = o.eccentricityEarth = computeEccentricityEarth(o.currentYear, balancedYear, perihelionCycleLength, eccentricityMean, eccentricityAmplitude, eccentricitySinusCorrection);
  predictions.obliquityEarth = o.obliquityEarth = computeObliquityEarth(o.currentYear);
  predictions.earthInvPlaneInclinationDynamic = o.earthInvPlaneInclinationDynamic = computeInclinationEarth(o.currentYear, balancedYear, holisticyearLength, earthInvPlaneInclinationMean, earthInvPlaneInclinationAmplitude);
  predictions.longitudePerihelion = o.longitudePerihelion = computeLongitudePerihelion(o.currentYear, balancedYear, perihelionCycleLength, o.perihelionprecessioncycleYear, helionpointAmplitude, mideccentricitypointAmplitude); // better to use ((earthPerihelionFromEarth.ra * 180 / Math.PI + 360) % 360) because this is just a rough estimate formula
  
  predictions.longitudePerihelionDatePer = o.longitudePerihelionDatePer = longitudeToDateTime((((earthPerihelionFromEarth.ra * 180 / Math.PI + 360) % 360)-earthRAAngle-180), o.currentYear)
  predictions.longitudePerihelionDateAp = o.longitudePerihelionDateAp = longitudeToDateTime(((earthPerihelionFromEarth.ra * 180 / Math.PI + 360)-earthRAAngle % 360), o.currentYear)
  
  predictions.lengthofAU = o.lengthofAU = (o.lengthofsiderealYear/60/60 * speedofSuninKM) / (2 * Math.PI);

}

/**
 * Compute the length of day (in seconds) for a given year.
 *
 * @param {number} currentYear                      – the year you want to compute for
 * @param {number} balancedYear                     – the reference (“balanced”) year
 * @param {number} perihelionCycleLength            – length of the perihelion cycle (in years)
 * @param {number} perihelionprecessioncycleYear    – the precession cycle year threshold
 * @param {number} meansolardayAmplitudeinSeconds   – amplitude of the mean solar‐day variation (in seconds)
 * @param {number} meanlengthofday                  – the base mean length of day (in seconds)
 * @returns {number} lengthofDay (in seconds)
 */
function computeLengthofDay(
  currentYear,
  balancedYear,
  perihelionCycleLength,
  perihelionprecessioncycleYear,
  meansolardayAmplitudeinSeconds,
  meanlengthofday
  ) {
  // Δ‐year
  const delta = currentYear - balancedYear;

  // Excel’s IF: if (Δ/length < 1) then Δ else perihelionprecessioncycleYear
  const cycleValue = (delta / perihelionCycleLength) < 1
    ? delta
    : perihelionprecessioncycleYear;

  // angle for the first COS term (in radians):
  // (cycleValue / perihelionCycleLength) * 360°
  //const angle1 = (cycleValue / perihelionCycleLength) * 360 * Math.PI / 180;
  //const term1 = -meansolardayAmplitudeinSeconds * meansolaryearAmplitude * Math.sin(angle1);

  // angle for the SIN term (in radians):
  // (cycleValue / (perihelionCycleLength/2)) * 360°
  const angle2 = (cycleValue / (perihelionCycleLength )) * 360 * Math.PI / 180;
  const term2 = -meansolardayAmplitudeinSeconds * Math.cos(angle2);

  // sum both terms + base mean length of day
  return term2 + meanlengthofday;
}

/**
 * Compute the length of the solar year (in days) for a given year.
 *
 * @param {number} currentYear                      – the year you want to compute for
 * @param {number} balancedYear                     – the reference (“balanced”) year
 * @param {number} perihelionCycleLength            – length of the perihelion cycle (in years)
 * @param {number} perihelionprecessioncycleYear    – the precession cycle year threshold
 * @param {number} meansolaryearAmplitudeinDays     – amplitude of the solar‐year variation (in days)
 * @param {number} meansolaryearlengthinDays        – the base mean length of solar year (in days)
 * @returns {number} lengthofsolarYear (in days)
 */
function computeLengthofsolarYear(
  currentYear,
  balancedYear,
  perihelionCycleLength,
  perihelionprecessioncycleYear,
  meansolaryearAmplitudeinDays,
  meansolaryearlengthinDays
  ) {
  // Δ‐year
  const delta = currentYear - balancedYear;

  // Excel’s IF: if (Δ/length < 1) then Δ else perihelionprecessioncycleYear
  const cycleValue = (delta / perihelionCycleLength) < 1
    ? delta
    : perihelionprecessioncycleYear;

  // angle in radians: (cycleValue/perihelionCycleLength) * 360°
  const angle = (cycleValue / perihelionCycleLength) * 360 * Math.PI / 180;

  // formula: amplitude × sin(angle) + base length
  return meansolaryearAmplitudeinDays * Math.sin(angle)
       + meansolaryearlengthinDays;
}

/**
 * Compute the length of the sidereal year (in seconds) for a given year.
 *
 * @param {number} currentYear                          – the year you want to compute for
 * @param {number} balancedYear                         – the reference (“balanced”) year
 * @param {number} perihelionCycleLength                – length of the perihelion cycle (in years)
 * @param {number} perihelionprecessioncycleYear        – the precession cycle year threshold
 * @param {number} meansiderealyearAmplitudeinSeconds   – amplitude of the sidereal‐year variation (in seconds)
 * @param {number} meansiderealyearlengthinSeconds      – the base mean length of sidereal year (in seconds)
 * @returns {number} lengthofsiderealYear (in seconds)
 */
function computeLengthofsiderealYear(
  currentYear,
  balancedYear,
  perihelionCycleLength,
  perihelionprecessioncycleYear,
  meansiderealyearAmplitudeinSeconds,
  meansiderealyearlengthinSeconds
  ) {
  // Δ‐year
  const delta = currentYear - balancedYear;

  // Excel’s IF: if (Δ/length < 1) then Δ else perihelionprecessioncycleYear
  const cycleValue = (delta / perihelionCycleLength) < 1
    ? delta
    : perihelionprecessioncycleYear;

  // angle in radians: (cycleValue / perihelionCycleLength) * 360°
  const angle = (cycleValue / perihelionCycleLength) * 360 * Math.PI / 180;

  // formula: − amplitude × sin(angle) + base length
  return -meansiderealyearAmplitudeinSeconds * Math.cos(angle)
         + meansiderealyearlengthinSeconds;
}

/**
 * Compute the length of the anomalistic year (in seconds) with Real LOD.
 *
 * @param {number} perihelionPrecession – the perihelion precession value
 * @param {number} lengthofsolarYear    – the length of the solar year (in days)
 * @returns {number} lengthofanomalisticYearRealLOD (in seconds)
 */
function computeLengthofanomalisticYearRealLOD(
  perihelionPrecession,
  lengthofsolarYear,
  lengthofDay
  ) {
  return ((perihelionPrecession * lengthofsolarYear) /
          (perihelionPrecession - 1)) * lengthofDay;
}

/**
 * Compute the axial precession.
 *
 * @param {number} lengthofsiderealYear – the length of the sidereal year (in seconds)
 * @param {number} lengthofsolarYear    – the length of the solar year (in days)
 * @returns {number} axialPrecession
 */
function computeAxialPrecession(
  lengthofsiderealYear,
  lengthofsolarYear
  ) {
  return lengthofsiderealYear /
         (lengthofsiderealYear - (lengthofsolarYear * 86400));
}

/**
 * Compute the axial precession with Real LOD.
 *
 * @param {number} lengthofsiderealYear – the length of the sidereal year (in seconds)
 * @param {number} lengthofsolarYear    – the length of the solar year (in days)
 * @param {number} lengthofDay          – number of seconds in one solar day (e.g. 86400)
 * @returns {number} axialPrecession
 */
function computeAxialPrecessionRealLOD(
  lengthofsiderealYear,
  lengthofsolarYear,
  lengthofDay
  ) {
  return lengthofsiderealYear /
         (lengthofsiderealYear - (lengthofsolarYear * lengthofDay));
}

/**
 * Compute Earth's orbital eccentricity for a given year.
 *
 * @param {number} currentYear
 * @param {number} balancedYear
 * @param {number} perihelionCycleLength
 * @param {number} eccentricityMean
 * @param {number} eccentricityAmplitude
 * @param {number} eccentricitySinusCorrection
 * @returns {number}
 */
function computeEccentricityEarth(
  currentYear,
  balancedYear,
  perihelionCycleLength,
  eccentricityMean,
  eccentricityAmplitude,
  eccentricitySinusCorrection
  ) {
  // 1. root = √(eₘ² + a²)
  const root = Math.sqrt(
    eccentricityMean * eccentricityMean +
    eccentricityAmplitude * eccentricityAmplitude
  );

  // 2. θ in radians
  const degrees = ((currentYear - balancedYear) / perihelionCycleLength) * 360;
  const θ = degrees * Math.PI / 180;

  const cosθ = Math.cos(θ);
  const absCosθ = Math.abs(cosθ);
  const signCosθ = Math.sign(cosθ);

  // 3. pull the sign out of the exponentiation
  const term1 = signCosθ * Math.pow(absCosθ, eccentricitySinusCorrection);
  const term2 =      cosθ * Math.pow(absCosθ, eccentricitySinusCorrection);

  // 4. two candidate eccentricities
  const e1 = root +
    (
      -eccentricityAmplitude +
      (eccentricityMean - root) * term1
    ) * cosθ;

  const e2 = root +
    (
      -eccentricityAmplitude +
      (eccentricityMean - root) * term2
    ) * cosθ;

  // 5. pick the branch
  return e1 > root ? e1 : e2;
}

/**
 * Compute Earth's obliquity (tilt) for a given decimal year.
 *
 * Relies on these values being in scope:
 *   - earthtiltMean                  (mean obliquity, in degrees)
 *   - tilandinclinationAmplitude  (amplitude, in degrees)
 *   - balancedYear                   (reference year for phase = 0)
 *   - holisticyearLength             (full cycle length, in years)
 *
 * @param {number} currentYear  – e.g. the decimal year from your JD→year fn
 * @returns {number}            Earth's tilt (in degrees) at that year
 */
function computeObliquityEarth(currentYear) {
  const t = currentYear - balancedYear;

  // two cycle lengths (years) for the cosine terms:
  const cycle3 = holisticyearLength / 3;
  const cycle8 = holisticyearLength / 8;

  // Convert each fractional cycle into radians:
  //    (t / cycle) * 360°  →  in radians = (t / cycle) * 2π
  const phase3 = (t / cycle3) * 2 * Math.PI;
  const phase8 = (t / cycle8) * 2 * Math.PI;

  // obliquityEarth
  //   + [–A * cos(phase3)] 
  //   + [+A * cos(phase8)]
  return earthtiltMean
       - earthInvPlaneInclinationAmplitude * Math.cos(phase3)
       + earthInvPlaneInclinationAmplitude * Math.cos(phase8);
}

/**
 * Compute Earth’s ecliptic inclination for a given year.
 *
 * @param {number} currentYear                   – the year you want to compute for
 * @param {number} balancedYear                  – the reference (“balanced”) year
 * @param {number} holisticyearLength            – length of the holistic cycle (in years)
 * @param {number} earthInvPlaneInclinationMean          – the mean inclination (in degrees)
 * @param {number} earthInvPlaneInclinationAmplitude   – amplitude of the tilt & inclination variation (in degrees)
 * @returns {number} the computed inclination (in degrees)
 */
function computeInclinationEarth(
  currentYear,
  balancedYear,
  holisticyearLength,
  earthInvPlaneInclinationMean,
  earthInvPlaneInclinationAmplitude
  ) {
  // 1. Compute cycle position in degrees
  const degrees = (
    (currentYear - balancedYear) /
    (holisticyearLength / 3)
  ) * 360;

  // 2. Convert to radians
  const radians = degrees * Math.PI / 180;

  // 3. Apply the formula
  return earthInvPlaneInclinationMean +
         (-earthInvPlaneInclinationAmplitude * Math.cos(radians));
}

/**
 * Compute a planet's dynamic inclination to the invariable plane.
 *
 * CALIBRATION APPROACH:
 * The inclination phase is derived from the ascending node position on the invariable
 * plane, since both are aspects of the same orbital plane precession. This creates a
 * physically consistent relationship between nodal precession and inclination oscillation.
 *
 * Formula: i(t) = i_J2000 + A × [cos(phase(t)) - cos(phase_J2000)]
 * Where: phase = Ω_invPlane + baseOffset + planetAdjust
 *
 * This ensures that at t=2000, the function returns exactly i_J2000.
 *
 * Scientific basis: Laplace-Lagrange secular theory
 * References:
 * - Farside physics textbook (Table 10.4): https://farside.ph.utexas.edu/teaching/celestial/Celestial/node91.html
 * - Murray & Dermott "Solar System Dynamics" (Chapter 7)
 *
 * @param {string} planet - Planet name (e.g., 'saturn')
 * @param {number} currentYear - Current simulation year
 * @returns {number} Dynamic inclination in degrees
 */
function computePlanetInvPlaneInclinationDynamic(planet, currentYear) {
  // Planet J2000 inclinations (Souami & Souchay 2012) - calibration targets
  const j2000Inclinations = {
    mercury: mercuryInvPlaneInclinationJ2000,
    venus: venusInvPlaneInclinationJ2000,
    mars: marsInvPlaneInclinationJ2000,
    jupiter: jupiterInvPlaneInclinationJ2000,
    saturn: saturnInvPlaneInclinationJ2000,
    uranus: uranusInvPlaneInclinationJ2000,
    neptune: neptuneInvPlaneInclinationJ2000,
    pluto: plutoInvPlaneInclinationJ2000
  };

  // Mean inclinations (midpoint of Laplace-Lagrange bounds)
  // These are the CENTER of the oscillation
  const meanInclinations = {
    mercury: mercuryInvPlaneInclinationMean,
    venus: venusInvPlaneInclinationMean,
    mars: marsInvPlaneInclinationMean,
    jupiter: jupiterInvPlaneInclinationMean,
    saturn: saturnInvPlaneInclinationMean,
    uranus: uranusInvPlaneInclinationMean,
    neptune: neptuneInvPlaneInclinationMean,
    pluto: plutoInvPlaneInclinationMean
  };

  // Planet inclination oscillation amplitudes (from Laplace-Lagrange secular theory)
  const amplitudes = {
    mercury: mercuryInvPlaneInclinationAmplitude,
    venus: venusInvPlaneInclinationAmplitude,
    mars: marsInvPlaneInclinationAmplitude,
    jupiter: jupiterInvPlaneInclinationAmplitude,
    saturn: saturnInvPlaneInclinationAmplitude,
    uranus: uranusInvPlaneInclinationAmplitude,
    neptune: neptuneInvPlaneInclinationAmplitude,
    pluto: plutoInvPlaneInclinationAmplitude
  };

  // Planet precession periods (same period governs nodal precession and inclination oscillation)
  const periods = {
    mercury: mercuryPerihelionICRFYears,
    venus: venusPerihelionICRFYears,
    mars: marsPerihelionICRFYears,
    jupiter: jupiterPerihelionICRFYears,
    saturn: saturnPerihelionICRFYears,  // Negative = retrograde
    uranus: uranusPerihelionICRFYears,
    neptune: neptunePerihelionICRFYears,  // Negative = retrograde
    pluto: plutoPerihelionICRFYears
  };

  // J2000 ascending nodes on invariable plane
  const ascNodesJ2000 = {
    mercury: mercuryAscendingNodeInvPlaneVerified,
    venus: venusAscendingNodeInvPlaneVerified,
    mars: marsAscendingNodeInvPlaneVerified,
    jupiter: jupiterAscendingNodeInvPlaneVerified,
    saturn: saturnAscendingNodeInvPlaneVerified,
    uranus: uranusAscendingNodeInvPlaneVerified,
    neptune: neptuneAscendingNodeInvPlaneVerified,
    pluto: plutoAscendingNodeInvPlaneVerified
  };

  // Phase offsets: the geometric relationship between Ω and the inclination phase
  // φ₀ = Ω_J2000 - offset  (where φ₀ is the inclination phase at J2000)
  const phaseOffsets = {
    mercury: mercuryInclinationPhaseAngle,
    venus: venusInclinationPhaseAngle,
    mars: marsInclinationPhaseAngle,
    jupiter: jupiterInclinationPhaseAngle,
    saturn: saturnInclinationPhaseAngle,
    uranus: uranusInclinationPhaseAngle,
    neptune: neptuneInclinationPhaseAngle,
    pluto: plutoInclinationPhaseAngle
  };

  const i_J2000 = j2000Inclinations[planet];
  const i_mean = meanInclinations[planet];
  const amplitude = amplitudes[planet];
  const period = periods[planet];
  const ascNodeJ2000 = ascNodesJ2000[planet];
  const phaseOffset = phaseOffsets[planet];

  if (i_J2000 === undefined || amplitude === undefined || period === undefined) {
    console.warn(`computePlanetInvPlaneInclinationDynamic: Unknown planet '${planet}'`);
    return i_J2000 || 0;
  }

  // For zero amplitude (e.g., Venus), just return the J2000 value
  if (amplitude === 0) {
    return i_J2000;
  }

  // Ω-based approach: Mean-centered oscillation linked to ascending node
  //
  // Formula: i(t) = mean + A × cos(Ω(t) - offset)
  //
  // where:
  //   mean = Laplace-Lagrange mean (center of oscillation)
  //   A = amplitude (half of min-max range)
  //   Ω(t) = current ascending node on invariable plane
  //   offset = geometric phase offset (Ω_J2000 - φ₀)
  //
  // The ascending node precesses with time, using balancedYear as epoch:
  //   Ω_balanced = Ω_J2000 - rate × (J2000 - balancedYear)
  //   Ω(t) = Ω_balanced + rate × (t - balancedYear)
  //
  // This ensures perfect cycle synchronization over complete Holistic Years
  // while still producing correct J2000 values for verification

  // Use balancedYear as epoch for perfect Holistic Year cycle synchronization
  // This ensures inclination values return to exactly the same values after one complete cycle
  // Calculate from JD directly using mean solar year length to avoid calendar-based drift
  const yearsSinceBalanced = (o.julianDay - balancedJD) / meansolaryearlengthinDays;

  // yearsFromBalancedToJ2000 is a pre-computed constant (defined near line 434)

  // Calculate precession rate
  const precessionRate = 360 / period;  // degrees per year (negative for retrograde)

  // Back-calculate ascending node at balancedYear from J2000 values
  const ascNodeAtBalanced = ascNodeJ2000 - precessionRate * yearsFromBalancedToJ2000;

  // Calculate current ascending node from balancedYear reference
  const ascNodeCurrent = ascNodeAtBalanced + precessionRate * yearsSinceBalanced;

  // Calculate current phase from ascending node
  const currentPhaseDeg = ascNodeCurrent - phaseOffset;
  const currentPhaseRad = currentPhaseDeg * Math.PI / 180;

  // Dynamic inclination centered on the mean
  return i_mean + amplitude * Math.cos(currentPhaseRad);
}

/**
 * Compute the longitude of perihelion for a given year.
 *
 * @param {number} currentYear                        – the year you want to compute for
 * @param {number} balancedYear                       – the reference (“balanced”) year
 * @param {number} perihelionCycleLength              – length of the perihelion cycle (in years)
 * @param {number} perihelionprecessioncycleYear      – the precession cycle year threshold
 * @param {number} helionpointAmplitude               – amplitude of the perihelion-point variation (in degrees)
 * @param {number} mideccentricitypointAmplitude      – amplitude of the mid-eccentricity-point variation (in degrees)
 * @returns {number} longitudePerihelion (in degrees)
 */
function computeLongitudePerihelion(
  currentYear,
  balancedYear,
  perihelionCycleLength,
  perihelionprecessioncycleYear,
  helionpointAmplitude,
  mideccentricitypointAmplitude
  ) {
  // 1. Determine which cycle value to use
  const delta = currentYear - balancedYear;
  const cycleValue = (delta / perihelionCycleLength) > 1
    ? delta
    : perihelionprecessioncycleYear;

  // 2. First sinusoidal term:
  //    helionpointAmplitude * sin( (cycleValue / perihelionCycleLength) * 360° )
  const angle1 = (cycleValue / perihelionCycleLength) * 360;
  const term1 = helionpointAmplitude * Math.sin(angle1 * Math.PI / 180);

  // 3. Linear drift term normalized into [0, 360):
  //    270 + delta * (360 / perihelionCycleLength)
  //    then subtract floor(.../360)*360
  const raw = 270 + delta * (360 / perihelionCycleLength);
  const term2 = raw - Math.floor(raw / 360) * 360;

  // 4. Second sinusoidal term:
  //    mideccentricitypointAmplitude * sin( (cycleValue / (perihelionCycleLength/2)) * 360° )
  const angle3 = (cycleValue / (perihelionCycleLength / 2)) * 360;
  const term3 = mideccentricitypointAmplitude * Math.sin(angle3 * Math.PI / 180);

  // 5. Sum all contributions
  return term1 + term2 + term3;
}

/**
 * Calculate the offset into the current 1/16-cycle.
 *
 * @param {number} currentYear               – e.g. your decimal year from JD
 * @param {number} balancedYear              – reference “start” of the cycle
 * @param {number} holisticyearLength        – full cycle length in years
 * @returns {number}  A value in [0, holisticyearLength/16)
 */
function yearInCycle(currentYear, balancedYear, holisticyearLength) {
  const delta       = currentYear - balancedYear;
  // Excel’s ROUNDDOWN(...,0) is truncation toward zero
  const wholeCycles = Math.trunc(delta / perihelionCycleLength);
  return delta - wholeCycles * perihelionCycleLength;
}

/**
 * Convert an astronomical Julian Date to a decimal year, using
 * the Julian calendar before 1582‐10‐15 and the Gregorian calendar thereafter.
 *
 * @param {number} jd  Astronomical Julian Date (can include fractional days).
 * @returns {number}   Decimal year (e.g. 1999.1234).
 */
function julianDateToDecimalYear(jd) {
  // 1) Compute intermediate values
  const J = jd + 0.5;
  const Z = Math.floor(J);
  const F = J - Z;

  // 2) Decide which calendar to use
  //    The switch happens at JD = 2299160.5 (1582-10-15 00:00 UTC)
  let A = Z;
  if (Z >= 2299161) {
    const alpha = Math.floor((Z - 1867216.25) / 36524.25);
    A = Z + 1 + alpha - Math.floor(alpha / 4);
  }

  // 3) Convert to calendar date (year, month, day.fraction)
  const B = A + 1524;
  const C = Math.floor((B - 122.1) / 365.25);
  const D = Math.floor(365.25 * C);
  const E = Math.floor((B - D) / 30.6001);

  const day = B - D - Math.floor(30.6001 * E) + F;
  const month = (E < 14) ? E - 1 : E - 13;
  const year  = (month > 2) ? C - 4716 : C - 4715;

  // 4) Figure out day‐of‐year, including the fractional part
  //    Build month lengths array according to the calendar in use
  const isGregorian = (Z >= 2299161);
  const isLeap = isGregorian
    ? (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0))
    : (year % 4 === 0);

  const monthLengths = [31, isLeap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  let dayOfYear = day;
  for (let m = 0; m < month - 1; m++) {
    dayOfYear += monthLengths[m];
  }

  // 5) Compute decimal year
  const daysInYear = isLeap ? 366 : 365;
  // At Jan 1 00:00 → dayOfYear = 1 → fraction = 0 → decimalYear = year
  const decimalYear = year + (dayOfYear - 1) / daysInYear;

  return decimalYear;
}

function makeRealisticEarth(pd){

    /* ------------------------------------------------ geometry -------- */
    const radius   = pd.size;
    const segments = 128;
    const geom     = new THREE.SphereGeometry(radius, segments, segments);

    /* ------------------------------------------------ textures -------- */
    const TL = new THREE.TextureLoader().setCrossOrigin('anonymous');
    const tex = {
        dayPostLGM  : TL.load("https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/Earth.jpg"),
        dayLGM      : TL.load("https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/EarthLGM.png"),
        niteModern  : TL.load("https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/EarthNight.png"),
        niteClassic : TL.load("https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/EarthNightClassic.png"),
        norm        : TL.load("https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/EarthNormal.png"),
        spec        : TL.load("https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/EarthSpecular.png"),
        cloud       : TL.load("https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/earthcloudmap.png"),
    };
  
    // ----- colour-space assignment  ----------------------------------
    tex.dayPostLGM.colorSpace  = THREE.NoColorSpace;
    tex.dayLGM.colorSpace      = THREE.NoColorSpace;
    tex.niteModern.colorSpace  = THREE.SRGBColorSpace;
    tex.cloud.colorSpace       = THREE.SRGBColorSpace;
    tex.niteClassic.colorSpace = THREE.SRGBColorSpace;
    tex.norm.colorSpace        = THREE.NoColorSpace;
    tex.spec.colorSpace        = THREE.NoColorSpace;

    /* ------------------------------------------------ shared uniforms - */
    const U = {
        /* DAY -------- */
        u_dayTexA : { value: tex.dayLGM      },   // before the change-over
        u_dayTexB : { value: tex.dayPostLGM  },   // after   the change-over
        u_dayMix  : { value: 0.0 },               // 0 → A, 1 → B

        /* NIGHT ------ */
        u_niteTexA : { value: tex.niteClassic },
        u_niteTexB : { value: tex.niteModern  },
        u_niteMix  : { value: 0.0 },
   
        u_normalTexture  : { value: tex.norm },
        u_specTexture    : { value: tex.spec },
        u_cloudTexture   : { value: tex.cloud },     // <-- NEW
        u_sunRelPosition : { value: new THREE.Vector3() },
        u_normalPower    : { value: 1.0 },          // 1 = original, >1 exaggerates bumps
        u_dayGain        : { value: 1.5 },          // Day brighter
        u_alpha          : { value: 0.7 },          // <-- NEW  (0-1 cloud opacity)
        u_termWidth      : { value: 0.08 },          // width in hemi-space (0 < w ≤ 1)
        u_iceGlowStrength : { value: 0.05 },
        u_nightCloudFactor : { value: 0.3 },
        u_position       : { value: new THREE.Vector3() }
    };

    /* ------------------------------------------------ core ------------ */
    const coreMat = new THREE.ShaderMaterial({
        uniforms      : U,
        vertexShader  : EARTH_VERT,
        fragmentShader: EARTH_FRAG
    });
    coreMat.extensions.derivatives = true;

    const core = new THREE.Mesh(geom, coreMat);
    core.material.depthWrite = true;
  
    core.castShadow    = true;        // (you probably set this elsewhere)
    core.receiveShadow = false;       // <— let the shell handle darkening

    /* ───────────────── Shadow-receiver shell ────────────────── */
    const shellGeom = new THREE.SphereGeometry(radius * 1.01, 64, 64);
    const shellMat  = new THREE.ShadowMaterial({
      opacity: 1.0          // 0 = invisible, 1 = pitch-black; tweak to taste
    });
    const shadowShell = new THREE.Mesh(shellGeom, shellMat);

    shadowShell.receiveShadow = true; // darken where the shadow map says so
    shadowShell.castShadow    = false;/* planet already casts its own shadow */
  
    /* ------------------------------------------------ clouds ---------- */
    const cloudMat = new THREE.ShaderMaterial({
        uniforms      : U,    // reuse; contains all needed uniforms now
        vertexShader  : EARTH_VERT,
        fragmentShader: CLOUD_FRAG,
        transparent   : true,
        depthWrite    : false
    });

    const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(radius * 1.02, segments, segments),
        cloudMat
    );
    clouds.rotationAutoUpdate = false;      // we spin it ourselves

    /* ------------------------------------------------ atmosphere ------ */
    const atm = new THREE.Mesh(
        new THREE.SphereGeometry(radius * 1.05, segments, segments),
        new THREE.ShaderMaterial({
            uniforms      : { u_sunRelPosition: U.u_sunRelPosition },
            vertexShader  : ATM_VERT,
            fragmentShader: ATM_FRAG,
            transparent   : true,
            side          : THREE.BackSide,
            depthWrite    : false
        })
    );

    /* ------------------------------------------------ container ------- */
    const container = new THREE.Object3D();
    core.add(clouds);                        // clouds follow core spin 1-to-1
    container.add(core, atm, shadowShell);   // atmosphere can stay a sibling

    /* ------------------------------------------------ helpers --------- */
    function updateSunDir(sunObj){
        tmp1.copy(sunObj.getWorldPosition(tmp2))
            .sub(core.getWorldPosition(tmp3));      // Earth → Sun
        U.u_sunRelPosition.value.copy(tmp1);
    }
  
    const DRIFT_DEG_PER_SEC = 0.7;                 // 0.1 °/s  ≈ 1 °/10 s
    const DRIFT_RATE        = THREE.MathUtils.degToRad(DRIFT_DEG_PER_SEC);

    function updateClouds(deltaTime = 0.016){       // seconds
        clouds.rotation.y += deltaTime * DRIFT_RATE * o.speed;
    }
  
    // ------------------------------------------------ era / map switcher -- 
    const JD_NIGHT_BOUNDARY = 2305620;   // first lit cities
    const JD_DAY_BOUNDARY   = -5756193;  // End of LGM with max inclination of 2.05831717
    const TRANSITION_DAYS   = 109572;    // length of the fade

    function updateEra(julianDay = o.julianDay) {

    // night side (Classic ➜ Modern)
      let t = (julianDay - JD_NIGHT_BOUNDARY) / TRANSITION_DAYS;
      U.u_niteMix.value = THREE.MathUtils.clamp(t, 0, 1);
      // or:  U.u_niteMix.value = THREE.MathUtils.smoothstep(0, 1, t);

      // day side (LGM ➜ Post-LGM)
      t = (julianDay - JD_DAY_BOUNDARY) / TRANSITION_DAYS;
      U.u_dayMix.value = THREE.MathUtils.clamp(t, 0, 1);
    }

    U.u_position.value.copy(core.position);

    return {
        container,
        coreMesh          : core,
        updateSunDir,
        updateClouds,
        updateEra
    };
}

function createPlanet(pd) {           // pd = Planet Data

  /*  ───────────────────────── orbit container  ─────────── */
  const orbitContainer = new THREE.Object3D();
  orbitContainer.rotation.x = pd.orbitTilta * Math.PI/180;
  orbitContainer.rotation.z = pd.orbitTiltb * Math.PI/180;
  orbitContainer.position.set(pd.orbitCentera, pd.orbitCenterc, pd.orbitCenterb);

  /*  Orbit ellipse ---------------------------------------------------- */
  const orbit      = new THREE.Object3D();
  const pts        = [];
  const segs       = 100;
  const a          = pd.orbitSemiMajor ?? pd.orbitRadius;
  const b          = pd.orbitSemiMinor ?? pd.orbitRadius;
  pd.a = a; pd.b = b; 

  for (let i=0;i<=segs;i++){
    const t = i/segs * Math.PI*2;
    pts.push( new THREE.Vector3(Math.cos(t)*a, Math.sin(t)*b, 0) );
  }
  const orbitGeom  = new THREE.BufferGeometry().setFromPoints(pts);
  const orbitMat   = new THREE.LineBasicMaterial({ color: pd.color, transparent:true, opacity:0.4 });
  const orbitLine  = new THREE.LineLoop(orbitGeom, orbitMat);
  orbitLine.rotation.x = Math.PI/2;
  orbit.add(orbitLine);

  /*  Pivot & rotation axis ------------------------------------------- */
  const pivot         = new THREE.Object3D();
  pivot.position.set(a,0,0);
  orbit.add(pivot);

  const rotationAxis  = new THREE.Object3D();
  rotationAxis.position.copy(pivot.position);
  rotationAxis.rotation.z = pd.tilt  * Math.PI/180;
  if (pd.tiltb) rotationAxis.rotation.x = pd.tiltb * Math.PI/180;

  /*  ---------- EARTH gets its own shader-driven mesh ---------- */
  let planetMesh;
  if (pd.name === "Earth") {
  const earthPack = makeRealisticEarth(pd);
  rotationAxis.add(earthPack.container);
  
  earthPack.coreMesh.castShadow    = true;
  earthPack.coreMesh.receiveShadow = true;
    
  /* preserve your world-access references so nothing else breaks */
  pd.planetObj         = earthPack.coreMesh;
  pd.planetMaterial    = earthPack.coreMesh.material;
  pd._updateSunDirFunc = earthPack.updateSunDir;
  pd._updateCloudsFunc = earthPack.updateClouds;
  pd._updateEraFunc    = earthPack.updateEra;
    
  } else {
    /*  ---------- all other planets  ---------- */
    let materialOpts = {};

    if (pd.textureUrl){
      const tex = loadTexture(pd.textureUrl);
      materialOpts.map       = tex;
      materialOpts.bumpScale = 0.05;
      materialOpts.specular  = new THREE.Color("#190909");
      if (pd.textureTransparency){
        materialOpts.transparent = true;
        materialOpts.opacity     = pd.textureTransparency;
      }
    } else {
      materialOpts.color = pd.color;
    }

    if (pd.emissive || pd.planetColor){
      materialOpts.emissive          = pd.planetColor || pd.color;
      materialOpts.emissiveIntensity = 2;
    }

    const planetMat     = new THREE.MeshPhongMaterial(materialOpts);
    const segsSphere    = pd.sphereSegments || 32;
    const sphereGeom    = new THREE.SphereGeometry(pd.size, segsSphere, segsSphere);
    planetMesh          = new THREE.Mesh(sphereGeom, planetMat);

    /*  Exclusions for shadows  */
    if (pd.isNotPhysicalObject === true) {
      /* … your ghost-helper code … */
      planetMesh.castShadow    = false;
      planetMesh.receiveShadow = false;

    /* +++++ Sun exception +++++++++++++++++++++++++++++++++++ */
    } else if (pd.name === 'Sun') {
      planetMesh.castShadow    = false; 
      planetMesh.receiveShadow = false;
      planetMesh.material.depthWrite = false;
    /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

    } else {
      /* normal physical bodies */
      planetMesh.castShadow    = true;
      planetMesh.receiveShadow = true;
    }
    
    if (pd.isNotPhysicalObject === true){
      if (pd.textureUrl){
        const tex = loadTexture(pd.textureUrl);
        planetMesh.material = new THREE.MeshBasicMaterial({
          map: tex, color: 0x777777,
          transparent: !!pd.textureTransparency,
          opacity: pd.textureTransparency || 1.0
        });
      }
    }

    pd.planetMaterial = planetMat;             // keep reference for GUI
    pd.planetObj      = planetMesh;
  }

  /*  ---------- rest of helpers (rings, helpers, etc.) --- */
  if (planetMesh) {
  rotationAxis.add(planetMesh);
  }

  /* optional ring system */
  if (pd.ringUrl){
    new THREE.TextureLoader().load(pd.ringUrl, tex=>{
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.generateMipmaps = false;
      tex.minFilter = THREE.LinearFilter;
      tex.center.set(0.5,0.5);

      const ring = createRings({
        ringSize   : pd.ringSize,
        innerMult  : pd.ringInnerMult,
        outerMult  : pd.ringOuterMult,
        segments   : pd.ringSegments || 256,
        texture    : tex,
        opacity    : pd.ringOpacity ?? 0.6
      });

      rotationAxis.add(ring);
      pd.ringObj = ring;
    });
  }

  orbit.add(rotationAxis);
  orbitContainer.add(orbit);

  /* helpers, axis, traces -------------------- */
  pd.orbitPlaneHelper = addOrbitPlaneHelper(pd, orbitContainer, o.starDistance*2);
  pd.orbitPlaneHelper.visible = false;

  if (pd.axisHelper){
    const ax = new THREE.AxesHelper(pd.size*3);
    planetMesh.add(ax);
    pd.axisHelperObj = ax;
  }

  /* save graph references exactly as before --------------------------- */
  pd.containerObj  = orbitContainer;
  pd.orbitObj      = orbit;
  pd.orbitLineObj  = orbitLine;
  pd.pivotObj      = pivot;
  pd.rotationAxis  = rotationAxis;

  /* console log (when needed) */
  //if (!/Barycenter|Precession|Cycle|Ellipse/i.test(pd.name)) {
  //  console.log(`Created planet: ${pd.name}`);
  //}

  scene.add(orbitContainer);
}

/**
 * Build a planetary ring mesh.
 *
 * @param {number} ringSize      – base radius in scene units (your old pd.ringSize)
 * @param {number} innerMult     – multiply ringSize for inner edge (e.g. 1.23)
 * @param {number} outerMult     – multiply ringSize for outer edge (e.g. 2.27)
 * @param {number} segments      – radial subdivisions (default 256)
 * @param {THREE.Texture} texture
 * @param {number} opacity       – 0-1, how faint / dusty
 */
function createRings({
  ringSize,
  innerMult,
  outerMult,
  segments = 256,
  texture,
  opacity = 0.6
}) {
  const innerR = innerMult * ringSize;
  const outerR = outerMult * ringSize;

  const geometry = new THREE.RingGeometry(
        innerR, outerR, segments, 5, 0, Math.PI * 2);

  /* ------------ fix UVs so the texture wraps nicely ------------ */
  const { position: pos, uv: uvs } = geometry.attributes;
  for (let i = 0; i < uvs.count; i++) {
    const x = pos.getX(i), y = pos.getY(i);
    const u = (Math.atan2(y, x) + Math.PI) / (2 * Math.PI);   // 0‒1 sweep
    const v = (Math.hypot(x, y) - innerR) / (outerR - innerR); // ring width
    uvs.setXY(i, u, v);
  }
  uvs.needsUpdate = true;

  const material = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    side: THREE.DoubleSide,
    opacity
  });

  const ring = new THREE.Mesh(geometry, material);
  ring.rotation.x = -Math.PI / 2;   // lie flat in the orbital plane
  return ring;
}

function createCelestialSphere(radius) {
  const geometry1 = new THREE.SphereGeometry( radius, 40, 40 );
  const material1 = new THREE.MeshNormalMaterial( { transparent: true, wireframe: false, opacity: 0 , depthWrite: false} );
  const mesh1 = new THREE.Mesh( geometry1, material1 );
  const edgesGeometry = new THREE.EdgesGeometry( geometry1 );
  const wireframe = new THREE.LineSegments( edgesGeometry, new THREE.LineBasicMaterial( { color: 0x666666, transparent: true, opacity: 0.3 } ) );
  wireframe.add(new THREE.PolarGridHelper( radius, 4, 1, 60, 0x0000ff, 0x0000ff ));

  mesh1.add( wireframe );
  mesh1.wireFrameObj = wireframe;
  return mesh1;
}

function showHideObject(obj) {
    obj.orbitLineObj.visible = obj.visible;
    if (obj.planetObj) {
       obj.planetObj.visible = obj.visible;
       }
    if (obj.axisHelper) {
      if (obj.visible) {
        obj.axisHelper.visible = o['Axis helpers']
      } else {
        obj.axisHelper.visible = obj.visible;                       
      }
    }  
    if (obj.ringObj) {
    obj.ringObj.visible = obj.visible;
  }
}

function showHideAxisHelpers() {
  planetObjects.forEach(obj => {
    if (obj.axisHelper) {
      obj.axisHelper.visible = o['Axis helpers'];
    }  
  });
}

function showHideOrbits() {
  planetObjects.forEach(obj => {
    if (obj.orbitLineObj && !obj.isNotPhysicalObject) {
       if (obj.visible) {
        obj.orbitLineObj.visible = o['Orbits'];
       }
    }  
  });
}

function randomPointInSphere(radius) {
  const v = new THREE.Vector3();
  let x, y, z, normalizationFactor;

  do {
    x = THREE.MathUtils.randFloat(-1, 1);
    y = THREE.MathUtils.randFloat(-1, 1);
    z = THREE.MathUtils.randFloat(-1, 1);
    normalizationFactor = Math.sqrt(x * x + y * y + z * z);
  } while (normalizationFactor === 0); // retry if all zero

  normalizationFactor = 1 / normalizationFactor;

  v.x = x * normalizationFactor * radius;
  v.y = y * normalizationFactor * radius;
  v.z = z * normalizationFactor * radius;

  return v;
}

function createStarfield() {  
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const colors = [];

  for (let i = 0; i < 100000; i++) {
    const vertex = randomPointInSphere(1000000);
    positions.push(vertex.x, vertex.y, vertex.z);

    // Generate random star temperature (Kelvin range for stars)
    const tempK = THREE.MathUtils.randFloat(2000, 10000);
    const color = colorTemperature2rgb(tempK);

    // Convert to 0–255 RGB integers
    const r = Math.round(color.r * 255);
    const g = Math.round(color.g * 255);
    const b = Math.round(color.b * 255);

    const rgbValues = [r, g, b]; // Same as what match() would have given

    // Normalize to 0..1 for Three.js colors
    colors.push(parseInt(rgbValues[0]) / 255, parseInt(rgbValues[1]) / 255, parseInt(rgbValues[2]) / 255);
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

  const material = new THREE.PointsMaterial({
    size: 0.05,
    vertexColors: true // or THREE.VertexColors (deprecated in newer versions)
  });

  const particles = new THREE.Points(geometry, material);
  scene.add(particles);
}

function setStarDistance() {
  stars.forEach(obj => {
    obj.starObj.position.x = obj.dist * o['Star distance'];
  })
}

function getCircularText(
  text, diameter, startAngle, align, textInside, inwardFacing, 
  fName, fSize, kerning
  ) {
    align = align.toLowerCase();
    const mainCanvas = document.createElement('canvas');
    const resolutionFactor = 3;
    const ctxRef = mainCanvas.getContext('2d');
    const clockwise = align === "right" ? 1 : -1;
    startAngle = startAngle * (Math.PI / 180);
    
    // Font height measurement
    const div = document.createElement("div");
    div.innerHTML = text;
    div.style.position = 'absolute';
    div.style.top = '-10000px';
    div.style.left = '-10000px';
    div.style.fontFamily = fName;
    div.style.fontSize = fSize;
    div.style.fontWeight = 'bold';
    document.body.appendChild(div);
    const textHeight = div.offsetHeight;
    document.body.removeChild(div);

    if (!textInside) diameter += textHeight * 2;

    const canvasSize = diameter * resolutionFactor;
    mainCanvas.width = canvasSize;
    mainCanvas.height = canvasSize;

    ctxRef.scale(resolutionFactor, resolutionFactor);
    ctxRef.translate(diameter / 2, diameter / 2);
    ctxRef.font = `bold ${fSize} ${fName}`;
    ctxRef.fillStyle = '#ffffff';
    ctxRef.textBaseline = 'middle';
    ctxRef.textAlign = 'center';
    ctxRef.shadowColor = 'black';
    ctxRef.shadowBlur = 4;

    if (((["left", "center"].includes(align)) && inwardFacing) || (align == "right" && !inwardFacing)) {
        text = text.split("").reverse().join("");
    }

    startAngle += (Math.PI * !inwardFacing);

    if (align == "center") {
        for (let j = 0; j < text.length; j++) {
            const charWid = ctxRef.measureText(text[j]).width;
            startAngle += ((charWid + (j === text.length - 1 ? 0 : kerning)) / (diameter / 2 - textHeight)) / 2 * -clockwise;
        }
    }

    ctxRef.rotate(startAngle);

    for (let j = 0; j < text.length; j++) {
        const charWid = ctxRef.measureText(text[j]).width;
        ctxRef.rotate((charWid / 2) / (diameter / 2 - textHeight) * clockwise);
        ctxRef.fillText(text[j], 0, (inwardFacing ? 1 : -1) * (0 - diameter / 2 + textHeight / 2));
        ctxRef.rotate((charWid / 2 + kerning) / (diameter / 2 - textHeight) * clockwise);
    }
  
  return mainCanvas;
}

function colorTemperature2rgb(kelvin) {
  let temperature = kelvin / 100.0;
  let red, green, blue;

  // Calculate red
  if (temperature < 66.0) {
    red = 255;
  } else {
    let t = temperature - 55.0;
    red = 351.97690566805693 + 0.114206453784165 * t - 40.25366309332127 * Math.log(t);
    red = Math.min(Math.max(red, 0), 255);
  }

  // Calculate green
  if (temperature < 66.0) {
    let t = temperature - 2;
    green = -155.25485562709179 - 0.44596950469579133 * t + 104.49216199393888 * Math.log(t);
  } else {
    let t = temperature - 50.0;
    green = 325.4494125711974 + 0.07943456536662342 * t - 28.0852963507957 * Math.log(t);
  }
  green = Math.min(Math.max(green, 0), 255);

  // Calculate blue
  if (temperature >= 66.0) {
    blue = 255;
  } else if (temperature <= 20.0) {
    blue = 0;
  } else {
    let t = temperature - 10;
    blue = -254.76935184120902 + 0.8274096064007395 * t + 115.67994401066147 * Math.log(t);
    blue = Math.min(Math.max(blue, 0), 255);
  }

  // Return as THREE.Color (normalized to [0, 1] range)
  return new THREE.Color(red / 255, green / 255, blue / 255);
}

/* -----------------------------------------------------------------
   Ecliptic longitude ➜ calendar date *with time*  (±1 s accuracy)
   – uses the dateTimeToJulianDay() + dayToDateNew()
   – ONLY valid for roughly 1000 AD … 2500 AD (But according to Theory from 4000 BC to 4000 AD)
------------------------------------------------------------------ */

/* Meeus – Sun’s true longitude  ---------------------------------- */
function solarLongitudeDeg(JD){
  const T  = (JD - 2451545.0) / 36525;
  const L0 = 280.46646 + 36000.76983*T + 0.0003032*T*T;
  const M  = 357.52911 + 35999.05029*T - 0.0001537*T*T;
  const C  = (1.914602 - 0.004817*T - 0.000014*T*T)*Math.sin(M*DEG) +
             (0.019993 - 0.000101*T)*Math.sin(2*M*DEG) +
              0.000289*Math.sin(3*M*DEG);
  return (L0 + C) % 360;
}

/**
 * Convert an ecliptic longitude to an exact civil date-time.
 *
 * @param {number} lonDeg        – true solar longitude (deg, any real number)
 * @param {number} [currentYear] – civil year; may be fractional (e.g. 2025.37)
 *                                 If omitted or non-finite, the function
 *                                 uses Math.floor(o.currentYear) when that
 *                                 is finite, otherwise the computer’s UTC year.
 * @returns {string}  "YYYY-MM-DD hh:mm:ss"
 */
function longitudeToDateTime(lonDeg, currentYear) {

  /* 1 — validate & normalise longitude --------------------------------- */
  lonDeg = Number(lonDeg);
  if (!Number.isFinite(lonDeg)) {
    throw new TypeError(
      `longitudeToDateTime: first argument must be a finite number, got ${lonDeg}`
    );
  }
  lonDeg = ((lonDeg % 360) + 360) % 360;      // wrap −∞…∞ → 0–360

  /* 2 — decide which civil year to use --------------------------------- */
  let yr = Number.isFinite(currentYear)
           ? Math.floor(currentYear)
           : (Number.isFinite(o.currentYear)
                ? Math.floor(o.currentYear)
                : new Date().getUTCFullYear());

  /* 3 — crude day-of-year guess (linear anchors) ----------------------- */
  const anchorLon = [  0,  90, 180, 270, 360];
  const anchorDOY = [ 79, 172, 266, 355, 444];   // mean dates in non-leap year
  let i = 0;
  while (lonDeg >= anchorLon[i + 1]) i++;
  const f   = (lonDeg - anchorLon[i]) / 90;
  const doy = anchorDOY[i] + f * (anchorDOY[i + 1] - anchorDOY[i]);

  /* 4 — JD at 00:00 UTC, 1 Jan of chosen year -------------------------- */
  let JD = dateTimeToJulianDay(`${yr}-01-01`, '00:00:00') + doy;

  /* 5 — Newton iterations to refine JD to the exact longitude ---------- */
  const dλdT = 360/meansolaryearlengthinDays;                     // mean solar motion °/day
  for (let k = 0; k < 8; k++) {
    const λ = solarLongitudeDeg(JD);
    if (λ === null) return "no formula";
    const diff = ((λ - lonDeg + 540) % 360) - 180;   // signed −180…+180
    if (Math.abs(diff) < 1e-8) break;                // ~0.00001 °
    JD -= diff / dλdT;
  }

  /* 6 — JD → calendar date-time via your helper ------------------------ */
  const { date, time } = dayToDateNew(
    JD,
    'julianday',
    'julian-gregorian-calendar'
  );

  return `${date} ${time}`;
}

/**
 * Check whether a given day (JD or Perihelion-day) falls on a
 * Perihelion-calendar “cycle” date: Year % cycleYears === 0, Month=1, Day=1.
 *
 * @param {number} day           — input day count (JD if julianday, or perihelion-day)
 * @param {'julianday'|'perihelionday'} inputKind
 * @param {number} cycleYears    — length of one cycle in Perihelion years (default 19122)
 * @returns {boolean}
 */
function isPerihelionCycle(day, inputKind, cycleYears = (holisticyearLength/16)) {
  // 1) get the Perihelion‐calendar date
  const p = dayToDateNew(day, inputKind, 'perihelion-calendar');
  // p.date is "YYYY-MM-DD" or "-YYYY-MM-DD"
  
  // 2) extract Y/M/D via regex
  const m = /^(-?\d+)-(\d{2})-(\d{2})$/.exec(p.date);
  if (!m) {
    console.warn('Unexpected perihelion date format:', p.date);
    return false;
  }
  const year  = parseInt(m[1], 10);
  const month = parseInt(m[2], 10);
  const dayOfM= parseInt(m[3], 10);

  // 3) check for Jan 1 of a positive multiple of cycleYears
  return (
    month === 1 &&
    dayOfM === 1 &&
    year > 0 &&
    year % cycleYears === 0
  );
}

function triggerPerihelionEasterEgg() {
  // a) Play your chime
  //const audio = new Audio('sounds/celestial-chime.mp3');
  //audio.play();

  // b) Golden glow: animate a bloom post-process or add a sprite/ Needs Bloompass addpass
  //addGoldenGlow(); 

  // c) Cosmic confetti: particle system of little star/comet sprites
  addConfettiParticles( camera.position.distanceTo(scene.position) );
}

function addConfettiParticles(spawnRadius = 5) {
  const geom = new THREE.BufferGeometry();
  const count = 200;
  const pos = new Float32Array(count * 3);
  for (let i = 0; i < count; i++) {
    // random direction in a sphere
    const v = new THREE.Vector3(
      (Math.random()*2-1),
      (Math.random()*2-1),
      (Math.random()*2-1)
    ).normalize().multiplyScalar(spawnRadius);
    pos.set([v.x, v.y, v.z], i*3);
  }
  geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.1,
    map: loadTexture('https://raw.githubusercontent.com/dvansonsbeek/3d/master/public/lensflare2.png'),
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });
  const pts = new THREE.Points(geom, mat);
  scene.add(pts);

  // animate them shooting outward and fading
  new TWEEN.Tween({ t: 0 })
    .to({ t: 1 }, 3000)
    .onUpdate(({ t }) => {
      geom.attributes.position.array.forEach((_, idx, arr) => {
        arr[idx] *= 1 + 2 * (t);  // move outward
      });
      geom.attributes.position.needsUpdate = true;
      mat.opacity = 1 - t;
    })
    .onComplete(() => {
      scene.remove(pts);
      geom.dispose(); mat.dispose();
    })
    .start();
}

function addGoldenGlow() {
  const initial = bloomPass.strength;
  new TWEEN.Tween({ str: initial })
    .to({ str: initial * 2 }, 1000)
    .yoyo(true)
    .repeat(1)
    .onUpdate(({ str }) => bloomPass.strength = str)
    .start();
}

// helper
function isPowerOfTwo(v) {
  return (v & (v - 1)) === 0;
}

//*************************************************************
// RA and Degree Functions
//*************************************************************
  
// === RA and Dec Conversions ===
function raToRadians(raStr) {
  if (typeof raStr !== 'string') {
    console.warn('raToRadians expected a string but got', typeof raStr);
    return 0;
  }

  raStr = raStr.trim().replace(/\s+/g, ''); // Remove all internal whitespace

  // Match formats like: "23h20m38.2s"
  let match1 = raStr.match(/^(\d+)h(\d+)m([\d.]+)s$/);
  if (match1) {
    let [ , hh, mm, ss ] = match1;
    hh = parseFloat(hh);
    mm = parseFloat(mm);
    ss = parseFloat(ss);
    const degrees = (hh + mm / 60 + ss / 3600) * 15;
    return degrees * (Math.PI / 180);
  }

  // Match colon-separated format: "23:20:38.2"
  let match2 = raStr.match(/^(\d+):(\d+):([\d.]+)$/);
  if (match2) {
    let [ , hh, mm, ss ] = match2;
    hh = parseFloat(hh);
    mm = parseFloat(mm);
    ss = parseFloat(ss);
    const degrees = (hh + mm / 60 + ss / 3600) * 15;
    return degrees * (Math.PI / 180);
  }

  console.warn('Unrecognized RA format:', raStr);
  return 0;
}

function radiansToRa(rad) {
  if (rad < 0) rad += 2 * Math.PI;

  const totalHours = rad * 12 / Math.PI;
  const hh = Math.floor(totalHours);
  const mm = Math.floor((totalHours - hh) * 60);
  const ss = Math.round(((totalHours - hh) * 60 - mm) * 60);

  return (
    String(hh).padStart(2, '0') + 'h' +
    String(mm).padStart(2, '0') + 'm' +
    String(ss).padStart(2, '0') + 's'
  );
}

function decToRadians(decStr) {
  if (typeof decStr !== 'string') {
    console.warn('decToRadians expected a string but got', typeof decStr);
    return 0;
  }

  decStr = decStr.trim().replace(/\s+/g, ''); // Remove all internal whitespace

  // Match formats like: "+23°44′25″" or "-12°30′15.5″"
  let match1 = decStr.match(/^(-?\+?\d+)°(\d+)′([\d.]+)″$/);
  if (match1) {
    let [ , deg, min, sec ] = match1;
    deg = parseFloat(deg);
    min = parseFloat(min);
    sec = parseFloat(sec);
    const sign = Math.sign(deg);
    const absDeg = Math.abs(deg) + min / 60 + sec / 3600;
    return sign * absDeg * (Math.PI / 180);
  }

  // Match colon-separated format: "+23:44:25.2"
  let match2 = decStr.match(/^(-?\+?\d+):(\d+):([\d.]+)$/);
  if (match2) {
    let [ , deg, min, sec ] = match2;
    deg = parseFloat(deg);
    min = parseFloat(min);
    sec = parseFloat(sec);
    const sign = Math.sign(deg);
    const absDeg = Math.abs(deg) + min / 60 + sec / 3600;
    return sign * absDeg * (Math.PI / 180);
  }

  console.warn('Unrecognized declination format:', decStr);
  return 0;
}

function radiansToDec(rad) {
  // Convert spherical phi to standard declination (0 at equator, ±90 at poles)
  rad = (rad <= 0) ? rad + Math.PI / 2 : Math.PI / 2 - rad;
  let degDec = rad * 180 / Math.PI;

  const sign = degDec < 0 ? '-' : '+';
  degDec = Math.abs(degDec);

  const degrees = Math.floor(degDec);
  const minutes = Math.floor((degDec - degrees) * 60);
  const seconds = Math.round(((degDec - degrees) * 60 - minutes) * 60);

  return (
    sign +
    String(degrees).padStart(2, '0') + '°' +
    String(minutes).padStart(2, '0') + "'" +
    String(seconds).padStart(2, '0') + '"'
  );
}

function radiansToDecDecimal(rad) {
  rad = (rad <= 0) ? rad + Math.PI / 2 : Math.PI / 2 - rad;
  return (rad * 180 / Math.PI).toFixed(4);
}

/**
 * raToDeg                                           v2 · MIT
 * ---------------------------------------------------------
 * Convert Right Ascension → ecliptic longitude (degrees)
 *
 * Accepts …
 *   •  "12h34m56.7s"
 *   •  "12:34:56.7"
 *   •  "12 34 56.7"
 *   •  "12.5824h"           (decimal hours)
 *   •  12.5824             ← number ⇒ decimal hours
 *   •  "189.785°" / "189.785 deg"
 *   •  189.785              ← number ≥ 24 ⇒ degrees
 *
 * Throws TypeError on anything it can’t parse.
 * Always returns a finite number 0 ≤ λ < 360
 */
function raToDeg(ra) {
  /* 0 — blank & NaN guards -------------------------------------------- */
  if (ra == null || (typeof ra === 'string' && !ra.trim())) {
    throw new TypeError('raToDeg: value is blank or nullish');
  }

  /* 1 — purely numeric input ------------------------------------------ */
  if (typeof ra === 'number') {
    if (!Number.isFinite(ra)) {
      throw new TypeError(`raToDeg: number is not finite: ${ra}`);
    }
    // 0–24  ⇒ hours,  others ⇒ degrees
    return ((ra < 24 ? ra * 15 : ra) % 360 + 360) % 360;
  }

  /* 2 — normalise string ---------------------------------------------- */
  const s = ra.trim().toLowerCase();

  /* 2a — explicit degree string (“deg” or “°”) ------------------------ */
  if (/[°d]/.test(s)) {
    const deg = parseFloat(s.replace(/[^\d.+-eE]/g, ''));
    if (!Number.isFinite(deg)) {
      throw new TypeError(`raToDeg: cannot parse degree string: "${ra}"`);
    }
    return ((deg % 360) + 360) % 360;
  }

  /* 2b — split into [h, m, s] ----------------------------------------- */
  const parts = s
    .replace(/[hms]/g, ' ')
    .replace(/:/g, ' ')
    .split(/\s+/)
    .filter(Boolean)
    .map(Number);

  if (parts.some(n => !Number.isFinite(n))) {
    throw new TypeError(`raToDeg: cannot parse RA string: "${ra}"`);
  }

  const [h, m = 0, sec = 0] = parts;

  /* Accept decimal-hour forms like "12.345" or "12.345h" -------------- */
  if (parts.length === 1) {
    if (h < 0) throw new RangeError(`raToDeg: negative hour value: "${ra}"`);
    return ((h * 15) % 360 + 360) % 360;
  }

  /* ---- validation (only negatives are forbidden) -------------------- */
  if (h < 0 || m < 0 || sec < 0) {
    throw new RangeError(`raToDeg: negative H M S value: "${ra}"`);
  }

  /* ---- convert, allowing overflow ----------------------------------- */
  const totalHours = h + m / 60 + sec / 3600;   // 60 s ⇒ +1 min, 60 min ⇒ +1 h
  return ((totalHours * 15) % 360 + 360) % 360; // wrap to 0–360°
}

// === Utilities ===
/** return a colour brightened toward white by `f` (0–1) */
function brighten(hex, f = 0.5) {
  const r = ((hex >> 16) & 0xff) + f * (0xff - ((hex >> 16) & 0xff));
  const g = ((hex >>  8) & 0xff) + f * (0xff - ((hex >>  8) & 0xff));
  const b = ( hex        & 0xff) + f * (0xff - ( hex        & 0xff));
  return (Math.round(r) << 16) | (Math.round(g) << 8) | Math.round(b);
}

function addInfoButton ( ctrl, url ) {
  const labelEl =
        ctrl.$name ||                                        // lil-gui
        ( ctrl.domElement &&                                 // dat.gui ≥0.7
          ctrl.domElement.querySelector('.property-name') ) ||
        ( ctrl.__li &&
          ctrl.__li.querySelector('.property-name') );

  if ( !labelEl || labelEl.querySelector('.gui-info') ) return;

  const a = document.createElement('a');
  a.className     = 'gui-info';
  a.href          = url;
  a.target        = '_blank';
  a.rel           = 'noopener';
  a.title         = 'Background information';
  a.textContent   = ' ⓘ';                  // NBSP + circled-I
  a.style.cssText = 'margin-left:4px; text-decoration:none; ' +
                    'cursor:pointer; user-select:none; font-weight:600;';

  labelEl.appendChild( a );
}

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function leadZero(n, plus){
    let sign;
    n < 0 ? sign = "-": sign = "";
    if (sign === "" && plus) {
      sign = "+"
    }
    n = Math.abs(n);
    return n > 9 ? sign + n: sign + "0" + n;
}

function isValidTime(value) {
  const parts = value.split(':');
  // 1) must be exactly hh:mm:ss
  if (parts.length !== 3) return false;

  const [hStr, mStr, sStr] = parts;
  // 2) each piece must be two digits
  if (!/^\d{2}$/.test(hStr)) return false;
  if (!/^\d{2}$/.test(mStr)) return false;
  if (!/^\d{2}$/.test(sStr)) return false;

  const h = Number(hStr);
  const m = Number(mStr);
  const s = Number(sStr);

  // 3) valid ranges
  if (h < 0 || h > 24)      return false;
  if (m < 0 || m > 59)      return false;
  if (s < 0 || s > 59)      return false;
  // extra: only allow 24:00:00 as a special case
  if (h === 24 && (m !== 0 || s !== 0)) return false;

  return true;
}

/**
 * Validate a calendar date string in your Julian⇄Gregorian system.
 *
 * – Accepts astronomical years (“-4712-01-01” → 4713 BC)
 * – Uses Julian leap-rule for dates < 1582-10-15, Gregorian thereafter
 * – Rejects the 10 “skipped” days in Oct 1582
 *
 * @param {string} value  “YYYY-MM-DD” or “-YYYY-MM-DD”
 * @returns {boolean}
 */
function isValidDate(value) {
  // 1) Parse with a single regex; preserve leading “-” on year
  const m = /^(-?\d+)-(\d{1,2})-(\d{1,2})$/.exec(value);
  if (!m) return false;

  const Y = parseInt(m[1], 10);
  const M = parseInt(m[2], 10);
  const D = parseInt(m[3], 10);

  // 2) Basic range checks
  if (M < 1 || M > 12 || D < 1 || D > 31) {
    return false;
  }

  // 3) Reject the “skipped” days of Oct 5–14, 1582
  if (
    Y === GREGORIAN_START.year &&
    M === GREGORIAN_START.month &&
    D > 4 &&
    D < GREGORIAN_START.day
  ) {
    return false;
  }

  // 4) Decide which leap-rule applies
  const beforeGregorian =
    Y < GREGORIAN_START.year ||
    (Y === GREGORIAN_START.year && (
      M < GREGORIAN_START.month ||
      (M === GREGORIAN_START.month && D < GREGORIAN_START.day)
    ));
  const isLeap = beforeGregorian
               ? (Y % 4 === 0)  // Julian rule
               : (Y % 4 === 0 && (Y % 100 !== 0 || Y % 400 === 0));  // Gregorian

  // 5) Month lengths
  const monthLengths = [
    31,
    isLeap ? 29 : 28,
    31, 30, 31, 30,
    31, 31, 30, 31,
    30, 31
  ];
  if (D > monthLengths[M - 1]) {
    return false;
  }

  return true;
}

function addYears(sDate, year) {
  let aDate = sDate.split("-");
  let y, date;
  if (aDate.length > 3) {
    //We had a minus sign first = a BC date
    y = -Number(aDate[1])
    date = (y + year) + "-" + aDate[2] + "-" + aDate[3];
  } else {
    y = Number(aDate[0])
    date = (y + year) + "-" + aDate[1] + "-" + aDate[2];
  };
  return date
}

// === Perihelion Calendar Conversions ===

function perihelionDayToJulianDay(pd) {
  if (typeof pd !== 'number' || !Number.isFinite(pd)) {
    throw new Error(`Invalid perihelion day: ${pd}`);
  }
  // Simple offset
  return pd + (startmodelJD-perihelionalignmentJD);
}

function julianDayToPerihelionDay(jd) {
  if (typeof jd !== 'number' || !Number.isFinite(jd)) {
    throw new Error(`Invalid Julian Day: ${jd}`);
  }
  return jd - (startmodelJD-perihelionalignmentJD);
}

/**
 * Convert a Julian Day Number to a UTC calendar date + time.
 *
 * @param {number} jd  The Julian Day Number (can be fractional).
 * @returns {{ date: string, time: string, calendar: 'Julian'|'Gregorian' }}
 * @throws {TypeError} If jd is not a finite number.
 */
function dayToDate(jd) {
  if (typeof jd !== 'number' || !isFinite(jd)) {
    throw new TypeError('dayToDate: julian day must be a finite number');
  }

  // shift origin to midnight
  const J = jd + 0.5;
  const Z = Math.floor(J);
  const F = J - Z;

  // determine whether to use Julian or Gregorian calendar rules
  const isGregorian = jd >= GREGORIAN_START_JD;
  let A;
  if (!isGregorian) {
    // Julian calendar
    A = Z;
  } else {
    // Gregorian calendar correction
    const alpha = Math.floor((Z - 1867216.25) / 36524.25);
    A = Z + 1 + alpha - Math.floor(alpha / 4);
  }

  // common steps
  const B = A + 1524;
  const C = Math.floor((B - 122.1) / 365.25);
  const D = Math.floor(365.25 * C);
  const E = Math.floor((B - D) / 30.6001);

  // day with fractional part
  const dayWithFrac = B - D - Math.floor(30.6001 * E) + F;
  let day = Math.floor(dayWithFrac);
  let fracDay = dayWithFrac - day;

  // month / year
  const month = (E < 14) ? E - 1 : E - 13;
  const year = (month > 2) ? C - 4716 : C - 4715;

  //if (year <= 0) {
  //  console.warn(
  //    `dayToDate: resulting year is ${year} (astronomical numbering; year 0 = 1 BC).`
  //  );
  // }

  // convert fractional day to H:M:S
  let hours   = Math.floor(fracDay * 24);
  let minutes = Math.floor((fracDay * 24 - hours) * 60);
  let seconds = Math.floor((((fracDay * 24 - hours) * 60) - minutes) * 60 + 0.5);

  // handle rounding spill-over
  if (seconds >= 60) { seconds -= 60; minutes += 1; }
  if (minutes >= 60) { minutes -= 60; hours   += 1; }
  if (hours   >= 24) { hours   -= 24; day      += 1; 
    // note: on an extremely rare rounding boundary this could push you into the next day —
    // if that matters you could re-run the algorithm on jd + tiny epsilon.
  }

  // zero-pad helpers
  const pad2 = n => n.toString().padStart(2, '0');
  const pad4 = n => n.toString().padStart(4, '0');

  return {
    calendar: isGregorian ? 'Gregorian' : 'Julian',
    date: `${pad4(year)}-${pad2(month)}-${pad2(day)}`,
    time: `${pad2(hours)}:${pad2(minutes)}:${pad2(seconds)}`
  };
}

/**
 * Convert either a Julian or Perihelion day count into a calendar date/time
 * in either the standard Julian→Gregorian switch or a Perihelion calendar.
 *
 * @param {number} day      — the input day count (may be fractional)
 * @param {'julianday'|'perihelionday'} inputKind
 * @param {'julian-gregorian-calendar'|'perihelion-calendar'} outputKind
 * @returns {{ calendar: string, date: string, time: string }}
 * @throws {TypeError|Error} on bad input
 */
function dayToDateNew(day, inputKind, outputKind) {
  // 1) Validate
  // 1) Normalize & validate `day`
  const d = Number(day);
  if (!Number.isFinite(d)) {
    throw new TypeError(
      `dayToDateNew: first argument must be a finite number, got ${day}`
    );
  }
  day = d;

  // 2) Validate your flags
  if (inputKind !== 'julianday' && inputKind !== 'perihelionday') {
    throw new TypeError(
      `dayToDateNew: inputKind must be 'julianday' or 'perihelionday'`
    );
  }
  if (
    outputKind !== 'julian-gregorian-calendar' &&
    outputKind !== 'perihelion-calendar'
  ) {
    throw new TypeError(
      `dayToDateNew: outputKind must be 'julian-gregorian-calendar' or 'perihelion-calendar'`
    );
  }

  // 3) Turn everything into a single JD
  let jd;
  if (inputKind === 'julianday') {
    jd = day;
  } else {
    // PERIHELION → JD
    jd = day + perihelionalignmentJD;  // perihelion-day 0 was exactly JD = perihelionalignmentJD
  }

  // 4) Dispatch to the right formatter
  if (outputKind === 'julian-gregorian-calendar') {
    return dayToDate(jd);
  } else {
    return dayToPerihelionCalendarDate(jd);
  }
}

/**
 * Convert a calendar date at UTC 00:00 into Julian Day Number.
 *
 * – Accepts astronomical years (year 0 = 1 BC, –1 = 2 BC, etc.)
 * – Uses pure Julian rules before 1582-10-15, Gregorian thereafter.
 *
 * @param {number} Y   full year (may be negative or zero)
 * @param {number} M   month 1–12
 * @param {number} D   day   1–31
 * @returns {number}   Julian Day Number at 00:00 UTC
 * @throws {TypeError} on invalid inputs
 */
function dateToJulianDay(Y, M, D) {
  // 1) Validate types & ranges
  if (!Number.isInteger(Y) || !Number.isInteger(M) || !Number.isInteger(D)) {
    throw new TypeError(
      `dateToJulianDay: expected integers, got Y=${Y}, M=${M}, D=${D}`
    );
  }
  if (M < 1 || M > 12) {
    throw new TypeError(`dateToJulianDay: month out of range: ${M}`);
  }
  if (D < 1 || D > 31) {
    throw new TypeError(`dateToJulianDay: day out of range: ${D}`);
  }

  // 2) Shift Jan/Feb to months 13/14 of previous year
  let y = Y, m = M;
  if (m <= 2) {
    y -= 1;
    m += 12;
  }

  // 3) Julian vs. Gregorian correction
  let B;
  const beforeGregorian =
    Y <  GREGORIAN_START.year ||
    (Y === GREGORIAN_START.year && (
      M  < GREGORIAN_START.month ||
      (M  === GREGORIAN_START.month && D < GREGORIAN_START.day)
    ));
  if (beforeGregorian) {
    B = 0;  // Julian calendar
  } else {
    const A = Math.floor(y / 100);
    B = 2 - A + Math.floor(A / 4);
  }

  // 4) Compute JD at midnight
  const jd = Math.floor(365.25 * (y + 4716))
           + Math.floor(30.6001 * (m + 1))
           + D + B - 1524.5;

  return jd;
}

/**
 * Convert a calendar date+time (UTC) into a (possibly fractional) Julian Day Number.
 *
 * – Years may be negative or zero (astronomical numbering: 0 = 1 BC, –1 = 2 BC, …)
 * – Dates < 1582-10-15 use the Julian calendar (no century correction)
 * – Dates ≥ 1582-10-15 use the Gregorian calendar correction
 * – Time “24:00:00” is allowed and becomes the next day at 00:00
 *
 * @param {string} dateStr  “YYYY-MM-DD” or “-YYYY-MM-DD”
 * @param {string} timeStr  “hh:mm:ss” or “24:00:00”
 * @returns {number}        fractional Julian Day Number
 * @throws {TypeError}      on malformed date or time
 */
function dateTimeToJulianDay(dateStr, timeStr) {
  // — 1) parse the date, allowing a leading “-” for BC years —
  const dateRe = /^(-?\d+)-(\d{1,2})-(\d{1,2})$/;
  const dm     = dateRe.exec(dateStr);
  if (!dm) {
    throw new TypeError(
      `Invalid date "${dateStr}". Expected "YYYY-MM-DD" or "-YYYY-MM-DD".`
    );
  }
  const Y = parseInt(dm[1], 10),
        M = parseInt(dm[2], 10),
        D = parseInt(dm[3], 10);
  if (M < 1 || M > 12) {
    throw new TypeError(`Invalid month ${M} in date "${dateStr}".`);
  }
  if (D < 1 || D > 31) {
    throw new TypeError(`Invalid day ${D} in date "${dateStr}".`);
  }

  // — 2) parse the time —
  const timeRe = /^(\d{1,2}):(\d{1,2}):(\d{1,2})$/;
  const tm     = timeRe.exec(timeStr);
  if (!tm) {
    throw new TypeError(
      `Invalid time "${timeStr}". Expected "hh:mm:ss".`
    );
  }
  const hh = parseInt(tm[1], 10),
        mm = parseInt(tm[2], 10),
        ss = parseInt(tm[3], 10);

  // — 3) special‐case 24:00:00 as "next day at midnight" —
  if (hh === 24 && mm === 0 && ss === 0) {
    // compute JD at 00:00 of this date, plus one full day
    const jdMidnight = dateToJulianDay(Y, M, D);
    return jdMidnight + 1;
  }

  // — 4) otherwise validate “normal” time ranges —
  if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) {
    throw new TypeError(`Invalid time components in "${timeStr}".`);
  }

  // — 5) compute the JD at 00:00 UTC for (Y,M,D) —
  const jd0 = dateToJulianDay(Y, M, D);

  // — 6) add fractional day from time —
  const dayFraction = hh / 24 + mm / 1440 + ss / 86400;
  return jd0 + dayFraction;
}

/** Is a year leap under the old Julian rule? */
function isJulianLeapYear(y) {
  return (y % 4) === 0;
}

/** Is a year leap under the Revised-Julian rule? */
function isRevisedJulianLeapYear(y) {
  if (y % 4 !== 0) return false;
  if (y % 100 !== 0) return true;
  const r = y % 900;
  return (r === 200 || r === 600);
}

/**
 * JD → Perihelion calendar date/time (astronomical years, fractional days).
 */
function dayToPerihelionCalendarDate(jd) {
  // 1) offset so that P=0 at perihelion epoch, integer days at midnight
  const P = jd - perihelionalignmentJD + 0.5;
  let   Z = Math.floor(P);
  const F = P - Z;

  // 2) peel off whole years forward or backward
  let year       = 0;
  let daysPassed = 0;    // days from epoch to start of 'year'
  let daysInYear;

  if (Z >= 0) {
    // move forward from year=0
    while (true) {
      const yearStartJD = perihelionalignmentJD + daysPassed;
      const useRevised  = yearStartJD >= REVISION_START_JD;
      const isLeap      = useRevised
                         ? isRevisedJulianLeapYear(year)
                         : isJulianLeapYear(year);
      daysInYear = isLeap ? 366 : 365;

      if (Z >= daysInYear) {
        Z         -= daysInYear;
        daysPassed+= daysInYear;
        year++;
      } else break;
    }
  } else {
    // move backward from year=0
    while (Z < 0) {
      const prevYear = year - 1;
      // start JD of that previous year:
      //   = epoch JD + (daysPassed minus daysInPrevYear)
      const useRevised = (perihelionalignmentJD + daysPassed) >= REVISION_START_JD;
      const isLeapPrev = useRevised 
                        ? isRevisedJulianLeapYear(prevYear)
                        : isJulianLeapYear(prevYear);
      daysInYear = isLeapPrev ? 366 : 365;

      Z         += daysInYear;
      daysPassed-= daysInYear;
      year--;
    }
  }

  // 3) now Z is day-of-year in [0 .. daysInYear-1]; F is time-fraction
  //    determine leap-flag for THIS year:
  const thisYearStartJD = perihelionalignmentJD + daysPassed;
  const thisUseRevised  = thisYearStartJD >= REVISION_START_JD;
  const thisIsLeap      = thisUseRevised
                         ? isRevisedJulianLeapYear(year)
                         : isJulianLeapYear(year);

  // month/day extraction
  const monthLengths = [31, thisIsLeap?29:28,31,30,31,30,31,31,30,31,30,31];
  let  month = 1;
  let  dayOfYear = Z;
  for (const ml of monthLengths) {
    if (dayOfYear >= ml) {
      dayOfYear -= ml;
      month++;
    } else break;
  }
  const dayOfMonth = dayOfYear + 1;

  // 4) time from F
  let hh = Math.floor(F * 24);
  let mm = Math.floor((F*24 - hh)*60);
  let ss = Math.floor(((F*24 - hh)*60 - mm)*60 + 0.5);
  if (ss >= 60) { ss -= 60; mm++; }
  if (mm >= 60) { mm -= 60; hh++; }

  // zero-pad
  const p2 = n => n.toString().padStart(2,'0');
  const p4 = n => {
    const s = Math.abs(n).toString().padStart(4,'0');
    return n<0 ? `-${s}` : s;
  };

  return {
    calendar: 'Perihelion',
    date:     `${p4(year)}-${p2(month)}-${p2(dayOfMonth)}`,
    time:     `${p2(hh)}:${p2(mm)}:${p2(ss)}`
  };
}

/**
 * Convert a calendar date/time → either Julian Day or Perihelion Day.
 *
 * @param {string} dateStr
 *   – in "YYYY-MM-DD" or "-YYYY-MM-DD" (astronomical year 0 = 1 BC)
 * @param {string} timeStr
 *   – in "hh:mm:ss" or "24:00:00"
 * @param {'julian-gregorian-date'|'perihelion-date'} inputKind
 * @param {'julianday'|'perihelionday'} outputKind
 * @returns {number}  the desired day (may be fractional)
 * @throws {TypeError} on bad args
 */
function dateToDayNew(dateStr, timeStr, inputKind, outputKind) {
  // 1) validate flags
  if (inputKind !== 'julian-gregorian-date'
   && inputKind !== 'perihelion-date') {
    throw new TypeError(
      `dateToDayNew: inputKind must be `
      +`'julian-gregorian-date' or 'perihelion-date'`
    );
  }
  if (outputKind !== 'julianday'
   && outputKind !== 'perihelionday') {
    throw new TypeError(
      `dateToDayNew: outputKind must be 'julianday' or 'perihelionday'`
    );
  }

  // 2) get a single Julian Day Number (JD) from the input calendar
  let jd;
  if (inputKind === 'julian-gregorian-date') {
    // uses the dateTimeToJulianDay we built earlier
    jd = dateTimeToJulianDay(dateStr, timeStr);
  } else {
    // perihelion-date → JD via our reverse‐perihelion helper
    jd = dateToPerihelionJulianDay(dateStr, timeStr);
  }

  // 3) dispatch to the desired output
  if (outputKind === 'julianday') {
    return jd;
  } else {
    // perihelionday = JD – perihelionalignmentJD
    return julianDayToPerihelionDay(jd);
  }
}

/*––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
  Helper: calendar‐date (perihelion) → Julian Day Number
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––*/

function dateToPerihelionJulianDay(dateStr, timeStr) {
  // parse date (allows "-YYYY")
  const dm = /^(-?\d+)-(\d{1,2})-(\d{1,2})$/.exec(dateStr);
  if (!dm) throw new TypeError(
    `Invalid date "${dateStr}". Expected "YYYY-MM-DD" or "-YYYY-MM-DD".`
  );
  const Y = parseInt(dm[1], 10),
        M = parseInt(dm[2], 10),
        D = parseInt(dm[3], 10);
  if (M < 1 || M > 12) throw new TypeError(`Invalid month ${M}`);
  if (D < 1 || D > 31) throw new TypeError(`Invalid day ${D}`);

  // parse time, special‐case "24:00:00"
  const tm = /^(\d{1,2}):(\d{1,2}):(\d{1,2})$/.exec(timeStr);
  if (!tm) throw new TypeError(
    `Invalid time "${timeStr}". Expected "hh:mm:ss".`
  );
  let [ hh, mm, ss ] = tm.slice(1).map(x=>parseInt(x,10));
  if (hh === 24 && mm === 0 && ss === 0) {
    // midnight rollover → JD @ next midnight
    return dateToPerihelionJulianDay(dateStr, '00:00:00') + 1;
  }
  if (hh<0||hh>23||mm<0||mm>59||ss<0||ss>59) {
    throw new TypeError(`Invalid time components in "${timeStr}".`);
  }

  // 1) days since perihelion‐epoch to the START of year Y
  let daysAcc = 0, year = 0;
  if (Y >= 0) {
    for (; year < Y; year++) {
      const startJD    = perihelionalignmentJD + daysAcc;
      const useRevised = startJD >= REVISION_START_JD;
      const isLeap     = useRevised
                        ? isRevisedJulianLeapYear(year)
                        : isJulianLeapYear(year);
      daysAcc += (isLeap ? 366 : 365);
    }
  } else {
    for (year = 0; year > Y; year--) {
      const startJD    = perihelionalignmentJD + daysAcc;
      const useRevised = startJD >= REVISION_START_JD;
      const isLeap     = useRevised
                        ? isRevisedJulianLeapYear(year-1)
                        : isJulianLeapYear(year-1);
      daysAcc -= (isLeap ? 366 : 365);
    }
  }

  // 2) add days for the months BEFORE M in year Y
  //    figure out if year Y is leap
  const yearStartJD  = perihelionalignmentJD + daysAcc;
  const useRevisedY  = yearStartJD >= REVISION_START_JD;
  const isLeapY      = useRevisedY
                      ? isRevisedJulianLeapYear(year)
                      : isJulianLeapYear(year);
  const monthLens    = [31, isLeapY?29:28,31,30,31,30,31,31,30,31,30,31];
  let dayOfYear      = D - 1;
  for (let m = 1; m < M; m++) {
    dayOfYear += monthLens[m-1];
  }

  // 3) fold into a Julian Day Number
  //    JD = periAlignJD + daysAcc + dayOfYear + timeFrac - 0.5
  const timeFrac = hh/24 + mm/1440 + ss/86400;
  return perihelionalignmentJD
       + daysAcc
       + dayOfYear
       + timeFrac
       - 0.5;
}

//*************************************************************
// Date functions
//*************************************************************

// --- REQUIREMENT: a global startmodelJD must already exist and be finite (may be fractional)
if (!(typeof startmodelJD === 'number' && isFinite(startmodelJD))) {
  throw new TypeError(`Expected global startmodelJD as a finite number, got ${startmodelJD}`);
}

// -------------------------
// JDN <-> calendar helpers
// -------------------------

// JDN from a Gregorian date (astronomical year numbering: year 0 allowed)
function jdnFromGregorian(y, m, d) {
  const a  = Math.floor((14 - m) / 12);
  const y2 = y + 4800 - a;
  const m2 = m + 12*a - 3;
  return d + Math.floor((153*m2 + 2)/5) + 365*y2 + Math.floor(y2/4)
       - Math.floor(y2/100) + Math.floor(y2/400) - 32045;
}

// JDN from a Julian date
function jdnFromJulian(y, m, d) {
  const a  = Math.floor((14 - m) / 12);
  const y2 = y + 4800 - a;
  const m2 = m + 12*a - 3;
  return d + Math.floor((153*m2 + 2)/5) + 365*y2 + Math.floor(y2/4) - 32083;
}

// Gregorian date from integer JDN
function gregorianFromJdn(J) {
  const a = J + 32044;
  const b = Math.floor((4*a + 3) / 146097);
  const c = a - Math.floor(146097*b / 4);
  const d = Math.floor((4*c + 3) / 1461);
  const e = c - Math.floor(1461*d / 4);
  const m = Math.floor((5*e + 2) / 153);
  const day = e - Math.floor((153*m + 2) / 5) + 1;
  const month = m + 3 - 12 * Math.floor(m / 10);
  const year = b*100 + d - 4800 + Math.floor(m / 10);
  return { y: year, m: month, d: day };
}

// Julian date from integer JDN
function julianFromJdn(J) {
  const c = J + 32082;
  const d = Math.floor((4*c + 3) / 1461);
  const e = c - Math.floor(1461*d / 4);
  const m = Math.floor((5*e + 2) / 153);
  const day = e - Math.floor((153*m + 2) / 5) + 1;
  const month = m + 3 - 12 * Math.floor(m / 10);
  const year = d - 4800 + Math.floor(m / 10);
  return { y: year, m: month, d: day };
}

// Gregorian reform switch (first Gregorian civil date = 1582-10-15)
const GREG_START_JDN = jdnFromGregorian(1582, 10, 15);

// --------------------
// Parsing & utilities
// --------------------
function pad2(n) { return String(n).padStart(2, "0"); }

// Civil-date check (ignores any fractional day)
function isJulianDate(y, m, d) {
  return (y < 1582) || (y === 1582 && (m < 10 || (m === 10 && d < 15)));
}

// Accepts "YYYY-MM-DD" or "YYYY-MM-DD.f" (and "-YYYY-...").
// Returns { y, m, dInt, frac } with 0 ≤ frac < 1 (fraction of day since MIDNIGHT).
function parseYMDAllowingFraction(sDate) {
  if (typeof sDate !== 'string') {
    throw new TypeError(`Invalid date "${sDate}". Expected "YYYY-MM-DD" or "-YYYY-MM-DD".`);
  }

  const parts = sDate.split("-");
  let y, m, dStr;

  if (sDate.startsWith("-")) {
    if (parts.length !== 4) {
      throw new TypeError(`Invalid date "${sDate}". Expected "-YYYY-MM-DD" or "-YYYY-MM-DD.f".`);
    }
    y = -Number(parts[1]);
    m = Number(parts[2]);
    dStr = parts[3];
  } else {
    if (parts.length !== 3) {
      throw new TypeError(`Invalid date "${sDate}". Expected "YYYY-MM-DD" or "YYYY-MM-DD.f".`);
    }
    y = Number(parts[0]);
    m = Number(parts[1]);
    dStr = parts[2];
  }

  const dFloat = Number(dStr);
  if (![y, m, dFloat].every(Number.isFinite)) {
    throw new TypeError(`Invalid date "${sDate}". Expected "YYYY-MM-DD" or "-YYYY-MM-DD".`);
  }
  if (m < 1 || m > 12) {
    throw new TypeError(`Invalid date "${sDate}". Month must be 1–12.`);
  }

  const dInt = Math.floor(dFloat);
  const frac = dFloat - dInt;
  if (dInt < 1 || dInt > 31 || frac < 0 || frac >= 1) {
    throw new TypeError(`Invalid date "${sDate}". Day must be 1–31 (fractional part 0 ≤ f < 1).`);
  }

  return { y, m, dInt, frac };
}

// ------------------------------------------------------
// Public helpers (drop-in): handle fractional days too
// ------------------------------------------------------

// Convert "YYYY-MM-DD" or "...-DD.f" to (possibly fractional) days since startmodelJD
function dateToDays(sDate) {
  const { y, m, dInt, frac } = parseYMDAllowingFraction(sDate);

  // Calendar selection based on civil date (ignore time-of-day)
  const useJulian = isJulianDate(y, m, dInt);
  const baseJDN = useJulian ? jdnFromJulian(y, m, dInt) : jdnFromGregorian(y, m, dInt);

  // JD convention: integer boundary at NOON; fraction is measured from MIDNIGHT.
  // So JD = baseJDN + (frac - 0.5).
  const JD = baseJDN + (frac - 0.5);

  return JD - startmodelJD;  // startmodelJD may be fractional
}

// Convert (possibly fractional) days since startmodelJD to a civil date (no fraction)
function daysToDate(g) {
  if (!Number.isFinite(g)) {
    throw new TypeError(`daysToDate expected a finite number but got ${g}`);
  }

  const JD = startmodelJD + g;
  const JDNint = Math.floor(JD + 0.5);   // map JD (noon-based) to civil day

  const useJulian = JDNint < GREG_START_JDN;
  const { y, m, d } = useJulian ? julianFromJdn(JDNint) : gregorianFromJdn(JDNint);
  return `${y}-${pad2(m)}-${pad2(d)}`;
}

// Same as above, but include the fractional day in the last field for display
function daysToDateWithFraction(g, precision = 9) {
  const JD = startmodelJD + g;
  const JDNint = Math.floor(JD + 0.5);
  const fracFromMidnight = JD - (JDNint - 0.5);  // ∈ [0,1)

  const useJulian = JDNint < GREG_START_JDN;
  const { y, m, d } = useJulian ? julianFromJdn(JDNint) : gregorianFromJdn(JDNint);

  const dayWithFrac = (d + fracFromMidnight).toFixed(precision)
    .replace(/0+$/,'').replace(/\.$/,'');
  return `${y}-${pad2(m)}-${dayWithFrac}`;
}

// Keep this name if other code calls it; returns a Julian-calendar date (no fraction)
function julianCalDayToDate(g) {
  const JD = startmodelJD + g;
  const JDNint = Math.floor(JD + 0.5);
  const { y, m, d } = julianFromJdn(JDNint);
  return `${y}-${pad2(m)}-${pad2(d)}`;
} 
